<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pronosticador de Fútbol — Poisson + Monte Carlo</title>

  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

  <!-- Chart.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg:#0f1724; --card:#0b1220; --muted:#9aa6bf; --accent:#3b82f6; --glass: rgba(255,255,255,0.03);
      --radius:12px;
    }
    *{box-sizing:border-box}
    body{
      font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
      margin:0; padding:28px; background:linear-gradient(180deg,#071029 0%, #051226 100%); color:#e6eef8;
      min-height:100vh;
    }
    .wrap{max-width:1100px;margin:0 auto;display:grid;gap:18px;grid-template-columns:1fr 420px;}
    header{grid-column:1/-1;display:flex;align-items:center;gap:16px;}
    h1{margin:0;font-size:20px}
    .card{background:var(--card);border-radius:var(--radius);padding:16px;border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    label{display:block;font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type="text"], input[type="number"], select{
      width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);
      background:var(--glass); color:inherit; font-size:14px;
    }
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .btn{background:var(--accent);color:white;padding:10px 12px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .muted{color:var(--muted);font-size:13px}
    .result-box{background:linear-gradient(180deg, rgba(59,130,246,0.08), transparent);padding:12px;border-radius:10px}
    small{color:var(--muted)}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:6px;text-align:left;border-bottom:1px dashed rgba(255,255,255,0.03)}
    .footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:13px;padding-top:6px}
    @media(max-width:980px){ .wrap{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Pronosticador: Poisson + Monte Carlo</h1>
        <div class="muted">Introduce parámetros rápidos y obtén probabilidades 1X2, Over/Under 2.5 y BTTS. Opcional: añade cuotas para ver EV y stake por Kelly.</div>
      </div>
    </header>

    <!-- Left: Controls + Results -->
    <div class="card">
      <h3>Entradas del partido</h3>

      <div class="grid-2">
        <div>
          <label>Equipo local</label>
          <input id="homeName" type="text" placeholder="Ej. Real Madrid" value="Local FC">
        </div>
        <div>
          <label>Equipo visitante</label>
          <input id="awayName" type="text" placeholder="Ej. Barcelona" value="Visitante United">
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="grid-2">
        <div>
          <label>Goles esperados (λ) — local</label>
          <input id="lambdaHome" type="number" min="0" step="0.01" value="1.6">
        </div>
        <div>
          <label>Goles esperados (λ) — visitante</label>
          <input id="lambdaAway" type="number" min="0" step="0.01" value="1.1">
        </div>
      </div>

      <div style="height:10px"></div>

      <label>Opciones de simulación</label>
      <div class="grid-2">
        <div>
          <label>Nº simulaciones (Monte Carlo)</label>
          <input id="sims" type="number" min="100" step="100" value="5000">
        </div>
        <div>
          <label>Max goles mostrados (tabla)</label>
          <input id="maxGoals" type="number" min="1" max="10" value="6">
        </div>
      </div>

      <div style="height:12px"></div>

      <h4>Cuotas (opcional)</h4>
      <div class="grid-2">
        <div>
          <label>Cuota Local (decimal)</label>
          <input id="oddsHome" type="number" min="1" step="0.01" placeholder="Ej. 1.85">
        </div>
        <div>
          <label>Cuota Empate</label>
          <input id="oddsDraw" type="number" min="1" step="0.01" placeholder="Ej. 3.70">
        </div>
      </div>
      <div style="height:8px"></div>
      <div class="grid-2" style="margin-bottom:10px">
        <div>
          <label>Cuota Visitante</label>
          <input id="oddsAway" type="number" min="1" step="0.01" placeholder="Ej. 4.20">
        </div>
        <div>
          <label>Bankroll (unidades) para Kelly</label>
          <input id="bankroll" type="number" min="1" step="1" value="100">
        </div>
      </div>

      <div style="display:flex;gap:10px;margin-top:10px">
        <button class="btn" id="runBtn">Calcular pronóstico</button>
        <button class="btn" id="simBtn" style="background:#0ea5a4">Ejecutar sólo Monte Carlo</button>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:14px 0" />

      <div id="summaryArea">
        <h3>Resultados</h3>
        <div class="result-box" id="mainResults">
          <div style="display:flex;gap:8px;flex-wrap:wrap">
            <div style="min-width:180px">
              <small>Prob. Local</small>
              <div id="pHome" style="font-weight:700;font-size:18px">—</div>
            </div>
            <div style="min-width:160px">
              <small>Prob. Empate</small>
              <div id="pDraw" style="font-weight:700;font-size:18px">—</div>
            </div>
            <div style="min-width:160px">
              <small>Prob. Visitante</small>
              <div id="pAway" style="font-weight:700;font-size:18px">—</div>
            </div>
            <div style="min-width:160px">
              <small>Prob. Over 2.5</small>
              <div id="pOver" style="font-weight:700;font-size:18px">—</div>
            </div>
            <div style="min-width:160px">
              <small>Prob. BTTS (ambos marcan)</small>
              <div id="pBTTS" style="font-weight:700;font-size:18px">—</div>
            </div>
          </div>

          <div style="height:8px"></div>
          <div id="evArea" style="display:flex;gap:10px;flex-wrap:wrap;margin-top:8px"></div>
        </div>

        <div style="height:12px"></div>

        <h4>Distribución de goles (probabilidades teóricas)</h4>
        <canvas id="goalsChart" height="180"></canvas>

        <div style="height:12px"></div>

        <h4>Tabla de probabilidades 0..N goles (local x visitante)</h4>
        <div style="overflow:auto;max-height:280px">
          <table id="probTable"><thead></thead><tbody></tbody></table>
        </div>

        <div style="height:10px"></div>

        <h4>Monte Carlo (simulación)</h4>
        <div class="muted">Si ejecutas la simulación, verás probabilidades empíricas basadas en <span id="simsCountText">—</span> partidas simuladas.</div>
        <div style="height:8px"></div>
        <div id="mcResults" class="muted" style="font-size:14px"></div>
      </div>
    </div>

    <!-- Right: Info + Tips -->
    <aside class="card">
      <h3>Cómo usar</h3>
      <ul class="muted" style="padding-left:16px">
        <li>Introduce λ (goles esperados). Si no sabes, usa tus modelos o promedios de la temporada.</li>
        <li>Haz click en "Calcular pronóstico" para ver las probabilidades teóricas (Poisson).</li>
        <li>Introduce cuotas para ver EV y stake recomendado por Kelly.</li>
        <li>Usa Monte Carlo para estimaciones empíricas (útil si quieres modelar factores no-Poisson).</li>
      </ul>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04)" />

      <h4>Explicaciones rápidas</h4>
      <div class="muted" style="font-size:13px">
        <strong>Poisson:</strong> modela el número de goles como Poisson(λ).  
        <strong>Monte Carlo:</strong> simula goles aleatorios con media λ para estimar probabilidades empíricas.  
        <strong>Kelly:</strong> fracción sugerida de tu bankroll: f = (bp - q) / b, donde b = odds-1, p = prob. estimada, q = 1-p.
      </div>

      <div style="height:12px"></div>

      <h4>Consejos</h4>
      <ol class="muted" style="padding-left:16px">
        <li>Calibra tus λ con datos reales (promedios por rivalidad/liga/cuotas).</li>
        <li>Limita stake por Kelly (por ejemplo usar 10%-50% de Kelly para reducir varianza).</li>
        <li>Combina Poisson con ajustes por forma, lesiones y localía.</li>
      </ol>

      <div style="height:12px"></div>
      <small class="muted">Hecho con ❤️ — modelo simple para explorar ideas, no una recomendación de apuestas.</small>
    </aside>

    <div class="footer">© Pronosticador Poisson — ejemplo educativo</div>
  </div>

<script>
/* ---------- Utilidades matemáticas ---------- */
function poissonProb(lambda, k){
  // P(X=k) = e^-λ * λ^k / k!
  if (k < 0) return 0;
  return Math.exp(-lambda) * Math.pow(lambda, k) / factorial(k);
}
function factorial(n){
  if (n <= 1) return 1;
  let f = 1;
  for (let i=2;i<=n;i++) f *= i;
  return f;
}
function cumulativePoissonGreater(lambda, threshold){
  // P(X > threshold) = 1 - sum_{k=0..threshold} P(X=k)
  let sum = 0;
  for (let k=0;k<=threshold;k++) sum += poissonProb(lambda,k);
  return Math.max(0, 1 - sum);
}

/* Monte Carlo: genera goles aleatorios Poisson usando aproximación de Knuth */
function samplePoisson(lambda){
  // Si lambda < 30 usaremos el algoritmo clásico; para lambda grande, usar aproximación normal
  if (lambda < 30) {
    let L = Math.exp(-lambda);
    let k = 0, p = 1;
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  } else {
    // aproximación normal con corrección (no perfecto pero evita loops)
    let val = Math.round(randn_bm() * Math.sqrt(lambda) + lambda);
    return Math.max(0, val);
  }
}
function randn_bm() {
  // Box-Muller
  let u = 0, v = 0;
  while(u === 0) u = Math.random();
  while(v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

/* ---------- Lógica principal ---------- */
document.getElementById('runBtn').addEventListener('click', runAll);
document.getElementById('simBtn').addEventListener('click', runMonteCarloOnly);

function runAll(){
  // obtiene inputs
  const lambdaH = parseFloat(document.getElementById('lambdaHome').value) || 0;
  const lambdaA = parseFloat(document.getElementById('lambdaAway').value) || 0;
  const maxG = parseInt(document.getElementById('maxGoals').value) || 6;
  const sims = parseInt(document.getElementById('sims').value) || 5000;
  const oddsH = parseFloat(document.getElementById('oddsHome').value) || null;
  const oddsD = parseFloat(document.getElementById('oddsDraw').value) || null;
  const oddsA = parseFloat(document.getElementById('oddsAway').value) || null;
  const bankroll = parseFloat(document.getElementById('bankroll').value) || 0;

  // matriz de probabilidades teóricas (0..maxG)
  let probMatrix = [];
  for (let i=0;i<=maxG;i++){
    probMatrix[i] = [];
    for (let j=0;j<=maxG;j++){
      probMatrix[i][j] = poissonProb(lambdaH, i) * poissonProb(lambdaA, j);
    }
  }

  // Probabilidades 1X2 teóricas
  let pHome = 0, pDraw = 0, pAway = 0;
  for (let i=0;i<=maxG;i++){
    for (let j=0;j<=maxG;j++){
      const p = probMatrix[i][j];
      if (i>j) pHome += p;
      else if (i===j) pDraw += p;
      else pAway += p;
    }
  }
  // Resto de probabilidad por eventos fuera de la tabla (goles mayores a maxG)
  // Para mayor exactitud, ajustamos con colas:
  const tailProbH = 1 - sumPoissonTo(lambdaH, maxG);
  const tailProbA = 1 - sumPoissonTo(lambdaA, maxG);
  // Probabilidad aproximada de home wins por colas (aprox: when either side > maxG)
  // La matriz truncada subestima escenarios donde alguno marca >maxG. Compensamos aproximando:
  // Añadimos P(local > maxG, away <= maxG) * approxProb + P(local>maxG, away>maxG)*0.5
  // pero para simplicidad añadimos la masa de cola marginal de cada lado as empate neutrally distributed.
  // Esto is approximate; user can increase maxGoals for precision.
  const remainingMass = (1 - matrixSum(probMatrix));
  // renormalizamos (simple) para que pHome+pDraw+pAway sumen ~1
  const sum3 = pHome + pDraw + pAway;
  if (sum3 > 0) {
    pHome /= sum3; pDraw /= sum3; pAway /= sum3;
  }

  // Over 2.5 (teórico): P(home_goals + away_goals > 2.5)
  let pOver25 = 0;
  for (let i=0;i<=maxG;i++){
    for (let j=0;j<=maxG;j++){
      if (i + j > 2) pOver25 += probMatrix[i][j];
    }
  }
  // approximate tail: if remainingMass > 0 and expectation suggests more goals, adjust slightly (skip complex)
  // BTTS (ambos marcan)
  let pBTTS = 0;
  for (let i=1;i<=maxG;i++){
    for (let j=1;j<=maxG;j++){
      pBTTS += probMatrix[i][j];
    }
  }

  // Mostrar resultados teóricos
  showMainResults(pHome, pDraw, pAway, pOver25, pBTTS, oddsH, oddsD, oddsA, bankroll);

  // dibujar matriz y distribuciones
  renderProbTable(probMatrix, maxG);
  renderGoalsChart(lambdaH, lambdaA, maxG);

  // correr Monte Carlo (async para no bloquear UI cuando sims grandes)
  runMonteCarlo(lambdaH, lambdaA, sims).then(mc => {
    displayMC(mc, sims);
  });
}

function runMonteCarloOnly(){
  const lambdaH = parseFloat(document.getElementById('lambdaHome').value) || 0;
  const lambdaA = parseFloat(document.getElementById('lambdaAway').value) || 0;
  const sims = parseInt(document.getElementById('sims').value) || 5000;
  document.getElementById('simsCountText').textContent = sims;
  document.getElementById('mcResults').textContent = 'Simulando... (esto puede tardar unos segundos)';
  runMonteCarlo(lambdaH, lambdaA, sims).then(mc => {
    displayMC(mc, sims);
  });
}

function runMonteCarlo(lambdaH, lambdaA, sims){
  document.getElementById('simsCountText').textContent = sims;
  return new Promise((resolve) => {
    // run in slices to keep UI responsive
    let simDone = 0;
    let result = {home:0, draw:0, away:0, over25:0, btts:0};
    const chunk = 1000;
    function workBatch(){
      const limit = Math.min(chunk, sims - simDone);
      for (let s=0;s<limit;s++){
        const gH = samplePoisson(lambdaH);
        const gA = samplePoisson(lambdaA);
        if (gH > gA) result.home++;
        else if (gH === gA) result.draw++;
        else result.away++;
        if (gH + gA > 2) result.over25++;
        if (gH > 0 && gA > 0) result.btts++;
      }
      simDone += limit;
      if (simDone < sims){
        // yield to event loop
        setTimeout(workBatch, 0);
      } else {
        // normalize
        for (let k in result) result[k] = result[k] / sims;
        resolve(result);
      }
    }
    workBatch();
  });
}

/* ---------- Visualización y helpers ---------- */
function showMainResults(pH, pD, pA, pOver, pBTTS, oddsH, oddsD, oddsA, bankroll){
  document.getElementById('pHome').textContent = (pH*100).toFixed(2) + '%';
  document.getElementById('pDraw').textContent = (pD*100).toFixed(2) + '%';
  document.getElementById('pAway').textContent = (pA*100).toFixed(2) + '%';
  document.getElementById('pOver').textContent = (pOver*100).toFixed(2) + '%';
  document.getElementById('pBTTS').textContent = (pBTTS*100).toFixed(2) + '%';

  // EV and Kelly if odds provided
  const evArea = document.getElementById('evArea');
  evArea.innerHTML = '';
  const addEV = (label, prob, odds) => {
    if (!odds || odds <= 0) return;
    const ev = prob * odds - 1;
    const b = odds - 1;
    const q = 1 - prob;
    let kelly = (prob * b - q) / b;
    // cap sane values
    if (!isFinite(kelly)) kelly = 0;
    // suggestion: use fraction of Kelly, e.g., 20-50% recommended in practice — we show full Kelly
    const unitStake = bankroll ? (kelly * bankroll) : kelly;
    const div = document.createElement('div');
    div.style.minWidth = '220px';
    div.innerHTML = `<small>${label}</small>
      <div style="font-weight:700">${(ev*100).toFixed(2)}% EV — Kelly: ${(kelly*100).toFixed(2)}% ${bankroll?'- stake: '+unitStake.toFixed(2)+' u':''}</div>`;
    evArea.appendChild(div);
  };

  addEV('Local', pH, oddsH);
  addEV('Empate', pD, oddsD);
  addEV('Visitante', pA, oddsA);
}

let goalsChart = null;
function renderGoalsChart(lambdaH, lambdaA, maxG){
  const labels = [];
  const dataH = [];
  const dataA = [];
  for (let k=0;k<=maxG;k++){
    labels.push(String(k));
    dataH.push(poissonProb(lambdaH, k));
    dataA.push(poissonProb(lambdaA, k));
  }
  const ctx = document.getElementById('goalsChart').getContext('2d');
  if (goalsChart) goalsChart.destroy();
  goalsChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels,
      datasets: [
        { label: 'Local (λ='+lambdaH+')', data: dataH, stack: 's1' },
        { label: 'Visitante (λ='+lambdaA+')', data: dataA, stack: 's2' }
      ]
    },
    options: {
      responsive:true,
      scales:{
        x:{ stacked:true, ticks:{color:'#cbd5e1'} },
        y:{ stacked:false, beginAtZero:true, ticks:{color:'#cbd5e1'} }
      },
      plugins:{
        legend:{labels:{color:'#cbd5e1'}}
      }
    }
  });
}

function renderProbTable(matrix, maxG){
  const table = document.getElementById('probTable');
  const thead = table.querySelector('thead');
  const tbody = table.querySelector('tbody');
  thead.innerHTML = '';
  tbody.innerHTML = '';

  // header
  let headRow = '<tr><th>Local \\ Visitante</th>';
  for (let j=0;j<=maxG;j++) headRow += `<th>${j}</th>`;
  headRow += '</tr>';
  thead.innerHTML = headRow;

  for (let i=0;i<=maxG;i++){
    let row = `<tr><th>${i}</th>`;
    for (let j=0;j<=maxG;j++){
      row += `<td>${(matrix[i][j]*100).toFixed(2)}%</td>`;
    }
    row += '</tr>';
    tbody.innerHTML += row;
  }
}

/* ---------- Utilities ---------- */
function sumPoissonTo(lambda, maxG){
  let s = 0;
  for (let k=0;k<=maxG;k++) s += poissonProb(lambda,k);
  return s;
}
function matrixSum(mat){
  let s = 0;
  for (let i=0;i<mat.length;i++){
    for (let j=0;j<mat[i].length;j++) s += mat[i][j];
  }
  return s;
}

function displayMC(mc, sims){
  const el = document.getElementById('mcResults');
  el.innerHTML = `Simulación (${sims}): <strong>Local ${(mc.home*100).toFixed(2)}%</strong> — <strong>Empate ${(mc.draw*100).toFixed(2)}%</strong> — <strong>Visit ${(mc.away*100).toFixed(2)}%</strong>
  <br> Over 2.5: ${(mc.over25*100).toFixed(2)}% — BTTS: ${(mc.btts*100).toFixed(2)}%`;
}

/* run initial demo once */
runAll();
</script>
</body>
</html>