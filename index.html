<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poisson • OU + BTTS + 1X2 — EV, Overround y Kelly 1/4 (con historial)</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel2:#1f2430; --text:#e8ecf3; --muted:#9aa3b2;
    --accent:#7aa2ff; --accent2:#5dd4a4; --warn:#ffb84d; --danger:#ff6b6b; --ok:#79e2a6; --border:#2a3140;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(180deg,#0f1115 0%,#121622 100%); color:var(--text)}
  header{padding:20px 16px; border-bottom:1px solid var(--border); background:#10141d; position:sticky; top:0; z-index:5}
  h1{margin:0; font-size:18px; letter-spacing:.3px}
  .wrap{max-width:1200px; margin:0 auto; padding:16px}
  .grid{display:grid; gap:16px}
  @media(min-width:900px){ .grid-cols-2{grid-template-columns:1fr 1fr} .grid-cols-3{grid-template-columns:1.1fr 1fr 1fr}}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px}
  .card h2{margin:.2rem 0 .8rem; font-size:16px}
  label{font-size:12px; color:var(--muted); display:block; margin:.25rem 0 .35rem}
  input[type="text"],input[type="number"],select,textarea{
    width:100%; background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:10px;
    padding:10px 12px; outline:none; font-size:14px;
  }
  .btn{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--border); background:#111827; color:var(--text);
       padding:10px 12px; border-radius:10px; cursor:pointer; text-decoration:none; font-size:14px; user-select:none}
  .btn.primary{background:linear-gradient(90deg,#2647ff,#1fa37e); border-color:transparent}
  .btn.ghost{background:transparent}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .btn.cta{font-weight:700; box-shadow:0 6px 20px rgba(38,71,255,.25), 0 2px 8px rgba(31,163,126,.25); position:relative}
  .btn.cta::after{content:""; position:absolute; inset:-1px; border-radius:10px; background:linear-gradient(90deg, rgba(122,162,255,.15), rgba(93,212,164,.15)); pointer-events:none}
  @media (prefers-reduced-motion: no-preference){
    .pulse{ animation:pulse 2.2s ease-in-out infinite; }
    @keyframes pulse{ 0%{ transform:scale(1) } 50%{ transform:scale(1.02) } 100%{ transform:scale(1) } }
  }
  .muted{color:var(--muted)}
  .kpi{display:flex; gap:12px; flex-wrap:wrap}
  .pill{padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,.03)}
  .pill.ok{border-color:#234d3b; background:rgba(121,226,166,.08); color:var(--accent2)}
  .pill.warn{border-color:#554224; background:rgba(255,184,77,.1); color:var(--warn)}
  .pill.bad{border-color:#5a2b2b; background:rgba(255,107,107,.1); color:var(--danger)}
  .badge{display:inline-block; padding:3px 8px; border-radius:999px; font-size:12px; border:1px solid var(--border)}
  .badge.accept{background:rgba(121,226,166,.1); color:var(--accent2); border-color:#2a5747}
  .badge.medium{background:rgba(255,184,77,.1); color:var(--warn); border-color:#5a4b2b}
  .badge.bad{background:rgba(255,107,107,.1); color:var(--danger); border-color:#5a2b2b}
  table{width:100%; border-collapse:separate; border-spacing:0}
  th,td{padding:10px 12px; border-bottom:1px solid var(--border); text-align:left; font-size:14px}
  th{color:var(--muted); font-weight:600; font-size:12px}
  .right{text-align:right}
  .flex{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .topbar{display:flex; align-items:center; gap:12px; justify-content:space-between}
  .links{display:flex; gap:8px; flex-wrap:wrap}
  .sep{height:1px; background:var(--border); margin:12px 0}
  .hint{font-size:12px; color:var(--muted)}
  .success{color:var(--accent2)}
  .danger{color:var(--danger)}
  .tiny{font-size:11px}
  .center{display:flex; align-items:center}
  @media(max-width:768px){ .grid-cols-2{grid-template-columns:1fr !important;} .grid-cols-3{grid-template-columns:1fr !important;} }
  @media(max-width:430px){
    .wrap{padding:8px}
    h1{font-size:16px}
    .card h2{font-size:14px}
    .btn{padding:10px 12px; font-size:15px}
    .btn.cta{width:100%}
    input,select,textarea{padding:8px 10px; font-size:14px}
  }
  .card table{display:block; overflow-x:auto; -webkit-overflow-scrolling:touch}
  /* Badge Prob ≥55% */
  #modelBox b[data-flag="1"]::after{
    content: " ≥55%"; margin-left:6px; font-weight:600; font-size:11px;
    color:var(--accent2); padding:2px 6px; border-radius:999px; border:1px solid #2a5747; background:rgba(121,226,166,.10);
  }
  .tag{display:inline-block; margin-left:6px; font-size:10px; padding:2px 6px; border-radius:999px; border:1px solid var(--border); color:var(--muted)}
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="topbar">
        <h1>Poisson • OU + BTTS + 1X2 — EV, Overround y Kelly 1/4 (con historial)</h1>
        <div class="links">
          <a href="historial.html" class="btn" aria-label="Abrir historial general">Abrir historial</a>
          <a href="historialpre.html" class="btn" aria-label="Abrir historial prepartido">Abrir historial prepartido</a>
          <a href="overraund.html" class="btn" aria-label="Abrir calculadora de Overround">Calculadora Overround</a>
        </div>
      </div>
    </div>
  </header>

  <div class="wrap grid grid-cols-2">
    <section class="card" aria-labelledby="cargar-datos">
      <h2 id="cargar-datos">1) Cargar datos</h2>
      <div class="grid">
        <div>
          <label for="file">Archivo JSON (array / objeto / NDJSON)</label>
          <input type="file" id="file" accept=".json,application/json,.txt" />
        </div>
      </div>
      <div class="hint tiny" style="margin-top:8px">Al seleccionar el archivo se procesará automáticamente. Después elige liga y equipos.</div>
      <div id="ingestStatus" class="hint" style="margin-top:8px"></div>
    </section>

    <section class="card" aria-labelledby="seleccion">
      <h2 id="seleccion">2) Selección (Liga y Equipos)</h2>
      <div class="grid">
        <div>
          <label for="selLeague">Liga</label>
          <select id="selLeague"></select>
        </div>
        <div class="grid grid-cols-2">
          <div>
            <label for="selHome">Equipo Local</label>
            <select id="selHome"></select>
          </div>
          <div>
            <label for="selAway">Equipo Visitante</label>
            <select id="selAway"></select>
          </div>
        </div>
      </div>
      <div class="sep"></div>
      <div class="grid grid-cols-3">
        <div>
          <label for="ouLine">Línea OU (ej. 2.5)</label>
          <input type="number" id="ouLine" step="0.5" value="2.5" />
          <div class="hint tiny">Si pones entero (p.ej. 2.0) se interpreta como mercado europeo (sin push).</div>
        </div>
        <div>
          <label for="bankroll">Bankroll</label>
          <input type="number" id="bankroll" step="1" value="1000" />
          <div class="hint tiny">Kelly 1/4 (mín 1% y máx 3% cuando EV&gt;0).</div>
        </div>
        <div>
          <label for="maxGoals">Máx. goles sumados (Poisson)</label>
          <input type="number" id="maxGoals" step="1" min="6" value="10" />
          <div class="hint tiny">Tope de suma para las convoluciones de goles.</div>
        </div>
      </div>
      <div class="hint tiny" style="margin-top:10px">El modelo se calcula <b>automáticamente</b> al escoger liga y equipos (y al ajustar OU o Máx. goles).</div>
    </section>

    <section class="card" aria-labelledby="cuotas">
      <h2 id="cuotas">3) Cuotas (introduce para Overround, EV y Kelly 1/4)</h2>
      <div class="grid">
        <div class="grid grid-cols-3">
          <div>
            <label for="oddOver">Over (OU)</label>
            <input type="number" id="oddOver" step="0.01" placeholder="ej. 1.95" />
          </div>
          <div>
            <label for="oddUnder">Under (OU)</label>
            <input type="number" id="oddUnder" step="0.01" placeholder="ej. 1.85" />
          </div>
          <div class="center"><span class="muted tiny">Mercado: Over/Under</span></div>
        </div>
        <div class="grid grid-cols-3">
          <div>
            <label for="oddBTTSY">BTTS Sí</label>
            <input type="number" id="oddBTTSY" step="0.01" placeholder="ej. 1.95" />
          </div>
          <div>
            <label for="oddBTTSN">BTTS No</label>
            <input type="number" id="oddBTTSN" step="0.01" placeholder="ej. 1.85" />
          </div>
          <div class="center"><span class="muted tiny">Mercado: BTTS</span></div>
        </div>
      </div>
      <div class="flex" style="margin-top:10px">
        <button class="btn primary cta pulse" id="btnOdds" aria-label="Calcular EV y Kelly">Calcular EV / Kelly</button>
        <span class="hint">El cálculo es <b>automático</b> al escribir cuotas o cambiar bankroll/OU. El botón es opcional.</span>
      </div>
      <div class="sep"></div>
      <div class="hint tiny">
        <b>Leyenda Overround:</b>
        <span class="badge accept">Aceptable ≤ 3%</span>
        <span class="badge medium">Medio 3%–6%</span>
        <span class="badge bad">No aceptable &gt; 6%</span>
        <br><b>Reglas para guardar:</b> Muestras H/A = 10/10 · <u>EV≥3%</u> · Cuota&gt;1 · Overround&lt;6% · Prob modelo ≥55%.
      </div>
    </section>

    <section class="card" aria-labelledby="resultados">
      <h2 id="resultados">4) Resultados del modelo</h2>
      <div id="modelBox" class="kpi">
        <span class="pill">λ Home: <b id="lamH">—</b></span>
        <span class="pill">λ Away: <b id="lamA">—</b></span>
        <span class="pill">OU &gt; <b id="ouLbl">2.5</b>: <b id="pOver">—</b></span>
        <span class="pill">OU &lt;= <b id="ouLbl2">2.5</b>: <b id="pUnder">—</b></span>
        <span class="pill">BTTS Sí: <b id="pBTTSY">—</b></span>
        <span class="pill">BTTS No: <b id="pBTTSN">—</b></span>
        <span class="pill">P(1): <b id="p1">—</b></span>
        <span class="pill">P(X): <b id="pX">—</b></span>
        <span class="pill">P(2): <b id="p2">—</b></span>
      </div>
      <div class="sep"></div>
      <div class="kpi">
        <span class="pill">CV total: <b id="cvTxt">—</b></span>
        <span class="pill">Muestras (H/A): <b id="nHA">—</b></span>
      </div>
      <div class="hint tiny" style="margin-top:6px">
        λH = blend(proxy tipo xG + goles) con ventaja local suave · λA idem visitante. Fallback seguro al método clásico si falta info.
      </div>

      <div class="sep"></div>
      <h3 class="tiny" style="margin:6px 0 4px">Rachas (últimos 10 por lado)</h3>
      <div class="grid grid-cols-2" id="streaksBox">
        <div>
          <span class="pill">Local — BTTS: <b id="stHBTTS">—</b></span>
          <span class="pill">Local — Over <b id="stHOULbl">2.5</b>: <b id="stHOU">—</b></span>
          <div class="hint tiny" id="seqH">—</div>
        </div>
        <div>
          <span class="pill">Visitante — BTTS: <b id="stABTTS">—</b></span>
          <span class="pill">Visitante — Over <b id="stAOULbl">2.5</b>: <b id="stAOU">—</b></span>
          <div class="hint tiny" id="seqA">—</div>
        </div>
      </div>
    </section>

    <section class="card" aria-labelledby="evkelly">
      <h2 id="evkelly">5) Valor esperado, Kelly 1/4 y Guardado</h2>
      <table>
        <thead>
          <tr>
            <th>Mercado</th><th>Detalle</th>
            <th class="right">Prob. Modelo</th><th class="right">Cuota</th>
            <th class="right">Overround</th><th class="right">EV</th>
            <th class="right">Stake Kelly 1/4</th><th class="right">Acción</th>
          </tr>
        </thead>
        <tbody id="evTable"></tbody>
      </table>
      <div class="hint tiny" style="margin-top:6px">
        EV = p·odd − 1. Kelly fraccional 1/4 = max(0, ((p·odd − 1)/(odd − 1)) / 4).
        <b>Límites cuando EV&gt;0:</b> mínimo 1% y máximo 3% del bankroll.
        Overround = Σ(1/odd) − 1.
      </div>
    </section>
  </div>

<script>
(() => {
  "use strict";

  const OVERROUND_THRESHOLDS = { warn: 0.03, bad: 0.06 };
  const STAKE_MIN = 0.01;
  const STAKE_MAX = 0.03;
  const PROB_THRESHOLD = 0.55;

  let DATA = [];
  let CURRENT = { league:null, home:null, away:null, lambdas:null, probs:null, samples:{nH:0,nA:0} };

  const $ = sel => document.querySelector(sel);
  const setText = (id, txt) => { const el = typeof id==="string" ? document.getElementById(id) : id; if(el) el.textContent = txt; };

  const factorialCache = [1];
  const fact = (n) => { for(let i=factorialCache.length;i<=n;i++) factorialCache[i] = factorialCache[i-1]*i; return factorialCache[n]; };
  const pois = (lambda,k)=> Math.exp(-lambda)*Math.pow(lambda,k)/fact(k);

  const parseFT = (ft) => {
    if(!ft || typeof ft!=="string") return {h:0,a:0,ok:false};
    const m = ft.match(/(-?\d+)\s*[-:]\s*(-?\d+)/);
    if(!m) return {h:0,a:0,ok:false};
    return {h: Number(m[1]), a: Number(m[2]), ok:true};
  };
  const splitTeams = (matchStr) => {
    if(!matchStr) return {home:null, away:null};
    const parts = String(matchStr).split(" - ");
    return {home: (parts[0]||"").trim(), away: (parts[1]||"").trim()};
  };
  const mean = arr => arr.length ? arr.reduce((s,x)=>s+x,0)/arr.length : 0;

  function pTotalLE(lambdaH, lambdaA, kMax, thr){
    let p = 0;
    const pH = Array.from({length:kMax+1}, (_,h)=>pois(lambdaH,h));
    const pA = Array.from({length:kMax+1}, (_,a)=>pois(lambdaA,a));
    for(let h=0; h<=kMax; h++){
      for(let a=0; a<=kMax-h; a++){
        if(h+a<=thr) p += pH[h]*pA[a];
      }
    }
    return Math.min(Math.max(p,0),1);
  }

  function cdf1X2(lambdaH, lambdaA, kMax){
    let p1=0, px=0, p2=0;
    const pH = Array.from({length:kMax+1}, (_,h)=>pois(lambdaH,h));
    const pA = Array.from({length:kMax+1}, (_,a)=>pois(lambdaA,a));
    for(let h=0; h<=kMax; h++){
      for(let a=0; a<=kMax; a++){
        const p = pH[h]*pA[a];
        if(h>a) p1+=p; else if(h===a) px+=p; else p2+=p;
      }
    }
    return {p1,px,p2};
  }

  function btss(lambdaH, lambdaA){
    const pH0 = Math.exp(-lambdaH);
    const pA0 = Math.exp(-lambdaA);
    const pYY = 1 - pH0 - pA0 + pH0*pA0;
    return {yes:pYY, no:1-pYY};
  }

  function overroundFromOdds(arrOdds){
    const valid = arrOdds.filter(o=>o && o>1.001);
    const sumInv = valid.reduce((s,o)=>s+1/o,0);
    if(!valid.length) return NaN;
    return Math.max(0, sumInv - 1);
  }

  function ev(p, odd){ if(!odd || odd<=1) return NaN; return p*odd - 1; }
  function kellyQuarter(p, odd){
    if(!odd || odd<=1) return 0;
    const f = (p*odd - 1) / (odd - 1);
    return Math.max(0, f / 4);
  }
  function coefVariacion(lambdaH, lambdaA){
    const lambdaTot = Math.max(lambdaH + lambdaA, 1e-9);
    return 1 / Math.sqrt(lambdaTot);
  }

  function stakeSuggestedFrac(p, odd, evv){
    if(!isFinite(evv) || evv<=0 || !isFinite(p) || !isFinite(odd) || odd<=1) return 0;
    const base = kellyQuarter(p, odd);
    return Math.min(STAKE_MAX, Math.max(STAKE_MIN, base));
  }
  function stakeTag(base, bounded){
    if(bounded===0) return "";
    if(base>bounded && Math.abs(bounded-STAKE_MAX)<1e-12) return '<span class="tag" title="Tope 3%">cap 3%</span>';
    if(base<bounded && Math.abs(bounded-STAKE_MIN)<1e-12) return '<span class="tag" title="Mínimo 1%">min 1%</span>';
    return "";
  }

  function normalize(obj){
    const {League, Match, "Result FT":RFT, Date, "Home Team":HTX, "Away Team":ATX} = obj;
    const mTeams = splitTeams(Match || "");
    const ft = parseFT(RFT);
    return {
      League: League || obj.LeagueName || obj.Div || "—",
      Match: Match || (HTX && ATX ? `${HTX} - ${ATX}` : ""),
      Home: mTeams.home, Away: mTeams.away,
      FTHG: ft.h, FTAG: ft.a,
      Date: Date || obj.Date || "",
      raw: obj
    };
  }

  async function parseInput(){
    const status = $("#ingestStatus");
    status.textContent = "Procesando...";
    let rows = [];
    const file = $("#file").files[0];

    if(file){
      try{
        const content = await file.text();
        rows = rows.concat(readFlexJSON(content));
      }catch(e){
        status.innerHTML = '<span class="danger">Error leyendo archivo.</span>';
        return;
      }
    } else {
      status.innerHTML = '<span class="danger">Selecciona un archivo para procesar.</span>';
      return;
    }

    if(!rows.length){
      status.innerHTML = '<span class="danger">No se detectó JSON válido.</span>';
      return;
    }

    DATA = rows.map(normalize).filter(r=>r.Match && (r.Home||"") && (r.Away||""));

    if(!DATA.length){
      status.innerHTML = '<span class="danger">No se pudieron normalizar partidos.</span>';
      return;
    }

    const leagues = [...new Set(DATA.map(r=>r.League))].sort((a,b)=>a.localeCompare(b));
    fillSelect($("#selLeague"), leagues, "— Selecciona liga —");
    fillSelect($("#selHome"), [], "— Local —");
    fillSelect($("#selAway"), [], "— Visitante —");

    status.innerHTML = `<span class="success">OK:</span> ${DATA.length} partidos cargados · ${leagues.length} ligas.`;

    if(leagues.length===1){
      $("#selLeague").value = leagues[0];
      CURRENT.league = leagues[0];
      const teams = getLeagueTeams(leagues[0]);
      fillSelect($("#selHome"), teams, "— Local —");
      fillSelect($("#selAway"), teams, "— Visitante —");
      if(teams.length>=2){
        $("#selHome").value = teams[0];
        $("#selAway").value = teams[1];
        CURRENT.home = teams[0];
        CURRENT.away = teams[1];
        autoCalcPoisson(true);
      }
    }
    $("#evTable").innerHTML = "";
  }

  function readFlexJSON(text){
    text = text.trim();
    if(!text) return [];
    try{
      const parsed = JSON.parse(text);
      return Array.isArray(parsed) ? parsed : [parsed];
    }catch(e){
      const lines = text.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      const arr = [];
      for(const line of lines){
        try{ arr.push(JSON.parse(line)); }catch(_){}
      }
      return arr;
    }
  }

  function fillSelect(sel, items, placeholder){
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = ""; opt0.textContent = placeholder || "—";
    sel.appendChild(opt0);
    for(const it of items){
      const o = document.createElement("option");
      o.value = it; o.textContent = it;
      sel.appendChild(o);
    }
  }

  function getLeagueTeams(league){
    const set = new Set();
    for(const r of DATA) if(r.League===league){ set.add(r.Home); set.add(r.Away); }
    set.delete(null); set.delete("");
    return [...set].sort((a,b)=>a.localeCompare(b));
  }

  function lastMatchesTeam(league, team, side, limit=10){
    const arr = [];
    for(const r of DATA){
      if(r.League!==league) continue;
      if(side==="home" && r.Home===team) arr.push(r);
      if(side==="away" && r.Away===team) arr.push(r);
    }
    arr.sort((a,b)=> new Date(a.Date||0) - new Date(b.Date||0));
    return arr.slice(-limit);
  }

  function goalsStats(league, team){
    const lastH = lastMatchesTeam(league, team, "home", 10);
    const lastA = lastMatchesTeam(league, team, "away", 10);

    const gfH = lastH.map(m=>m.FTHG);
    const gcH = lastH.map(m=>m.FTAG);
    const gfA = lastA.map(m=>m.FTAG);
    const gcA = lastA.map(m=>m.FTHG);

    return {
      nH: lastH.length, nA: lastA.length,
      avgGF_H: mean(gfH), avgGC_H: mean(gcH),
      avgGF_A: mean(gfA), avgGC_A: mean(gcA)
    };
  }

  /* ==================== PROXY tipo xG con tus campos FT ==================== */
  function toNum(v, def=0){ const n = Number(v); return (isFinite(n)? n : def); }
  function getRaw(r, key, def=0){ return toNum(r && Object.prototype.hasOwnProperty.call(r,key) ? r[key] : undefined, def); }

  const P_WEIGHTS = {
    wSOT: 0.11,        // a puerta
    wNSOT: 0.03,       // tiro fuera
    wDA: 0.04/10,      // 10 dangerous ≈ 0.40
    wATK: 0.015/10,    // 10 attacks ≈ 0.15
    wCOR: 0.04/5,      // 5 corners ≈ 0.20
    wPOS: 0.02/10,     // 10% posesión ≈ 0.20
    wRC: -0.10         // roja penaliza
  };

  function proxyFromRaw(r, side){
    const prefix = side === "home" ? "Home" : "Away";
    const SOT = getRaw(r, `${prefix} OnGoal Shots at FT`);
    const SH  = getRaw(r, `${prefix} Total Shots at FT`);
    const DA  = getRaw(r, `${prefix} Dangerous Attacks at FT`);
    const ATK = getRaw(r, `${prefix} Attacks at FT`);
    const POS = getRaw(r, `${prefix} Ball Possession at FT`);
    const COR = getRaw(r, `${prefix} Corners at FT`);
    const RC  = getRaw(r, `${prefix} RedCards at FT`);
    const NSOT = Math.max(0, SH - SOT);
    const prox =
      P_WEIGHTS.wSOT  * SOT +
      P_WEIGHTS.wNSOT * NSOT +
      P_WEIGHTS.wDA   * DA +
      P_WEIGHTS.wATK  * ATK +
      P_WEIGHTS.wCOR  * COR +
      P_WEIGHTS.wPOS  * POS +
      P_WEIGHTS.wRC   * RC;
    return prox;
  }

  function teamProxyAvg(matches, side){
    let sum=0, n=0;
    for(const m of matches){
      const prox = proxyFromRaw(m.raw || {}, side);
      if(isFinite(prox)){ sum += prox; n++; }
    }
    return n ? (sum/n) : null;
  }

  function leagueProxyScale(leagueMatches){
    let goalsSum=0, proxSum=0, n=0;
    for(const m of leagueMatches){
      const r = m.raw || {};
      const proxH = proxyFromRaw(r, "home");
      const proxA = proxyFromRaw(r, "away");
      const proxTot = (isFinite(proxH)?proxH:0) + (isFinite(proxA)?proxA:0);
      const goalsTot = toNum(m.FTHG) + toNum(m.FTAG);
      if(isFinite(proxTot) && proxTot>0){
        proxSum += proxTot; goalsSum += goalsTot; n++;
      }
    }
    const avgGoals = n ? goalsSum/n : 2.6;
    const avgProxy = n ? proxSum/n : 2.6;
    const s = (avgProxy>0) ? (avgGoals/avgProxy) : 1;
    return { s };
  }

  const L_WEIGHTS = { w1:0.45, w2:0.25, w3:0.20, w4:0.10 };

  function computeLambdas(league, home, away){
    const H = goalsStats(league, home);
    const A = goalsStats(league, away);

    const lastH = lastMatchesTeam(league, home, "home", 10);
    const lastA = lastMatchesTeam(league, away, "away", 10);
    const leagueMatches = DATA.filter(r => r.League === league);

    const { s } = leagueProxyScale(leagueMatches);

    const proxH_home = teamProxyAvg(lastH, "home");
    const proxA_away = teamProxyAvg(lastA, "away");

    const xGF_H = isFinite(proxH_home) ? s*proxH_home : null;
    const xGF_A = isFinite(proxA_away) ? s*proxA_away : null;

    // aproximación simétrica para "concedidos" si no hay métrica separada
    const xGA_H = xGF_H;
    const xGA_A = xGF_A;

    const GF_H = H.avgGF_H, GA_A = A.avgGC_A;
    const GF_A = A.avgGF_A, GA_H = H.avgGC_H;

    const { w1,w2,w3,w4 } = L_WEIGHTS;

    const lamH_proxy = weighted([xGF_H,w1],[xGA_A,w2],[GF_H,w3],[GA_A,w4]);
    const lamA_proxy = weighted([xGF_A,w1],[xGA_H,w2],[GF_A,w3],[GA_H,w4]);

    let lamH = isFinite(lamH_proxy) ? lamH_proxy : (0.6*(GF_H||0) + 0.4*(GA_A||0));
    let lamA = isFinite(lamA_proxy) ? lamA_proxy : (0.6*(GF_A||0) + 0.4*(GA_H||0));

    lamH *= 1.05; // ligera ventaja local
    lamH = Math.max(0.2, Math.min(3.5, lamH));
    lamA = Math.max(0.2, Math.min(3.5, lamA));

    CURRENT.samples = {nH:H.nH, nA:A.nA};
    return { lamH, lamA };

    function weighted(...pairs){
      let num=0, den=0;
      for(const [val,w] of pairs){ if(isFinite(val)){ num += w*val; den += w; } }
      return den>0 ? num/den : NaN;
    }
  }
  /* ================== FIN PROXY tipo xG ================== */

  function computeAllProbs(lambdaH, lambdaA, ouLine, kMax){
    const thr = Math.floor(ouLine);
    const pLE = pTotalLE(lambdaH, lambdaA, kMax, thr);
    const isHalf = Math.abs(ouLine - thr) > 1e-9;
    let pOver, pUnder;
    if(isHalf){ pOver = 1 - pLE; pUnder = pLE; }
    else { pOver = 1 - pLE; pUnder = pLE; }
    const b = btss(lambdaH, lambdaA);
    const ones = cdf1X2(lambdaH, lambdaA, kMax);
    return { ou:{over:pOver, under:pUnder}, btts:{yes:b.yes, no:b.no}, oneXtwo: ones };
  }

  function fmtPct(x){ return isFinite(x) ? (100*x).toFixed(1)+"%" : "—"; }
  function fmtDec(x){ return isFinite(x) ? x.toFixed(3) : "—"; }
  function fmtMoney(x){ return isFinite(x) ? x.toFixed(2) : "—"; }

  function orClass(or){
    if(!isFinite(or)) return {cls:"", label:"—"};
    if(or > OVERROUND_THRESHOLDS.bad) return {cls:"badge bad", label:"No aceptable"};
    if(or > OVERROUND_THRESHOLDS.warn) return {cls:"badge medium", label:"Medio"};
    return {cls:"badge accept", label:"Aceptable"};
  }

  function setProbWithFlag(id, p){
    const el = document.getElementById(id);
    if(!el) return;
    el.textContent = fmtPct(p);
    if(p>=PROB_THRESHOLD && isFinite(p)) el.setAttribute('data-flag','1'); else el.setAttribute('data-flag','0');
  }

  function renderModel(){
    const { lambdas, probs, samples } = CURRENT;
    if(!lambdas || !probs){ return; }
    const line = Number($("#ouLine").value || 2.5);
    setText("lamH", fmtDec(lambdas.lamH));
    setText("lamA", fmtDec(lambdas.lamA));
    setText("ouLbl", line);
    setText("ouLbl2", line);

    setProbWithFlag('pOver',  probs.ou.over);
    setProbWithFlag('pUnder', probs.ou.under);
    setProbWithFlag('pBTTSY', probs.btts.yes);
    setProbWithFlag('pBTTSN', probs.btts.no);
    setProbWithFlag('p1',     probs.oneXtwo.p1);
    setProbWithFlag('pX',     probs.oneXtwo.px);
    setProbWithFlag('p2',     probs.oneXtwo.p2);

    const CV = coefVariacion(lambdas.lamH, lambdas.lamA);
    setText("cvTxt", `${CV.toFixed(2)} (${CV<0.5?'Bajo':(CV<=0.8?'Medio':'Alto')})`);
    setText("nHA", `${samples.nH}/${samples.nA}`);

    renderStreaks();
  }

  function calcOdds(){
    if(!CURRENT.probs){ return; }
    const bk = Number($("#bankroll").value);
    if(!isFinite(bk) || bk < 0){ return; }
    const line = Number($("#ouLine").value || 2.5);

    const odds = {
      over: Number($("#oddOver").value || 0),
      under: Number($("#oddUnder").value || 0),
      bttsy: Number($("#oddBTTSY").value || 0),
      bttsn: Number($("#oddBTTSN").value || 0)
    };

    const rows = [];

    const orOU = overroundFromOdds([odds.over, odds.under]);
    rows.push(buildRow("Over/Under", `Over ${line}`, CURRENT.probs.ou.over, odds.over, orOU, bk, {market:"OU_OVER", meta:{line}}));
    rows.push(buildRow("Over/Under", `Under ${line}`, CURRENT.probs.ou.under, odds.under, orOU, bk, {market:"OU_UNDER", meta:{line}}));

    const orBT = overroundFromOdds([odds.bttsy, odds.bttsn]);
    rows.push(buildRow("BTTS", "BTTS Sí", CURRENT.probs.btts.yes, odds.bttsy, orBT, bk, {market:"BTTS_YES"}));
    rows.push(buildRow("BTTS", "BTTS No", CURRENT.probs.btts.no, odds.bttsn, orBT, bk, {market:"BTTS_NO"}));

    const tbody = $("#evTable");
    tbody.innerHTML = "";
    for(const tr of rows) tbody.appendChild(tr);
  }

  function buildRow(grupo, label, p, odd, overround, bankroll, meta){
    const tr = document.createElement("tr");

    const tdG = document.createElement("td"); tdG.textContent = grupo; tr.appendChild(tdG);
    const tdL = document.createElement("td"); tdL.textContent = label; tr.appendChild(tdL);

    const tdP = document.createElement("td"); tdP.className="right";
    tdP.innerHTML = isFinite(p) ? `${fmtPct(p)}${p>=PROB_THRESHOLD? ' <span class="badge accept tiny">≥55%</span>' : ''}` : "—";
    tr.appendChild(tdP);

    const tdO = document.createElement("td"); tdO.className="right"; tdO.textContent = odd>1? odd.toFixed(2) : "—"; tr.appendChild(tdO);

    const tdR = document.createElement("td"); tdR.className="right";
    const occ = orClass(overround);
    tdR.innerHTML = isFinite(overround)
      ? `<span class="${occ.cls}" title="${occ.label} — ${(100*overround).toFixed(2)}%">${(100*overround).toFixed(2)}%</span>`
      : "—";
    tr.appendChild(tdR);

    const evv = ev(p, odd);
    const tdEV = document.createElement("td"); tdEV.className="right";
    tdEV.innerHTML = isFinite(evv) ? `<b class="${evv>=0?'success':'danger'}">${(100*evv).toFixed(2)}%</b>` : "—";
    tr.appendChild(tdEV);

    const baseKQ = kellyQuarter(p, odd);
    const boundedFrac = stakeSuggestedFrac(p, odd, evv);
    const stakeAmt = isFinite(boundedFrac) ? bankroll * boundedFrac : 0;
    const tdK = document.createElement("td"); tdK.className="right";
    if(isFinite(evv) && evv>0 && odd>1){
      tdK.innerHTML = `${(100*boundedFrac).toFixed(2)}% · $${fmtMoney(stakeAmt)} ${stakeTag(baseKQ, boundedFrac)}`;
    } else {
      tdK.textContent = "—";
    }
    tr.appendChild(tdK);

    const samples = CURRENT.samples || {nH:0, nA:0};
    const meetsSample   = (samples.nH === 10 && samples.nA === 10);
    const meetsEV       = (isFinite(evv) && evv >= 0.03);
    const meetsOdd      = (isFinite(odd) && odd > 1);
    const meetsOver     = (isFinite(overround) && overround < 0.06);
    const meetsProb     = (isFinite(p) && p >= PROB_THRESHOLD);
    const canSave = (meetsSample && meetsEV && meetsOdd && meetsOver && meetsProb);

    const tdBtn = document.createElement("td"); tdBtn.className="right";

    const btnSave = document.createElement("button");
    btnSave.className = "btn " + (canSave ? "primary" : "ghost");
    btnSave.textContent = "Guardar Pick";
    btnSave.disabled = !canSave;
    btnSave.title = canSave ? "Guardar en historial" : reasonForDisabled();
    btnSave.onclick = () => trySave(canSave, buildPickPayload(p, odd, overround, evv, baseKQ, boundedFrac, stakeAmt, meta), false);

    const btnSavePre = document.createElement("button");
    btnSavePre.className = "btn " + (canSave ? "primary" : "ghost");
    btnSavePre.style.marginLeft = "6px";
    btnSavePre.textContent = "Guardar Pre";
    btnSavePre.disabled = !canSave;
    btnSavePre.title = canSave ? "Guardar en historial prepartido" : reasonForDisabled();
    btnSavePre.onclick = () => trySave(canSave, buildPickPayload(p, odd, overround, evv, baseKQ, boundedFrac, stakeAmt, meta), true);

    tdBtn.appendChild(btnSave);
    tdBtn.appendChild(btnSavePre);
    tr.appendChild(tdBtn);

    function reasonForDisabled(){
      if(!meetsSample) return "Requisito de muestra: H/A debe ser 10/10";
      if(!meetsOdd) return "Cuota inválida (>1 requerida)";
      if(!meetsEV) return "EV debe ser ≥ 3%";
      if(!meetsOver) return "Overround debe ser < 6%";
      if(!meetsProb) return "Probabilidad del modelo debe ser ≥ 55%";
      return "No disponible";
    }

    return tr;
  }

  function buildPickPayload(p, odd, overround, evv, baseKQ, boundedFrac, stakeAmt, meta){
    return {
      league: CURRENT.league,
      home: CURRENT.home,
      away: CURRENT.away,
      lambdaH: CURRENT.lambdas?.lamH ?? null,
      lambdaA: CURRENT.lambdas?.lamA ?? null,
      line: (meta.meta && meta.meta.line) ? meta.meta.line : null,
      market: meta.market,
      prob: p,
      odd,
      overround,
      ev: evv,
      kelly_frac: baseKQ,
      bankroll: Number($("#bankroll").value || 0),
      stake_suggested_frac: boundedFrac,
      stake_suggested_abs: stakeAmt,
      timestamp: new Date().toISOString()
    };
  }

  function trySave(canSave, payload, isPre){
    if(!canSave){
      alert("⚠️ No se puede guardar con las reglas actuales.");
      return;
    }
    savePick(payload, isPre);
  }

  function savePick(pick, isPre=false){
    try{
      const key = isPre ? "picks_pre" : "picks";
      const arr = JSON.parse(localStorage.getItem(key)||"[]");
      arr.push(pick);
      localStorage.setItem(key, JSON.stringify(arr));
      alert(isPre ? "✅ Pick guardado en historial PREPARTIDO." : "✅ Pick guardado en historial.");
    }catch(e){
      alert("No se pudo guardar el pick: " + e.message);
    }
  }

  function outcomesFromMatches(matches, ouLine){
    const btts = [];
    const ou = [];
    for(const m of matches){
      const h = m.FTHG ?? 0;
      const a = m.FTAG ?? 0;
      const total = (Number(h)||0) + (Number(a)||0);
      btts.push((h>0) && (a>0));
      ou.push(total > ouLine);
    }
    return { btts, ou };
  }

  function streakCount(arr, targetTrue){
    let c = 0;
    for(let i=arr.length-1; i>=0; i--){
      if(Boolean(arr[i]) === Boolean(targetTrue)) c++; else break;
    }
    return c;
  }

  function seqString(arr, trueChar, falseChar){
    if(!arr.length) return "—";
    return arr.map(v => v ? trueChar : falseChar).join(" ");
  }

  function renderStreaks(){
    const league = $("#selLeague").value;
    const home = $("#selHome").value;
    const away = $("#selAway").value;
    const line = Number($("#ouLine").value || 2.5);

    setText("stHOULbl", line);
    setText("stAOULbl", line);

    if(!league || !home || !away || home===away){
      setText("stHBTTS","—"); setText("stHOU","—"); setText("seqH","—");
      setText("stABTTS","—"); setText("stAOU","—"); setText("seqA","—");
      return;
    }

    const lastH = lastMatchesTeam(league, home, "home", 10);
    const lastA = lastMatchesTeam(league, away, "away", 10);

    const H = outcomesFromMatches(lastH, line);
    const A = outcomesFromMatches(lastA, line);

    const hBTTSst = streakCount(H.btts, true);
    const hOUst   = streakCount(H.ou, true);
    const aBTTSst = streakCount(A.btts, true);
    const aOUst   = streakCount(A.ou, true);

    setText("stHBTTS", lastH.length ? `${hBTTSst} Sí` : "—");
    setText("stHOU",   lastH.length ? `${hOUst} Over` : "—");
    setText("stABTTS", lastA.length ? `${aBTTSst} Sí` : "—");
    setText("stAOU",   lastA.length ? `${aOUst} Over` : "—");

    const seqHtxt = lastH.length ? `BTTS: ${seqString(H.btts,'Y','N')} · Over ${line}: ${seqString(H.ou,'O','U')}` : "—";
    const seqAtxt = lastA.length ? `BTTS: ${seqString(A.btts,'Y','N')} · Over ${line}: ${seqString(A.ou,'O','U')}` : "—";

    setText("seqH", seqHtxt);
    setText("seqA", seqAtxt);
  }

  $("#file").addEventListener("change", parseInput);
  $("#selLeague").addEventListener("change", (e)=>{
    const lg = e.target.value;
    CURRENT.league = lg || null;
    if(!lg){
      fillSelect($("#selHome"), [], "— Local —");
      fillSelect($("#selAway"), [], "— Visitante —");
      $("#evTable").innerHTML = "";
      renderStreaks();
      return;
    }
    const teams = getLeagueTeams(lg);
    fillSelect($("#selHome"), teams, "— Local —");
    fillSelect($("#selAway"), teams, "— Visitante —");
    if(teams.length>=2){
      $("#selHome").value = teams[0];
      $("#selAway").value = teams[1];
      CURRENT.home = teams[0];
      CURRENT.away = teams[1];
      autoCalcPoisson(true);
    }
    $("#evTable").innerHTML = "";
  });

  $("#selHome").addEventListener("change", (e)=>{ CURRENT.home = e.target.value || null; autoCalcPoisson(true); $("#evTable").innerHTML = ""; });
  $("#selAway").addEventListener("change", (e)=>{ CURRENT.away = e.target.value || null; autoCalcPoisson(true); $("#evTable").innerHTML = ""; });

  $("#ouLine").addEventListener("input", ()=>{ autoCalcPoisson(true); });
  $("#maxGoals").addEventListener("input", ()=>{ autoCalcPoisson(true); });

  const autoFields = ["#oddOver","#oddUnder","#oddBTTSY","#oddBTTSN","#bankroll"];
  for(const sel of autoFields){
    const el = $(sel);
    ["input","change"].forEach(evt => el.addEventListener(evt, calcOdds));
  }

  document.getElementById("btnOdds").addEventListener("click", calcOdds);

  function autoCalcPoisson(alsoRefreshEV=false){
    const league = $("#selLeague").value;
    const home = $("#selHome").value;
    const away = $("#selAway").value;
    if(!league || !home || !away || home===away) { renderStreaks(); return; }
    const { lamH, lamA } = computeLambdas(league, home, away);
    const line = Number($("#ouLine").value || 2.5);
    const kMax = Math.max(6, Number($("#maxGoals").value || 10));
    const probs = computeAllProbs(lamH, lamA, line, kMax);
    CURRENT.lambdas = {lamH, lamA};
    CURRENT.probs = probs;
    renderModel();
    if(alsoRefreshEV) calcOdds();
  }

  function fillSelect(sel, items, placeholder){
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = ""; opt0.textContent = placeholder || "—";
    sel.appendChild(opt0);
    for(const it of items){
      const o = document.createElement("option");
      o.value = it; o.textContent = it;
      sel.appendChild(o);
    }
  }
})();
</script>
</body>
</html>