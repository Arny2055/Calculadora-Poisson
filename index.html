<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Backtesting F√∫tbol ‚Äî JSON robusto</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{--bg:#0f1115;--panel:#171a21;--panel2:#1f2430;--text:#e6eaf2;--muted:#9aa3b2;--accent:#7aa2ff;--border:#2a3140;}
  *{box-sizing:border-box;font-family:'Inter',sans-serif}
  body{margin:0;background:var(--bg);color:var(--text)}
  header{padding:1rem;background:var(--panel);border-bottom:1px solid var(--border)}
  main{display:grid;grid-template-columns:1fr 3fr;gap:1rem;padding:1rem}
  section{background:var(--panel2);padding:1rem;border-radius:8px;overflow:auto}
  label{display:block;margin-top:.4rem;color:var(--muted)}
  select,input,button{width:100%;padding:.5rem;margin-top:.35rem;background:var(--panel);color:var(--text);border:1px solid var(--border);border-radius:6px}
  button{cursor:pointer;background:var(--accent)}
  table{width:100%;border-collapse:collapse;font-size:.85rem;margin-top:.5rem}
  th,td{border:1px solid var(--border);padding:.4rem;text-align:center}
  th{background:var(--panel)}
  .dropzone{border:2px dashed var(--accent);border-radius:8px;padding:1rem;text-align:center;color:var(--muted);margin-top:.5rem}
  .dropzone.dragover{background:rgba(122,162,255,.1)}
  .status{background:#11151d;border:1px solid var(--border);border-radius:8px;padding:.6rem;margin-top:.6rem;font-size:.9rem}
  .ok{color:#7ee787}.warn{color:#ffb86b}.err{color:#ff6b6b}
  canvas{width:100%!important;height:260px!important;margin-top:1rem}
</style>
</head>
<body>
<header><h1>‚öΩ Backtesting F√∫tbol ‚Äî JSON robusto</h1></header>

<main>
  <section>
    <h2>‚öôÔ∏è Configuraci√≥n</h2>
    <input type="file" id="fileInput" accept=".json"/>
    <div id="dropzone" class="dropzone">Arrastra tu JSON aqu√≠</div>

    <label>Liga</label><select id="leagueSelect" onchange="applyFilters()"></select>
    <label>Equipo Local</label><select id="homeSelect" onchange="applyFilters()"></select>
    <label>Equipo Visitante</label><select id="awaySelect" onchange="applyFilters()"></select>

    <label>Stop Drawdown (%)</label><input type="number" id="ddStop" value="30" min="0" max="95"/>
    <label>Stake</label>
    <select id="stakeMode" onchange="applyFilters()">
      <option value="flat">Flat (1 unidad)</option>
      <option value="kelly">Kelly fraccional (cap 25%)</option>
    </select>
    <label>M√≠n. apuestas (entrenamiento) para validar Œ±</label><input type="number" id="minBets" value="20" min="0"/>

    <button onclick="exportCSV()">Exportar CSV (picks test)</button>
    <div id="status" class="status">Carga un JSON para comenzar.</div>
  </section>

  <section>
    <h2>üìä Resultados</h2>
    <div id="metrics"></div>
    <canvas id="equityChart"></canvas>
    <canvas id="confusionChart"></canvas>
    <h3>Top Reglas/Patrones</h3><table id="rulesTable"></table>
    <h3>Segmentaci√≥n por Liga</h3><table id="leagueTable"></table>
    <h3>Segmentaci√≥n por Equipo (Local)</h3><table id="teamTable"></table>
    <h3>Segmentaci√≥n por Rangos de Cuotas</h3><table id="oddsTable"></table>
    <canvas id="equityOddsChart"></canvas>
    <h3>Partidos Evaluados (TEST)</h3><table id="matchesTable"></table>
  </section>
</main>

<script>
let rawData=[], filtered=[], charts={}, lastTestPicks=[];
const mesesES={ene:"Jan",feb:"Feb",mar:"Mar",abr:"Apr",may:"May",jun:"Jun",jul:"Jul",ago:"Aug",sept:"Sep",sep:"Sep",oct:"Oct",nov:"Nov",dic:"Dec"};

function setStatus(html,cls=""){const s=document.getElementById("status");s.innerHTML=html; s.className=`status ${cls}`;}

function normalizeString(s){ if(typeof s!=="string") return s; return s.trim().replace("FÔøΩtbol","F√∫tbol").replace("Ftbol","F√∫tbol"); }
function toNumber(x){ if(typeof x==="number") return x; if(x==null) return NaN; const t=String(x).replace(/,/g,".").replace(/[^\d.\-]/g,""); return parseFloat(t); }
function parseScore(s){ const m=String(s||"").match(/(\d+)\s*[-:]\s*(\d+)/); return m?{hg:+m[1],ag:+m[2]}:null; }

function parseDateES(s){
  if(!s) return null;
  s=String(s).trim();
  let d=new Date(s); if(!isNaN(d)) return d;
  const m=s.match(/(\d{1,2})\s+([a-zA-Z√±√ë.]+)\.?,?\s+(\d{4})\s+(\d{1,2}:\d{2})/);
  if(m){ let day=m[1], mes=m[2].toLowerCase().replace(".",""); mes=mesesES[mes]||mes; const str=`${day} ${mes} ${m[3]} ${m[4]}`; d=new Date(str); if(!isNaN(d)) return d; }
  return new Date(s);
}

function safeSplitTeams(matchStr){ matchStr=normalizeString(matchStr||""); const p=matchStr.split(" - "); if(p.length===2) return p; const i=matchStr.indexOf("-"); if(i>0) return [matchStr.slice(0,i).trim(),matchStr.slice(i+1).trim()]; return [matchStr,""]; }

function parseJsonLoose(txt){
  try{
    const j=JSON.parse(txt);
    if(Array.isArray(j)) return j;
    if(j && typeof j==="object"){
      if(Array.isArray(j.data)) return j.data;
      if(Array.isArray(j.records)) return j.records;
      if(Array.isArray(j.items)) return j.items;
      return [j]; // un solo objeto
    }
  }catch(e){ /* intento NDJSON (l√≠nea por l√≠nea) */ }
  // NDJSON simple
  const lines=txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if(lines.length>1){
    try{ return lines.map(JSON.parse); }catch(e){}
  }
  return [];
}

function baseClean(ds){
  return ds.map(r=>{
    const o={...r};
    o.League=normalizeString(o.League);
    o.Match =normalizeString(o.Match);
    o["Desired Outcome"]=normalizeString(o["Desired Outcome"]||o.DesiredOutcome||"");
    o.DateObj=parseDateES(o.Date||o["Fecha"]||o["date"]);
    // odds/num√©ricos
    o.Odd = toNumber(o.Odd ?? o["Odd"] ?? o["Odd GG"] ?? o["Cuota"] ?? o["odd"]);
    [
      "Home Attacks at FT","Away Attacks at FT","Home Dangerous Attacks at FT","Away Dangerous Attacks at FT",
      "Home OnGoal Shots at FT","Away OnGoal Shots at FT","Home Total Shots at FT","Away Total Shots at FT",
      "Home Ball Possession at FT","Away Ball Possession at FT","Home Corners at FT","Away Corners at FT",
      "Home RedCards at FT","Away RedCards at FT","Home YellowCards at FT","Away YellowCards at FT",
      "Home Position","Away Position","Odd 1 PreMatch","Odd X PreMatch","Odd 2 PreMatch"
    ].forEach(k=>{ if(o[k]!=null) o[k]=toNumber(o[k]); });

    // target (BTTS/GG si aplica; si no, usa Result)
    let target=null;
    const outcome=(o["Desired Outcome"]||"").toUpperCase();
    const score=parseScore(o["Result FT"]||o["FT Result"]||o["Marcador"]||"");
    if((outcome==="GG"||outcome==="BTTS") && score){
      target = (score.hg>0 && score.ag>0)?1:0;
    }else{
      const res=String(o.Result||"").toLowerCase();
      target = (res.includes("win") || res==="1") ? 1 : 0;
    }
    o.target = Number(target===1);

    return o;
  }).filter(r=>r.DateObj && !isNaN(r.DateObj));
}

function buildFeatures(ds){
  return ds.map(m=>{
    const [home,away]=safeSplitTeams(m.Match);
    const diff=(a,b)=> (toNumber(m[a])||0) - (toNumber(m[b])||0);
    const odd = toNumber(m.Odd)||NaN;
    return {
      ...m, home, away, odd,
      impProb: odd? 1/odd : NaN,
      diffAttacks:  diff("Home Attacks at FT","Away Attacks at FT"),
      diffDanger:   diff("Home Dangerous Attacks at FT","Away Dangerous Attacks at FT"),
      diffOnTarget: diff("Home OnGoal Shots at FT","Away OnGoal Shots at FT"),
      diffShots:    diff("Home Total Shots at FT","Away Total Shots at FT"),
      diffPoss:     diff("Home Ball Possession at FT","Away Ball Possession at FT"),
      diffCorners:  diff("Home Corners at FT","Away Corners at FT"),
      diffYellows:  diff("Home YellowCards at FT","Away YellowCards at FT"),
      diffReds:     diff("Home RedCards at FT","Away RedCards at FT"),
      diffPosRank: (toNumber(m["Away Position"])||0) - (toNumber(m["Home Position"])||0),
    };
  });
}

function splitTemporal(ds){ const arr=[...ds].sort((a,b)=>a.DateObj-b.DateObj); const cut=Math.floor(arr.length*0.7); return {train:arr.slice(0,cut), test:arr.slice(cut)}; }

function standardize(train, fields){
  const stats={}; fields.forEach(f=>{ const vals=train.map(x=>+x[f]||0); const mu=vals.reduce((a,b)=>a+b,0)/Math.max(vals.length,1); const sd=Math.sqrt(vals.reduce((a,b)=>a+(b-mu)*(b-mu),0)/Math.max(vals.length,1))||1; stats[f]={mu,sd}; });
  const apply=row=>{ const r={...row}; fields.forEach(f=> r[f+"_z"]=((+row[f]||0)-stats[f].mu)/stats[f].sd ); return r; };
  return {stats,apply};
}

function logisticTrain(train,zfeats,iters=700,lr=0.02){
  let w0=0,w={}; zfeats.forEach(f=>w[f]=0);
  for(let it=0;it<iters;it++){
    for(const r of train){
      let z=w0; zfeats.forEach(f=> z+=w[f]*(+r[f+"_z"]||0) );
      const p=1/(1+Math.exp(-z)); const e=(r.target||0)-p;
      w0+=lr*e; zfeats.forEach(f=> w[f]+=lr*e*(+r[f+"_z"]||0) );
    }
  }
  return {w0,w};
}
function predictProb(row,model,zfeats){ let z=model.w0; zfeats.forEach(f=> z+=model.w[f]*(+row[f+"_z"]||0) ); return 1/(1+Math.exp(-z)); }

function gridSearchAlpha(train){
  const feats = ["diffAttacks","diffDanger","diffOnTarget","diffShots","diffPoss","diffCorners","diffYellows","diffReds","diffPosRank","impProb","odd"];
  const {apply} = standardize(train,feats);
  const Z = train.map(apply);
  const model = logisticTrain(Z,feats,700,0.02);
  const minBets = Math.max( Number(document.getElementById("minBets").value||0), Math.ceil(train.length*0.05) );
  let best={alpha:0,roi:-Infinity,bets:0};
  for(let a=0;a<=10;a++){
    const alpha=a/100;
    let pl=0,bets=0;
    for(const r of Z){
      const odd=r.odd; if(!(odd>1)) continue;
      const p=predictProb(r,model,feats);
      if(p>(1/odd)+alpha){ bets++; pl += (r.target==1)?(odd-1):(-1); }
    }
    const roi = bets>0? pl/bets : -Infinity;
    if(bets>=minBets && roi>best.roi) best={alpha,roi,bets};
  }
  return {alpha:best.alpha, model, zfeats:feats, applyFn:apply};
}

function evaluateTest(test, policy){
  const ddStopPct = Number(document.getElementById("ddStop").value||0);
  const stakeMode = document.getElementById("stakeMode").value;
  let tp=0,fp=0,fn=0,tn=0, equity=[0], peak=0, stop=false, picks=[];
  for(const r0 of test){
    const r=policy.applyFn(r0); const odd=r.odd; if(!(odd>1)){ equity.push(equity[equity.length-1]); continue; }
    const p=predictProb(r,policy.model,policy.zfeats); const th=(1/odd)+policy.alpha; const bet=!stop && (p>th);
    let stake=1; if(stakeMode==="kelly"){ const b=(odd-1), q=1-p; let f=(b*p - q)/b; if(!isFinite(f)) f=0; stake=Math.max(0,Math.min(f,0.25)); }
    let gain=0;
    if(bet && stake>0){ gain = (r.target==1)? stake*(odd-1) : -stake; }
    const predCls = bet?1:0;
    if(predCls==1&&r.target==1)tp++; if(predCls==1&&r.target==0)fp++; if(predCls==0&&r.target==1)fn++; if(predCls==0&&r.target==0)tn++;
    equity.push(equity[equity.length-1]+gain); peak=Math.max(peak,equity[equity.length-1]); const dd=peak>0?100*(peak-equity[equity.length-1])/peak:0; if(ddStopPct>0 && dd>=ddStopPct) stop=true;
    if(bet && stake>0){ picks.push({date:r.DateObj, league:r.League, match:r.Match, odd:+odd, p:+p.toFixed(3), stake:+stake.toFixed(3), win:r.target, profit:+gain.toFixed(3)}); }
  }
  const bets=picks.length, pnl=equity[equity.length-1], roi=bets>0? pnl/bets : 0;
  const acc=(tp+tn)>0? (tp+tn)/(tp+tn+fp+fn) : 0;
  return {tp,fp,fn,tn,acc:+acc.toFixed(3),roi:+roi.toFixed(3),equity,picks};
}

function segmentBy(picks,key,bins=null){
  const groups={};
  for(const p of picks){
    let g = key==="odd"? null : p[key];
    if(bins){ for(const b of bins){ if(p.odd>=b.min && p.odd<b.max){ g=b.label; break; } } }
    if(!g) g="N/A"; if(!groups[g]) groups[g]=[]; groups[g].push(p);
  }
  const rows=[];
  for(const k of Object.keys(groups)){
    const arr=groups[k]; const bets=arr.length;
    let wins=0,pl=0; arr.forEach(x=>{ if(x.win==1){wins++; pl+=x.stake*(x.odd-1);} else {pl-=x.stake;} });
    rows.push({group:k,roi:+(pl/Math.max(1,bets)).toFixed(3),acc:+(wins/Math.max(1,bets)).toFixed(3),bets});
  }
  return rows.sort((a,b)=>b.roi-a.roi);
}

function discoverRulesOnTest(test){
  const conds=[
    {desc:"diffAttacks>10", fn:(m)=>m.diffAttacks>10},
    {desc:"diffDanger>5",  fn:(m)=>m.diffDanger>5},
    {desc:"diffShots>4",   fn:(m)=>m.diffShots>4},
    {desc:"odd>2.0",       fn:(m)=>m.odd>2.0},
    {desc:"odd<2.0",       fn:(m)=>m.odd<2.0}
  ];
  const rules=[];
  for(const c of conds){
    const sub=test.filter(c.fn);
    if(sub.length>=8){
      const wins=sub.filter(x=>x.target==1).length;
      const roi=(wins*((sub[0].odd||2)-1)-(sub.length-wins))/sub.length;
      rules.push({cond:c.desc,n:sub.length,roi:+roi.toFixed(3)});
    }
  }
  return rules.sort((a,b)=>b.roi-a.roi).slice(0,10);
}

function destroyChart(id){ if(charts[id]){ charts[id].destroy(); charts[id]=null; } }

function render(dataset){
  const statusHead = `<span class="ok">OK</span> ¬∑ Filas v√°lidas: <b>${dataset.length}</b>`;
  if(!dataset || dataset.length<3){
    setStatus(`${statusHead} ¬∑ <span class="warn">Se requieren ‚â•3 filas para entrenar/probar.</span>`, "");
    document.getElementById("metrics").innerHTML="";
    ["equityChart","confusionChart","equityOddsChart"].forEach(destroyChart);
    ["rulesTable","leagueTable","teamTable","oddsTable","matchesTable"].forEach(id=>document.getElementById(id).innerHTML="");
    return;
  }

  const {train,test}=splitTemporal(dataset);
  const policy=gridSearchAlpha(train);
  const ev=evaluateTest(test,policy);
  lastTestPicks=ev.picks;

  setStatus(`${statusHead} ¬∑ Train: ${train.length} ¬∑ Test: ${test.length} ¬∑ Œ±*: <b>${policy.alpha.toFixed(2)}</b> ¬∑ Apuestas test: <b>${ev.picks.length}</b>`, "ok");
  document.getElementById("metrics").innerHTML =
    `<p>Acc(test): <b>${ev.acc}</b> ¬∑ ROI(test): <b>${ev.roi}</b> ¬∑ Picks: <b>${ev.picks.length}</b></p>`;

  destroyChart("equityChart");
  charts.equityChart=new Chart(document.getElementById("equityChart"),{
    type:"line",
    data:{labels:test.map(x=>x.DateObj.toISOString().slice(0,10)),datasets:[{label:"Equity (test)",data:ev.equity,borderWidth:2}]}
  });

  destroyChart("confusionChart");
  charts.confusionChart=new Chart(document.getElementById("confusionChart"),{
    type:"bar",data:{labels:["TP","FP","FN","TN"],datasets:[{label:"Confusi√≥n",data:[ev.tp,ev.fp,ev.fn,ev.tn]}]}
  });

  const rules=discoverRulesOnTest(test);
  let rt="<tr><th>Condici√≥n</th><th>n</th><th>ROI estim.</th></tr>";
  rules.forEach(r=> rt+=`<tr><td>${r.cond}</td><td>${r.n}</td><td>${r.roi}</td></tr>`);
  document.getElementById("rulesTable").innerHTML=rt;

  // segmentaciones (solo picks donde realmente se apost√≥)
  ev.picks.forEach(p=>{ const [h,a]=safeSplitTeams(p.match||""); p.matchHome=h; p.matchAway=a; });
  const segLeague=segmentBy(ev.picks,"league"), segTeam=segmentBy(ev.picks,"matchHome");
  let lt="<tr><th>Liga</th><th>ROI</th><th>Acierto</th><th>#Apuestas</th></tr>";
  segLeague.forEach(s=> lt+=`<tr><td>${s.group}</td><td>${s.roi}</td><td>${s.acc}</td><td>${s.bets}</td></tr>`);
  document.getElementById("leagueTable").innerHTML=lt;
  let tt="<tr><th>Equipo Local</th><th>ROI</th><th>Acierto</th><th>#Apuestas</th></tr>";
  segTeam.forEach(s=> tt+=`<tr><td>${s.group}</td><td>${s.roi}</td><td>${s.acc}</td><td>${s.bets}</td></tr>`);
  document.getElementById("teamTable").innerHTML=tt;

  const bins=[{min:1,max:1.5,label:"1.00‚Äì1.50"},{min:1.5,max:2,label:"1.50‚Äì2.00"},{min:2,max:2.5,label:"2.00‚Äì2.50"},{min:2.5,max:3,label:"2.50‚Äì3.00"},{min:3,max:100,label:"3.00+"}];
  const segOdds=segmentBy(ev.picks,"odd",bins);
  let ot="<tr><th>Rango Cuota</th><th>ROI</th><th>Acierto</th><th>#Apuestas</th></tr>";
  segOdds.forEach(s=> ot+=`<tr><td>${s.group}</td><td>${s.roi}</td><td>${s.acc}</td><td>${s.bets}</td></tr>`);
  document.getElementById("oddsTable").innerHTML=ot;

  destroyChart("equityOddsChart");
  const equityByBin = segOdds.map(s=>({label:s.group,data:buildEquityForBin(ev.picks,bins,s.group)}));
  const maxLen=Math.max(...equityByBin.map(e=>e.data.length),0);
  charts.equityOddsChart=new Chart(document.getElementById("equityOddsChart"),{
    type:"line",
    data:{labels:Array.from({length:maxLen},(_,i)=>i),datasets:equityByBin.map(e=>({label:e.label,data:e.data,borderWidth:2}))}
  });

  let mt="<tr><th>Fecha</th><th>Liga</th><th>Partido</th><th>Odd</th><th>pÃÇ</th><th>Stake</th><th>Win</th><th>Profit</th></tr>";
  ev.picks.forEach(p=> mt+=`<tr><td>${p.date?new Date(p.date).toISOString().slice(0,10):""}</td><td>${p.league||""}</td><td>${p.match||""}</td><td>${p.odd}</td><td>${p.p}</td><td>${p.stake}</td><td>${p.win}</td><td>${p.profit}</td></tr>`);
  document.getElementById("matchesTable").innerHTML=mt;
}
function buildEquityForBin(picks,bins,label){
  const seq=[]; let eq=0;
  for(const p of picks){
    let g=null; for(const b of bins){ if(p.odd>=b.min && p.odd<b.max){ g=b.label; break; } }
    if(g===label){ eq += (p.win==1)? (p.stake*(p.odd-1)) : (-p.stake); seq.push(+eq.toFixed(4)); }
  }
  if(seq.length===0) seq.push(0); return seq;
}

function applyFilters(){
  const l=document.getElementById("leagueSelect").value;
  const h=document.getElementById("homeSelect").value;
  const a=document.getElementById("awaySelect").value;
  filtered = rawData.filter(m=>{
    let ok=true;
    if(l!=="Todos" && normalizeString(m.League)!==l) ok=false;
    const [home,away]=safeSplitTeams(m.Match);
    if(h!=="Todos" && home!==h) ok=false;
    if(a!=="Todos" && away!==a) ok=false;
    return ok;
  });
  const total=rawData.length, kept=filtered.length, drop=total-kept;
  setStatus(`Filtrados: <b>${kept}</b> / ${total} ¬∑ Omitidos por filtros: ${drop}`, kept? "ok":"warn");
  render(buildFeatures(filtered));
}

function fillSelect(id,arr){ const sel=document.getElementById(id); sel.innerHTML="<option>Todos</option>"; arr.forEach(v=> sel.innerHTML+=`<option>${v}</option>`); }

function exportCSV(){
  const rows=[["Fecha","Liga","Partido","Odd","p_hat","Stake","Win","Profit"]];
  (lastTestPicks||[]).forEach(p=> rows.push([p.date?new Date(p.date).toISOString():"",p.league||"",p.match||"",p.odd,p.p,p.stake,p.win,p.profit]));
  const csv=rows.map(r=>r.join(",")).join("\n"); const a=document.createElement("a");
  a.href=URL.createObjectURL(new Blob([csv],{type:"text/csv"})); a.download="backtesting_test_picks.csv"; a.click();
}

const drop=document.getElementById("dropzone");
drop.addEventListener("dragover",e=>{e.preventDefault();drop.classList.add("dragover");});
drop.addEventListener("dragleave",()=>drop.classList.remove("dragover"));
drop.addEventListener("drop",e=>{e.preventDefault();drop.classList.remove("dragover");handleFile(e.dataTransfer.files[0]);});
document.getElementById("fileInput").addEventListener("change",e=>handleFile(e.target.files[0]));

function handleFile(file){
  const reader=new FileReader();
  reader.onload=e=>{
    const txt=e.target.result;
    const raw=parseJsonLoose(txt);
    if(!raw.length){ setStatus(`No se pudo leer el JSON (aseg√∫rate de que sea un array o NDJSON).`, "err"); return; }
    rawData = baseClean(raw);
    const total=raw.length, valid=rawData.length, dropped=total-valid;
    if(valid===0){ setStatus(`Se leyeron ${total} filas pero <b>0 v√°lidas</b> (fechas/cuotas ausentes). Revisa campos "Date" y "Match".`, "err"); return; }
    const leagues=[...new Set(rawData.map(d=>normalizeString(d.League)).filter(Boolean))].sort();
    const teams=[...new Set(rawData.flatMap(d=>safeSplitTeams(d.Match))).filter(Boolean)].sort();
    fillSelect("leagueSelect",leagues); fillSelect("homeSelect",teams); fillSelect("awaySelect",teams);
    filtered=[...rawData];
    setStatus(`Le√≠das: <b>${total}</b> ¬∑ V√°lidas: <b>${valid}</b> ¬∑ Ignoradas: ${dropped}`, "ok");
    render(buildFeatures(filtered));
  };
  reader.readAsText(file, "UTF-8");
}
</script>
</body>
</html>