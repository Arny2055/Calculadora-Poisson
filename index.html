<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poisson — Probabilidades y Rachas (Solo Modelo)</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet" />
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel2:#1f2430; --text:#e8ecf3; --muted:#9aa3b2;
    --accent:#7aa2ff; --accent2:#5dd4a4; --warn:#ffb84d; --danger:#ff6b6b; --ok:#79e2a6; --border:#2a3140;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(180deg,#0f1115 0%,#121622 100%); color:var(--text)}
  header{padding:20px 16px; border-bottom:1px solid var(--border); background:#10141d; position:sticky; top:0; z-index:5}
  h1{margin:0; font-size:18px; letter-spacing:.3px}
  .wrap{max-width:1200px; margin:0 auto; padding:16px}
  .grid{display:grid; gap:16px}
  @media(min-width:900px){ .grid-cols-2{grid-template-columns:1fr 1fr} .grid-cols-3{grid-template-columns:1.1fr 1fr 1fr}}
  .card{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:14px}
  .card h2{margin:.2rem 0 .8rem; font-size:16px}
  label{font-size:12px; color:var(--muted); display:block; margin:.25rem 0 .35rem}
  input[type="text"],input[type="number"],select,textarea{
    width:100%; background:var(--panel2); color:var(--text); border:1px solid var(--border); border-radius:10px;
    padding:10px 12px; outline:none; font-size:14px;
  }
  .btn{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--border); background:#111827; color:var(--text);
       padding:10px 12px; border-radius:10px; cursor:pointer; text-decoration:none; font-size:14px; user-select:none}
  .btn.primary{background:linear-gradient(90deg,#2647ff,#1fa37e); border-color:transparent}
  .btn.ghost{background:transparent}
  .btn[disabled]{opacity:.5; cursor:not-allowed}
  .muted{color:var(--muted)}
  .kpi{display:flex; gap:12px; flex-wrap:wrap}
  .pill{padding:6px 10px; border-radius:999px; border:1px solid var(--border); background:rgba(255,255,255,.03)}
  .pill.ok{border-color:#234d3b; background:rgba(121,226,166,.08); color:var(--accent2)}
  .sep{height:1px; background:var(--border); margin:12px 0}
  .hint{font-size:12px; color:var(--muted)}
  .success{color:var(--accent2)}
  .danger{color:var(--danger)}
  .tiny{font-size:11px}
  @media(max-width:768px){ .grid-cols-2{grid-template-columns:1fr !important;} .grid-cols-3{grid-template-columns:1fr !important;} }
  @media(max-width:430px){
    .wrap{padding:8px}
    h1{font-size:16px}
    .card h2{font-size:14px}
    input,select,textarea{padding:8px 10px; font-size:14px}
  }
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="topbar">
        <h1>Poisson • Probabilidades y Rachas (Solo Modelo)</h1>
      </div>
    </div>
  </header>

  <div class="wrap grid grid-cols-2">
    <section class="card" aria-labelledby="cargar-datos">
      <h2 id="cargar-datos">1) Cargar datos</h2>
      <div class="grid">
        <div>
          <label for="file">Archivo JSON (array / objeto / NDJSON)</label>
          <input type="file" id="file" accept=".json,application/json,.txt" />
        </div>
      </div>
      <div class="hint tiny" style="margin-top:8px">
        Al seleccionar el archivo se procesará automáticamente. Después elige liga y equipos.
      </div>
      <div id="ingestStatus" class="hint" style="margin-top:8px"></div>
    </section>

    <section class="card" aria-labelledby="seleccion">
      <h2 id="seleccion">2) Selección (Liga y Equipos)</h2>
      <div class="grid">
        <div>
          <label for="selLeague">Liga</label>
          <select id="selLeague"></select>
        </div>
        <div class="grid grid-cols-2">
          <div>
            <label for="selHome">Equipo Local</label>
            <select id="selHome"></select>
          </div>
          <div>
            <label for="selAway">Equipo Visitante</label>
            <select id="selAway"></select>
          </div>
        </div>
      </div>
      <div class="sep"></div>
      <div class="grid grid-cols-3">
        <div>
          <label for="ouLine">Línea OU (ej. 2.5)</label>
          <input type="number" id="ouLine" step="0.5" value="2.5" />
          <div class="hint tiny">Probabilidad de OU > Línea (ej. > 2.5).</div>
        </div>
        <div style="display:none;">
          <label for="bankroll">Bankroll</label>
          <input type="number" id="bankroll" step="1" value="1000" />
        </div>
        <div>
          <label for="maxGoals">Máx. goles sumados (Poisson)</label>
          <input type="number" id="maxGoals" step="1" min="6" value="10" />
          <div class="hint tiny">Tope de suma para las convoluciones de goles.</div>
        </div>
      </div>
      <div class="hint tiny" style="margin-top:10px">
        El modelo se calcula <b>automáticamente</b> al escoger liga y equipos (y al ajustar OU o Máx. goles).
      </div>
    </section>

    <section class="card" aria-labelledby="resultados">
      <h2 id="resultados">3) Resultados del modelo</h2>
      <div id="modelBox" class="kpi">
        <span class="pill">λ Home: <b id="lamH">—</b></span>
        <span class="pill">λ Away: <b id="lamA">—</b></span>
        <span class="pill ok">P(Over <b id="ouLbl">2.5</b>): <b id="pOver">—</b></span>
        <span class="pill">P(BTTS Sí): <b id="pBTTSY">—</b></span>
      </div>
      <div class="sep"></div>
      <div class="kpi">
        <span class="pill">Muestras (H/A): <b id="nHA">—</b></span>
      </div>
      <div class="hint tiny" style="margin-top:6px">
        λH = 0.6·(promedio GF local en casa) + 0.4·(promedio GC visitante fuera) ··
        λA = 0.6·(promedio GF visitante fuera) + 0.4·(promedio GC local en casa).
      </div>
    </section>

    <section class="card" aria-labelledby="rachas">
      <h2 id="rachas">4) Rachas (últimos 10 por lado)</h2>
      <div class="grid grid-cols-2" id="streaksBox">
        <div>
          <span class="pill">Local — BTTS: <b id="stHBTTS">—</b></span>
          <span class="pill">Local — Over <b id="stHOULbl">2.5</b>: <b id="stHOU">—</b></span>
          <div class="hint tiny" id="seqH">—</div>
        </div>
        <div>
          <span class="pill">Visitante — BTTS: <b id="stABTTS">—</b></span>
          <span class="pill">Visitante — Over <b id="stAOULbl">2.5</b>: <b id="stAOU">—</b></span>
          <div class="hint tiny" id="seqA">—</div>
        </div>
      </div>
    </section>

    <div style="display:none;">
        <input type="number" id="oddOver" step="0.01" value="0" />
        <input type="number" id="oddUnder" step="0.01" value="0" />
        <input type="number" id="oddBTTSY" step="0.01" value="0" />
        <input type="number" id="oddBTTSN" step="0.01" value="0" />
        <button id="btnOdds"></button>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // Se eliminan todas las constantes y funciones relacionadas con EV, Kelly, Overround y Guardado.
  // Se mantienen solo las necesarias para el cálculo de Poisson y Rachas.

  let DATA = [];
  let CURRENT = { league:null, home:null, away:null, lambdas:null, probs:null, samples:{nH:0,nA:0} };

  const $ = sel => document.querySelector(sel);
  const setText = (id, txt) => { const el = typeof id==="string" ? document.getElementById(id) : id; if(el) el.textContent = txt; };

  const factorialCache = [1];
  const fact = (n) => { for(let i=factorialCache.length;i<=n;i++) factorialCache[i] = factorialCache[i-1]*i; return factorialCache[n]; };
  const pois = (lambda,k)=> Math.exp(-lambda)*Math.pow(lambda,k)/fact(k);

  const parseFT = (ft) => {
    if(!ft || typeof ft!=="string") return {h:0,a:0,ok:false};
    const m = ft.match(/(-?\d+)\s*[-:]\s*(-?\d+)/);
    if(!m) return {h:0,a:0,ok:false};
    return {h: Number(m[1]), a: Number(m[2]), ok:true};
  };
  const splitTeams = (matchStr) => {
    if(!matchStr) return {home:null, away:null};
    const parts = String(matchStr).split(" - ");
    return {home: (parts[0]||"").trim(), away: (parts[1]||"").trim()};
  };
  const mean = arr => arr.length ? arr.reduce((s,x)=>s+x,0)/arr.length : 0;

  /**
   * Calcula P(Total <= thr) usando convolución Poisson hasta kMax.
   * @param {number} lambdaH - Media de goles Local.
   * @param {number} lambdaA - Media de goles Visitante.
   * @param {number} kMax - Máximo de goles a considerar para cada equipo.
   * @param {number} thr - Umbral de goles (entero). P(Total <= thr)
   * @returns {number} La probabilidad.
   */
  function pTotalLE(lambdaH, lambdaA, kMax, thr){
    let p = 0;
    const pH = Array.from({length:kMax+1}, (_,h)=>pois(lambdaH,h));
    const pA = Array.from({length:kMax+1}, (_,a)=>pois(lambdaA,a));
    for(let h=0; h<=kMax; h++){
      // El umbral se aplica a la suma: h + a <= thr
      const maxA = Math.min(kMax, thr - h);
      for(let a=0; a<=maxA; a++){
        p += pH[h]*pA[a];
      }
    }
    return Math.min(Math.max(p,0),1);
  }

  // Se eliminó cdf1X2 ya que no se usa 1X2.

  function btss(lambdaH, lambdaA){
    const pH0 = Math.exp(-lambdaH); // P(Local anota 0)
    const pA0 = Math.exp(-lambdaA); // P(Visitante anota 0)
    // P(BTTS No) = P(Local no anota) + P(Visitante no anota) - P(Ambos no anotan)
    //             = P(H=0) + P(A=0) - P(H=0, A=0)
    // P(BTTS Sí) = 1 - P(BTTS No)
    // P(BTTS Sí) = 1 - (P(H=0) + P(A=0) - P(H=0)*P(A=0))
    const pNo = pH0 + pA0 - pH0 * pA0;
    return {yes:1-pNo, no:pNo};
  }

  function normalize(obj){
    const {League, Match, "Result FT":RFT, Date, "Home Team":HTX, "Away Team":ATX} = obj;
    const mTeams = splitTeams(Match || "");
    const ft = parseFT(RFT);
    return {
      League: League || obj.LeagueName || obj.Div || "—",
      Match: Match || (HTX && ATX ? `${HTX} - ${ATX}` : ""),
      Home: mTeams.home, Away: mTeams.away,
      FTHG: ft.h, FTAG: ft.a,
      Date: Date || obj.Date || "",
      raw: obj
    };
  }

  async function parseInput(){
    const status = $("#ingestStatus");
    status.textContent = "Procesando...";
    let rows = [];
    const file = $("#file").files[0];

    if(file){
      try{
        const content = await file.text();
        rows = rows.concat(readFlexJSON(content));
      }catch(e){
        status.innerHTML = '<span class="danger">Error leyendo archivo.</span>';
        return;
      }
    } else {
      status.innerHTML = '<span class="danger">Selecciona un archivo para procesar.</span>';
      return;
    }

    if(!rows.length){
      status.innerHTML = '<span class="danger">No se detectó JSON válido.</span>';
      return;
    }

    DATA = rows.map(normalize).filter(r=>r.Match && (r.Home||"") && (r.Away||""));

    if(!DATA.length){
      status.innerHTML = '<span class="danger">No se pudieron normalizar partidos.</span>';
      return;
    }

    const leagues = [...new Set(DATA.map(r=>r.League))].sort((a,b)=>a.localeCompare(b));
    fillSelect($("#selLeague"), leagues, "— Selecciona liga —");
    fillSelect($("#selHome"), [], "— Local —");
    fillSelect($("#selAway"), [], "— Visitante —");

    status.innerHTML = `<span class="success">OK:</span> ${DATA.length} partidos cargados · ${leagues.length} ligas.`;

    // Lógica para preseleccionar si solo hay una liga
    if(leagues.length===1){
      $("#selLeague").value = leagues[0];
      CURRENT.league = leagues[0];
      const teams = getLeagueTeams(leagues[0]);
      fillSelect($("#selHome"), teams, "— Local —");
      fillSelect($("#selAway"), teams, "— Visitante —");
      if(teams.length>=2){
        $("#selHome").value = teams[0];
        $("#selAway").value = teams[1];
        CURRENT.home = teams[0];
        CURRENT.away = teams[1];
        autoCalcPoisson(false); // No se necesita refresh EV
      }
    }
  }

  function readFlexJSON(text){
    text = text.trim();
    if(!text) return [];
    try{
      const parsed = JSON.parse(text);
      return Array.isArray(parsed) ? parsed : [parsed];
    }catch(e){
      const lines = text.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      const arr = [];
      for(const line of lines){
        try{ arr.push(JSON.parse(line)); }catch(_){}}
      return arr;
    }
  }

  function fillSelect(sel, items, placeholder){
    sel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = ""; opt0.textContent = placeholder || "—";
    sel.appendChild(opt0);
    for(const it of items){
      const o = document.createElement("option");
      o.value = it; o.textContent = it;
      sel.appendChild(o);
    }
  }

  function getLeagueTeams(league){
    const set = new Set();
    for(const r of DATA) if(r.League===league){ set.add(r.Home); set.add(r.Away); }
    set.delete(null); set.delete("");
    return [...set].sort((a,b)=>a.localeCompare(b));
  }

  function lastMatchesTeam(league, team, side, limit=10){
    const arr = [];
    for(const r of DATA){
      if(r.League!==league) continue;
      // Para Local: busca donde el equipo es Home. FTHG (goles a favor), FTAG (goles en contra)
      if(side==="home" && r.Home===team) arr.push(r);
      // Para Visitante: busca donde el equipo es Away. FTAG (goles a favor), FTHG (goles en contra)
      if(side==="away" && r.Away===team) arr.push(r);
    }
    // Ordenar cronológicamente (más reciente al final)
    arr.sort((a,b)=> new Date(a.Date||0) - new Date(b.Date||0));
    return arr.slice(-limit);
  }

  function goalsStats(league, team){
    const lastH = lastMatchesTeam(league, team, "home", 10);
    const lastA = lastMatchesTeam(league, team, "away", 10);

    // Goles a favor (GF) y Goles en contra (GC)
    const gfH = lastH.map(m=>m.FTHG); // Local: Goles a favor
    const gcH = lastH.map(m=>m.FTAG); // Local: Goles en contra
    const gfA = lastA.map(m=>m.FTAG); // Visitante: Goles a favor
    const gcA = lastA.map(m=>m.FTHG); // Visitante: Goles en contra

    return {
      nH: lastH.length, nA: lastA.length,
      avgGF_H: mean(gfH), avgGC_H: mean(gcH),
      avgGF_A: mean(gfA), avgGC_A: mean(gcA)
    };
  }

  function computeLambdas(league, home, away){
    const H = goalsStats(league, home);
    const A = goalsStats(league, away);

    // λH = 60% GF Local en casa + 40% GC Visitante fuera
    const lamH = 0.6*(H.avgGF_H||0) + 0.4*(A.avgGC_A||0);
    // λA = 60% GF Visitante fuera + 40% GC Local en casa
    const lamA = 0.6*(A.avgGF_A||0) + 0.4*(H.avgGC_H||0);

    CURRENT.samples = {nH:H.nH, nA:A.nA};
    return { lamH, lamA };
  }

  function computeAllProbs(lambdaH, lambdaA, ouLine, kMax){
    const thr = Math.floor(ouLine);
    // P(Total <= thr)
    const pLE = pTotalLE(lambdaH, lambdaA, kMax, thr);
    // Si es línea entera (ej. 2.0), P(Under) = P(Total <= 2), P(Over) = P(Total >= 3)
    // Si es línea decimal (ej. 2.5), P(Under) = P(Total <= 2), P(Over) = P(Total >= 3)
    // En ambos casos, P(Over > Line) = 1 - P(Total <= thr)

    const pOver = 1 - pLE;
    const pUnder = pLE;

    const b = btss(lambdaH, lambdaA);
    
    // Solo necesitamos Over y BTTS Sí
    return { ou:{over:pOver, under:pUnder}, btts:{yes:b.yes, no:b.no} };
  }

  function fmtPct(x){ return isFinite(x) ? (100*x).toFixed(1)+"%" : "—"; }
  function fmtDec(x){ return isFinite(x) ? x.toFixed(3) : "—"; }
  
  function renderModel(){
    const { lambdas, probs, samples } = CURRENT;
    if(!lambdas || !probs){ 
        setText("lamH", "—"); setText("lamA", "—"); 
        setText("pOver", "—"); setText("pBTTSY", "—"); 
        setText("nHA", "—");
        return; 
    }
    const line = Number($("#ouLine").value || 2.5);
    setText("lamH", fmtDec(lambdas.lamH));
    setText("lamA", fmtDec(lambdas.lamA));
    setText("ouLbl", line);

    setText('pOver',  fmtPct(probs.ou.over));
    setText('pBTTSY', fmtPct(probs.btts.yes));
    
    setText("nHA", `${samples.nH}/${samples.nA}`);

    // Llamar a la función de rachas
    renderStreaks();
  }

  // Se eliminó la función calcOdds ya que no se usa.
  // Se eliminó la función buildRow/trySave/savePick ya que no se usan.

  // ====== Utilidades de rachas ======
  function outcomesFromMatches(matches, ouLine){
    const btts = [];
    const ou = [];
    for(const m of matches){
      const h = m.FTHG ?? 0;
      const a = m.FTAG ?? 0;
      const total = (Number(h)||0) + (Number(a)||0);
      btts.push((h>0) && (a>0));
      ou.push(total > ouLine);
    }
    return { btts, ou };
  }

  function streakCount(arr, targetTrue){
    // Cuenta consecutivos desde el final del array (más reciente)
    let c = 0;
    for(let i=arr.length-1; i>=0; i--){
      if(Boolean(arr[i]) === Boolean(targetTrue)) c++; else break;
    }
    return c;
  }

  function seqString(arr, trueChar, falseChar){
    // Muestra 10 símbolos, último a la derecha (más reciente)
    if(!arr.length) return "—";
    return arr.map(v => v ? trueChar : falseChar).join(" ");
  }

  function renderStreaks(){
    const league = $("#selLeague").value;
    const home = $("#selHome").value;
    const away = $("#selAway").value;
    const line = Number($("#ouLine").value || 2.5);

    setText("stHOULbl", line);
    setText("stAOULbl", line);

    if(!league || !home || !away || home===away){
      setText("stHBTTS","—"); setText("stHOU","—"); setText("seqH","—");
      setText("stABTTS","—"); setText("stAOU","—"); setText("seqA","—");
      return;
    }

    const lastH = lastMatchesTeam(league, home, "home", 10);   // local en casa
    const lastA = lastMatchesTeam(league, away, "away", 10);   // visitante fuera

    const H = outcomesFromMatches(lastH, line);
    const A = outcomesFromMatches(lastA, line);

    // Rachas: contamos Sí para BTTS y Over para OU
    const hBTTSst = streakCount(H.btts, true);
    const hOUst   = streakCount(H.ou, true);
    const aBTTSst = streakCount(A.btts, true);
    const aOUst   = streakCount(A.ou, true);

    setText("stHBTTS", lastH.length ? `${hBTTSst} Sí` : "—");
    setText("stHOU",   lastH.length ? `${hOUst} Over` : "—");
    setText("stABTTS", lastA.length ? `${aBTTSst} Sí` : "—");
    setText("stAOU",   lastA.length ? `${aOUst} Over` : "—");

    // Secuencias (cronológico: izq = más antiguo, der = más reciente)
    const seqHtxt = lastH.length
      ? `BTTS: ${seqString(H.btts,'Y','N')} · Over ${line}: ${seqString(H.ou,'O','U')}`
      : "—";
    const seqAtxt = lastA.length
      ? `BTTS: ${seqString(A.btts,'Y','N')} · Over ${line}: ${seqString(A.ou,'O','U')}`
      : "—";

    setText("seqH", seqHtxt);
    setText("seqA", seqAtxt);
  }

  // ====== Eventos UI ======
  $("#file").addEventListener("change", parseInput);

  $("#selLeague").addEventListener("change", (e)=>{
    const lg = e.target.value;
    CURRENT.league = lg || null;
    if(!lg){
      fillSelect($("#selHome"), [], "— Local —");
      fillSelect($("#selAway"), [], "— Visitante —");
      renderStreaks();
      return;
    }
    const teams = getLeagueTeams(lg);
    fillSelect($("#selHome"), teams, "— Local —");
    fillSelect($("#selAway"), teams, "— Visitante —");
    if(teams.length>=2){
      $("#selHome").value = teams[0];
      $("#selAway").value = teams[1];
      CURRENT.home = teams[0];
      CURRENT.away = teams[1];
      autoCalcPoisson(false);
    }
  });

  $("#selHome").addEventListener("change", (e)=>{ CURRENT.home = e.target.value || null; autoCalcPoisson(false); });
  $("#selAway").addEventListener("change", (e)=>{ CURRENT.away = e.target.value || null; autoCalcPoisson(false); });

  $("#ouLine").addEventListener("input", ()=>{ autoCalcPoisson(false); });
  $("#maxGoals").addEventListener("input", ()=>{ autoCalcPoisson(false); });

  // Se eliminaron todos los listeners de cuotas y bankroll

  function autoCalcPoisson(alsoRefreshEV=false){
    const league = $("#selLeague").value;
    const home = $("#selHome").value;
    const away = $("#selAway").value;
    if(!league || !home || !away || home===away) { renderStreaks(); return; }
    
    const { lamH, lamA } = computeLambdas(league, home, away);
    const line = Number($("#ouLine").value || 2.5);
    const kMax = Math.max(6, Number($("#maxGoals").value || 10));
    
    const probs = computeAllProbs(lamH, lamA, line, kMax);
    
    CURRENT.lambdas = {lamH, lamA};
    CURRENT.probs = probs;
    renderModel();
    // La parte de calcOdds (EV/Kelly) ha sido eliminada.
  }

})();
</script>
</body>
</html>
