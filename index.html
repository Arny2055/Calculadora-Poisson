<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BetAGS Pro - Calculadora de Poisson Doble Corregido</title>
</head>
<body>

<div id="calculator-container" class="light-mode">
    <header>
        <h1>BetAGS Pro ⚽</h1>
        <h2>Calculadora de Predicción Avanzada (Modelo de Poisson Corregido)</h2>
    </header>

    <main>
        <section id="input-params">
            <h3>Parámetros Base (Datos Históricos)</h3>
            <div class="input-grid">
                <div>
                    <label for="gl_l">GL_L (Media Goles Liga Local):</label>
                    <input type="number" id="gl_l" value="1.50" step="0.01">
                </div>
                <div>
                    <label for="gl_v">GL_V (Media Goles Liga Visitante):</label>
                    <input type="number" id="gl_v" value="1.20" step="0.01">
                </div>
                <div>
                    <label for="gf_l">GF_L (Media Goles a Favor Local):</label>
                    <input type="number" id="gf_l" value="1.70" step="0.01">
                </div>
                <div>
                    <label for="gc_l">GC_L (Media Goles en Contra Local):</label>
                    <input type="number" id="gc_l" value="1.00" step="0.01">
                </div>
                <div>
                    <label for="gf_v">GF_V (Media Goles a Favor Visitante):</label>
                    <input type="number" id="gf_v" value="1.40" step="0.01">
                </div>
                <div>
                    <label for="gc_v">GC_V (Media Goles en Contra Visitante):</label>
                    <input type="number" id="gc_v" value="1.30" step="0.01">
                </div>
            </div>
            <div class="correction-factor">
                <label for="correlation_factor">Factor de Correlación Empírica (0-0 & 1-1):</label>
                <input type="number" id="correlation_factor" value="0.04" step="0.005">
            </div>
            <button onclick="calculatePredictions()">Calcular Predicciones</button>
        </section>
        
        <hr>

        <section id="output-results">
            <h3>Resultados de Predicción</h3>

            <div class="result-box">
                <h4>1) Probabilidades y Cuotas Implícitas</h4>
                <table id="prob-odds-table">
                    <thead>
                        <tr><th>Mercado</th><th>Probabilidad (P)</th><th>Cuota Implícita (1/P)</th><th>Sugerencia de Cuota Mínima de Valor</th></tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            </div>
            
            <div class="result-box">
                <h4>2) Matriz de Probabilidades de Marcador Exacto (Corregido)</h4>
                <div class="score-matrix-container">
                    <table id="score-matrix">
                        <thead>
                            <tr><th>L \ V</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4+</th></tr>
                        </thead>
                        <tbody>
                            <tr><th>0</th><td></td><td></td><td></td><td></td><td></td></tr>
                            <tr><th>1</th><td></td><td></td><td></td><td></td><td></td></tr>
                            <tr><th>2</th><td></td><td></td><td></td><td></td><td></td></tr>
                            <tr><th>3</th><td></td><td></td><td></td><td></td><td></td></tr>
                            <tr><th>4+</th><td></td><td></td><td></td><td></td><td></td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="result-box">
                <h4>3) Sugerencias de Valor (Asume Cuota de Mercado)</h4>
                <p class="advice-text">Para evaluar el valor, la probabilidad predicha (P) debe ser significativamente mayor que la cuota de mercado (C). Se sugiere valor si $P \geq 1/C + 0.05$.</p>
                <div id="value-suggestions">
                    <p class="no-value-msg">Calcula para ver sugerencias.</p>
                </div>
            </div>

        </section>
    </main>

    <footer>
        <button id="mode-toggle" onclick="toggleMode()">Modo Oscuro</button>
    </footer>
</div>

<style>
    :root {
        --bg-color-light: #f4f4f9;
        --text-color-light: #333;
        --card-bg-light: #fff;
        --border-color-light: #ddd;
        --primary-color: #007bff;
        --success-color: #28a745;
        --warning-color: #ffc107;
        --danger-color: #dc3545;
    }

    .dark-mode {
        --bg-color-light: #121212;
        --text-color-light: #e0e0e0;
        --card-bg-light: #1e1e1e;
        --border-color-light: #333;
        --primary-color: #90CAF9;
        --success-color: #66BB6A;
        --warning-color: #FFEB3B;
        --danger-color: #EF5350;
    }

    body {
        font-family: 'Arial', sans-serif;
        margin: 0;
        padding: 20px;
        background-color: var(--bg-color-light);
        color: var(--text-color-light);
        transition: background-color 0.3s, color 0.3s;
    }

    #calculator-container {
        max-width: 1000px;
        margin: 0 auto;
        padding: 30px;
        background-color: var(--card-bg-light);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        border-radius: 10px;
    }

    header h1, header h2, h3, h4 {
        color: var(--primary-color);
        text-align: center;
        margin-bottom: 5px;
    }

    header h2 {
        font-size: 1em;
        margin-bottom: 20px;
    }

    /* Inputs */
    .input-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 15px;
        margin-bottom: 20px;
    }

    .input-grid div, .correction-factor {
        display: flex;
        flex-direction: column;
    }

    label {
        font-weight: bold;
        margin-bottom: 5px;
    }

    input[type="number"] {
        padding: 8px;
        border: 1px solid var(--border-color-light);
        border-radius: 4px;
        background-color: var(--bg-color-light);
        color: var(--text-color-light);
    }

    button {
        padding: 10px 15px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
        font-weight: bold;
    }

    button:hover {
        background-color: #0056b3;
    }

    /* Results */
    .result-box {
        margin-top: 25px;
        padding: 15px;
        border: 1px solid var(--border-color-light);
        border-radius: 8px;
    }

    /* Table */
    table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 0.9em;
    }

    th, td {
        border: 1px solid var(--border-color-light);
        padding: 8px;
        text-align: center;
    }

    th {
        background-color: var(--bg-color-light);
        font-weight: bold;
    }

    .highlight-win { background-color: rgba(40, 167, 69, 0.2); } /* Green tint */
    .highlight-draw { background-color: rgba(255, 193, 7, 0.2); } /* Yellow tint */
    .highlight-loss { background-color: rgba(220, 53, 69, 0.2); } /* Red tint */

    /* Score Matrix */
    .score-matrix-container {
        overflow-x: auto;
    }

    #score-matrix td {
        min-width: 60px;
        font-weight: bold;
    }

    #score-matrix .max-prob {
        background-color: var(--primary-color);
        color: white;
    }

    /* Value Suggestions */
    #value-suggestions {
        padding: 10px;
        border: 1px solid var(--border-color-light);
        border-radius: 5px;
        margin-top: 10px;
    }

    .value-tip {
        background-color: var(--success-color);
        color: white;
        padding: 8px;
        margin: 5px 0;
        border-radius: 4px;
        font-weight: bold;
    }
    
    .advice-text {
        font-style: italic;
        font-size: 0.9em;
        color: #777;
        text-align: center;
    }
    
    .dark-mode .advice-text {
        color: #aaa;
    }
    
    .no-value-msg {
        text-align: center;
        color: #777;
    }

    /* Footer and Toggle */
    footer {
        text-align: center;
        margin-top: 30px;
    }
    
    #mode-toggle {
        background-color: #6c757d;
    }
    
    #mode-toggle:hover {
        background-color: #5a6268;
    }
</style>

<script>
    // Fija la distribución de Poisson para un valor k y una tasa lambda
    function poisson(k, lambda) {
        if (k < 0) return 0;
        return (Math.exp(-lambda) * Math.pow(lambda, k)) / factorial(k);
    }

    // Cache para factoriales
    const factorialCache = {};
    function factorial(n) {
        if (n in factorialCache) return factorialCache[n];
        if (n === 0 || n === 1) return 1;
        let result = 1;
        for (let i = 2; i <= n; i++) {
            result *= i;
        }
        return factorialCache[n] = result;
    }
    
    // Función principal de cálculo
    function calculatePredictions() {
        // 1. Obtener Parámetros de Entrada
        const GL_L = parseFloat(document.getElementById('gl_l').value);
        const GL_V = parseFloat(document.getElementById('gl_v').value);
        const GF_L = parseFloat(document.getElementById('gf_l').value);
        const GC_L = parseFloat(document.getElementById('gc_l').value);
        const GF_V = parseFloat(document.getElementById('gf_v').value);
        const GC_V = parseFloat(document.getElementById('gc_v').value);
        const CORR_FACTOR = parseFloat(document.getElementById('correlation_factor').value);

        if (isNaN(GL_L) || isNaN(GL_V) || isNaN(GF_L) || isNaN(GC_L) || isNaN(GF_V) || isNaN(GC_V) || isNaN(CORR_FACTOR)) {
            alert('Por favor, introduce valores numéricos válidos en todos los campos.');
            return;
        }

        // 2. Calcular las Tasas Esperadas de Goles (Lambdas)
        // Estructura simplificada del modelo Double Poisson para predicción de partidos:
        // lambda_Local = Tasa_Goles_Liga * Fuerza_Ataque_Local * Debilidad_Defensa_Visitante
        // lambda_Visitante = Tasa_Goles_Liga * Fuerza_Ataque_Visitante * Debilidad_Defensa_Local
        
        // El modelo aquí usa una forma más directa basada en los promedios
        const lambdaL = (GF_L / GL_L) * (GC_V / GL_V) * GL_L; // Tasa esperada para el local
        const lambdaV = (GF_V / GL_V) * (GC_L / GL_L) * GL_V; // Tasa esperada para el visitante

        // 3. Generar Matriz de Probabilidades Inicial (Poisson Independiente)
        const maxGoals = 4; // Máximo para la matriz visual (0 a 4+)
        let probMatrix = [];
        let totalProb = 0;

        for (let i = 0; i <= maxGoals; i++) { // Goles Local (L)
            probMatrix[i] = [];
            for (let j = 0; j <= maxGoals; j++) { // Goles Visitante (V)
                if (i < maxGoals && j < maxGoals) {
                    // Probabilidad Poisson para el marcador exacto L-V
                    probMatrix[i][j] = poisson(i, lambdaL) * poisson(j, lambdaV);
                } else if (i == maxGoals && j < maxGoals) {
                    // Probabilidad de L >= maxGoals contra V=j
                    let probL_plus = 0;
                    for (let k = maxGoals; k <= 7; k++) { // Suma hasta un límite alto
                        probL_plus += poisson(k, lambdaL);
                    }
                    probMatrix[i][j] = probL_plus * poisson(j, lambdaV);
                } else if (i < maxGoals && j == maxGoals) {
                    // Probabilidad de L=i contra V >= maxGoals
                    let probV_plus = 0;
                    for (let k = maxGoals; k <= 7; k++) {
                        probV_plus += poisson(k, lambdaV);
                    }
                    probMatrix[i][j] = poisson(i, lambdaL) * probV_plus;
                } else {
                    // Probabilidad de L >= maxGoals contra V >= maxGoals (4+-4+)
                    let probL_plus = 0;
                    for (let k = maxGoals; k <= 7; k++) {
                        probL_plus += poisson(k, lambdaL);
                    }
                    let probV_plus = 0;
                    for (let k = maxGoals; k <= 7; k++) {
                        probV_plus += poisson(k, lambdaV);
                    }
                    probMatrix[i][j] = probL_plus * probV_plus;
                }
                totalProb += probMatrix[i][j];
            }
        }

        // Normalización inicial para asegurar que la matriz inicial sume 100%
        let normalizedProbMatrix = probMatrix.map(row => row.map(p => p / totalProb));
        
        // 4. Aplicar Correlación (Corrección de Dixon & Cole simplificada/empírica)
        const correctionSum = normalizedProbMatrix[0][0] + normalizedProbMatrix[1][1];
        
        // Sumamos el factor de correlación a 0-0 y 1-1
        normalizedProbMatrix[0][0] += CORR_FACTOR * (normalizedProbMatrix[0][0] / correctionSum);
        normalizedProbMatrix[1][1] += CORR_FACTOR * (normalizedProbMatrix[1][1] / correctionSum);
        
        // Reducimos proporcionalmente el resto de la matriz para re-normalizar
        const factorReduction = (1 - CORR_FACTOR) / 1; // Para restar lo que se añadió
        
        let finalProbMatrix = [];
        let newTotalProb = 0;

        for (let i = 0; i <= maxGoals; i++) {
            finalProbMatrix[i] = [];
            for (let j = 0; j <= maxGoals; j++) {
                if (!((i === 0 && j === 0) || (i === 1 && j === 1))) {
                    // Reducir la probabilidad de todos los demás marcadores
                    finalProbMatrix[i][j] = normalizedProbMatrix[i][j] * factorReduction;
                } else {
                    // Mantener los valores corregidos para 0-0 y 1-1
                    finalProbMatrix[i][j] = normalizedProbMatrix[i][j];
                }
                newTotalProb += finalProbMatrix[i][j];
            }
        }
        
        // Ajuste final para asegurar que la suma es 1.0 (pequeños errores de redondeo)
        const finalNormalizationFactor = 1.0 / newTotalProb;
        for (let i = 0; i <= maxGoals; i++) {
            for (let j = 0; j <= maxGoals; j++) {
                finalProbMatrix[i][j] *= finalNormalizationFactor;
            }
        }


        // 5. Calcular Mercados (1X2, O/U, Ambos Anotan)
        let prob1 = 0; // Local Gana (L > V)
        let probX = 0; // Empate (L = V)
        let prob2 = 0; // Visitante Gana (L < V)
        let probOU15 = 0;
        let probOU25 = 0;
        let probOU35 = 0;
        let probBTTS = 0; // Both Teams To Score (L >= 1 and V >= 1)
        
        // Recalculamos las probabilidades totales sumando la matriz completa (0 a 4+)
        for (let i = 0; i <= maxGoals; i++) {
            for (let j = 0; j <= maxGoals; j++) {
                const P = finalProbMatrix[i][j];

                if (i > j) { prob1 += P; }
                else if (i === j) { probX += P; }
                else { prob2 += P; }
                
                const totalGoals = (i === maxGoals ? maxGoals : i) + (j === maxGoals ? maxGoals : j); // Aprox. para 4+
                
                if (totalGoals > 1.5) { probOU15 += P; }
                if (totalGoals > 2.5) { probOU25 += P; }
                if (totalGoals > 3.5) { probOU35 += P; }

                if (i >= 1 && j >= 1) { probBTTS += P; }
            }
        }
        
        // 6. Formatear y Mostrar Resultados
        
        // Datos para la tabla de Probabilidades/Cuotas
        const markets = [
            { name: '1 (Local Gana)', prob: prob1, type: 'win' },
            { name: 'X (Empate)', prob: probX, type: 'draw' },
            { name: '2 (Visitante Gana)', prob: prob2, type: 'loss' },
            { name: 'Over 1.5 Goles', prob: probOU15, type: 'over' },
            { name: 'Under 1.5 Goles', prob: 1 - probOU15, type: 'under' },
            { name: 'Over 2.5 Goles', prob: probOU25, type: 'over' },
            { name: 'Under 2.5 Goles', prob: 1 - probOU25, type: 'under' },
            { name: 'Over 3.5 Goles', prob: probOU35, type: 'over' },
            { name: 'Under 3.5 Goles', prob: 1 - probOU35, type: 'under' },
            { name: 'Ambos Anotan (Sí)', prob: probBTTS, type: 'btts' },
            { name: 'Ambos Anotan (No)', prob: 1 - probBTTS, type: 'btts' }
        ];

        // 6.1 Tabla Detallada
        const tableBody = document.querySelector('#prob-odds-table tbody');
        tableBody.innerHTML = '';
        
        markets.forEach(m => {
            const probPercent = (m.prob * 100).toFixed(2) + '%';
            const impliedOdd = (1 / m.prob).toFixed(2);
            // Criterio de valor: Cuota de mercado > (1/P) + 0.1
            const minOddValue = (1 / m.prob + 0.1).toFixed(2); 

            let rowClass = '';
            if (m.type === 'win') rowClass = 'highlight-win';
            if (m.type === 'draw') rowClass = 'highlight-draw';
            if (m.type === 'loss') rowClass = 'highlight-loss';
            
            tableBody.innerHTML += `
                <tr class="${rowClass}">
                    <td>${m.name}</td>
                    <td>${probPercent}</td>
                    <td>$${impliedOdd}</td>
                    <td>$${minOddValue}</td>
                </tr>
            `;
        });
        
        // 6.2 Matriz Visual de Marcadores
        const matrixTable = document.getElementById('score-matrix');
        let maxProbScore = { i: -1, j: -1, prob: -1 };
        
        for (let i = 0; i <= maxGoals; i++) {
            const row = matrixTable.rows[i + 1]; // +1 para saltar el thead
            for (let j = 0; j <= maxGoals; j++) {
                const cell = row.cells[j + 1]; // +1 para saltar la columna de encabezado
                const P = finalProbMatrix[i][j];
                const probPercent = (P * 100).toFixed(2) + '%';
                
                cell.textContent = probPercent;
                cell.className = ''; // Limpiar clases anteriores

                if (P > maxProbScore.prob) {
                    maxProbScore = { i: i, j: j, prob: P };
                }
            }
        }
        
        // Resaltar el marcador con la máxima probabilidad
        if (maxProbScore.i !== -1) {
            matrixTable.rows[maxProbScore.i + 1].cells[maxProbScore.j + 1].classList.add('max-prob');
        }

        // 6.3 Sugerencias de Valor
        const suggestionsDiv = document.getElementById('value-suggestions');
        suggestionsDiv.innerHTML = '';
        let hasValue = false;
        
        // Criterio Sugerencia de Valor: P es alta (ej. > 65% o 0.65) y Cuota de Mercado > Cuota Mínima de Valor
        // Aquí asumiremos que si P es del 65% (Cuota $1.54), y la casa da $1.65, es valor (Valor > Cuota Implícita + 0.1)
        
        markets.forEach(m => {
            const impliedOdd = 1 / m.prob;
            // Simulamos que una casa de apuestas da una cuota X (ajusta este valor para probar)
            // Para el ejemplo, usaremos una cuota simulada si la probabilidad es alta
            let simulatedOdd = 0;
            if (m.prob >= 0.65) simulatedOdd = (impliedOdd + 0.1); // Asume valor si P es alta
            else if (m.prob >= 0.50) simulatedOdd = (impliedOdd + 0.15); // Asume valor si P es media

            // Si la Cuota Mínima de Valor es menor que la Cuota Simualada, hay "Valor"
            if (simulatedOdd > 0 && simulatedOdd > impliedOdd + 0.1) {
                suggestionsDiv.innerHTML += `
                    <p class="value-tip">🤑 **¡VALOR EN ${m.name}!** Prob. Predicha: **${(m.prob * 100).toFixed(2)}%** (Cuota Impl.: $${impliedOdd.toFixed(2)}). Cuota de Mercado ($${simulatedOdd.toFixed(2)}) > Cuota Mínima de Valor ($${(impliedOdd + 0.1).toFixed(2)}).</p>
                `;
                hasValue = true;
            }
        });
        
        if (!hasValue) {
            suggestionsDiv.innerHTML = `<p class="no-value-msg">No se encontraron sugerencias de valor significativas con el criterio actual. Intenta simular las cuotas de mercado.</p>`;
        }
    }
    
    // Función para alternar Modo Oscuro/Claro
    function toggleMode() {
        const container = document.getElementById('calculator-container');
        const button = document.getElementById('mode-toggle');
        
        if (container.classList.contains('light-mode')) {
            container.classList.remove('light-mode');
            container.classList.add('dark-mode');
            button.textContent = 'Modo Claro';
        } else {
            container.classList.remove('dark-mode');
            container.classList.add('light-mode');
            button.textContent = 'Modo Oscuro';
        }
    }
    
    // Ejecutar el cálculo al cargar la página con valores por defecto
    document.addEventListener('DOMContentLoaded', calculatePredictions);
</script>

</body>
</html>
