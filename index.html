<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Football Value-Hacker v10.1 (Optimizado)</title>
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <style>
        /* Estilos CSS Base (Ajustados para nuevas m√©tricas) */
        :root {
            --bg-main: #0c1524;
            --bg-panel: #1a2434;
            --bg-card: #222e40;
            --text-primary: #e2e8f0;
            --text-secondary: #94a3b8;
            --border: #334155;
            --accent: #f59e0b; 
            --accent-hover: #d97706;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --stats-bg: #1e3a8a;
            --stats-accent: #60a5fa;
        }
        * { box-sizing: border-box; outline: none; min-width: 0; }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-main); color: var(--text-primary); margin: 0; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        .separator { border: 0; height: 1px; background: var(--border); margin: 15px 0; }
        header { background-color: var(--bg-panel); padding: 10px 15px; height: 50px; display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid var(--border); flex-shrink: 0; }
        .brand { font-weight: 700; font-size: 1.1rem; display: flex; align-items: center; gap: 8px; color: var(--accent);}
        .tag { font-size:0.6em; background:var(--danger); padding:2px 6px; border-radius:8px; color:white; font-weight: normal; }
        .btn { padding: 6px 12px; border-radius: 6px; cursor: pointer; border: none; font-weight: 600; display: flex; align-items: center; gap: 6px; color:white; font-size: 0.8rem; transition: background-color 0.2s;}
        .btn-secondary { background: var(--bg-card); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--border); }
        .container { display: grid; grid-template-columns: 250px 1fr; height: calc(100vh - 50px); overflow: hidden; }
        .sidebar { background-color: var(--bg-panel); border-right: 1px solid var(--border); padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .sidebar h3 { margin: 0; font-size: 0.75rem; text-transform: uppercase; color: var(--text-secondary); letter-spacing: 0.5px; padding-bottom: 5px; }
        .control-group label { display: block; margin-bottom: 2px; font-size: 0.8rem; color: var(--text-secondary); font-weight: 600;}
        select, input[type="number"], input[type="text"] { width: 100%; padding: 6px; background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; color: white; font-size: 0.8rem;}
        .btn-run { background: var(--success); width: 100%; justify-content: center; padding: 10px; margin-top: 10px; font-size: 0.9rem; }
        .tab-controls { display: flex; margin-bottom: 10px; border-bottom: 1px solid var(--border); }
        .tab-button { flex-grow: 1; text-align: center; padding: 8px 0; cursor: pointer; font-size: 0.8rem; font-weight: 600; color: var(--text-secondary); border-bottom: 2px solid transparent;}
        .tab-button.active { color: var(--accent); border-bottom: 2px solid var(--accent); }
        .tab-content { display: none; padding-top: 5px; }
        .tab-content.active { display: block; }
        .matchup-selectors { display: flex; flex-direction: column; gap: 8px; }
        .main { padding: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .kpi-wrapper { overflow-x: auto; white-space: nowrap; padding-bottom: 5px; }
        .kpi-grid { display: inline-flex; gap: 10px; }
        .kpi-card { min-width: 140px; background: var(--bg-card); padding: 10px; border-radius: 6px; border: 1px solid var(--border); }
        .kpi-title { font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; }
        .kpi-value { font-size: 1.3rem; font-weight: 700; margin-top: 2px; }
        .text-green { color: var(--success); }
        .text-red { color: var(--danger); }
        .text-blue { color: var(--stats-accent); }
        .text-orange { color: var(--warning); }
        .stats-card { background: #2f496e; padding: 15px; border-radius: 6px; border: 1px solid var(--stats-accent); flex-shrink: 0; display:none;}
        .stats-grid-wrapper { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px dashed var(--border); }
        .stats-odds-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px;}
        .stats-odds-item { padding: 6px;}
        .score-matrix table { width: 100%; font-size: 0.75rem; }
        .score-matrix th, .score-matrix td { padding: 3px; border: 1px solid #334155;}
        .chart-box-full { height: 250px; }
        .split-row { display: flex; gap: 15px; }
        .panel-box { width: 50%; }
        .panel-title { font-size: 0.85rem; }
        .table-scroll { overflow-y: auto; flex-grow: 1; }
        table { width: 100%; border-collapse: collapse; font-size: 0.8rem; } 
        th { padding: 8px 10px; }
        td { padding: 6px 10px; }
        #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 1000; display: none; flex-direction: column; justify-content: center; align-items: center; color: white; font-size: 2rem;}
        .spinner { animation: spin 1.5s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #teamTable th, #teamTable td { padding: 4px 6px; font-size: 0.75rem; text-align: center;}
        #teamTable th:first-child, #teamTable td:first-child { text-align: left; width: 40%; font-size: 0.8rem;}
        #teamTable thead th { font-weight: 700; background-color: var(--border); color: var(--text-primary);}
        .dd-chart-box { height: 150px; }
        .dd-chart-box canvas { height: 100%; }
        .monthly-table td, .monthly-table th { font-size: 0.75rem; text-align: center; }
        .monthly-table th:first-child { text-align: left; }
        .league-chart-box { height: 250px; }
    </style>
</head>
<body>

    <div id="loadingOverlay" style="display:none;"><i class="fas fa-hammer spinner"></i><h3 style="margin-top:20px; color:#ccc;">Ejecutando Modelo H√≠brido, Poisson y An√°lisis CLV...</h3></div>

    <header>
        <div class="brand"><i class="fas fa-hammer"></i> Value-Hacker <span class="tag">v10.1 Optimizada</span></div>
        <div style="display:flex; gap:10px; align-items:center;">
            <input type="file" id="fileInput" accept=".csv" multiple>
            <label for="fileInput" class="btn btn-secondary"><i class="fas fa-folder-open"></i> Cargar Archivos CSV (2)</label>
        </div>
    </header>

    <div class="container">
        <aside class="sidebar">
            
            <div class="control-group">
                <label>URL Temporada Actual</label>
                <input type="text" id="urlInputCurrent" placeholder="URL CSV">
            </div>
            <div class="control-group">
                <label>URL Temporada ANTERIOR (Opcional)</label>
                <input type="text" id="urlInputPrevious" placeholder="URL CSV">
            </div>
            <button onclick="loadFromUrls()" class="btn btn-primary" style="margin-bottom:10px; background:var(--stats-accent);"><i class="fas fa-cloud-download-alt"></i> Cargar URLs</button>

            <hr class="separator">

            <div class="tab-controls">
                <div id="tabConfigBtn" class="tab-button active" onclick="switchTab('config')"><i class="fas fa-sliders-h"></i> Configuraci√≥n</div>
                <div id="tabEstadisticasBtn" class="tab-button" onclick="switchTab('estadisticas')"><i class="fas fa-chart-line"></i> An√°lisis Avanzado</div>
            </div>

            <div id="tabConfig" class="tab-content active">
                <h3>üí∞ Gesti√≥n de Banca y Stake (Implacable)</h3>
                <div class="control-group">
                    <label>Mercado</label>
                    <select id="marketSelect">
                        <option value="H">Local (1)</option>
                        <option value="D">Empate (X)</option>
                        <option value="A">Visita (2)</option>
                        <option value="O25">Over 2.5 Goles</option>
                        <option value="U25">Under 2.5 Goles</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label style="color:var(--accent); font-weight:bold;">
                        <input type="checkbox" id="useFrequencyValue" style="width:auto; margin-right:5px; transform:scale(1.2);" checked> Usar Filtro de Valor Esperado (EV) > 0
                    </label>
                </div>

                <div class="control-group">
                    <label>Estrategia de Stake (Banca Inicial: <b id="bankLabel">1000</b>)</label>
                    <div style="display:flex; gap:5px;">
                        <select id="stakeType" style="width:60%;">
                            <option value="flat">Plano (Fijo)</option>
                            <option value="percent">% Banca</option>
                            <option value="kelly" selected>Criterio de Kelly</option>
                        </select>
                        <input type="number" id="stakeValue" value="33" step="1" style="width:40%;" placeholder="Factor/Porc.">
                    </div>
                    <label style="font-size:0.7rem; color:var(--warning); margin-top:5px;">*Kelly: StakeValue es el Denominador. El stake es **ponderado por EV**.</label>
                    <input type="number" id="initialBank" value="1000" style="margin-top:5px;" placeholder="Banca Inicial" onchange="document.getElementById('bankLabel').innerText=this.value;">
                </div>
                
                <hr class="separator">

                <h3>üõ°Ô∏è Filtros de Riesgo / Volatilidad</h3>
                <div class="control-group">
                    <label>Rango de Cuota</label>
                    <div style="display:flex; gap:5px;">
                        <input type="number" id="minOdds" value="1.50" step="0.01" min="1.01" style="width:50%;" placeholder="Min Odd">
                        <input type="number" id="maxOdds" value="4.00" step="0.01" min="1.01" style="width:50%;" placeholder="Max Odd">
                    </div>
                </div>
                
                <div class="control-group">
                    <label>M√≠nimo de Valor Esperado (EV%)</label>
                    <input type="number" id="minEV" value="0.01" step="0.01" min="0.01" placeholder="Ej: 0.01 (1%)">
                </div>

                <div class="control-group">
                    <label>Liga</label>
                    <select id="leagueSelect"><option value="all">Todas</option></select>
                </div>
            </div>

            <div id="tabEstadisticas" class="tab-content">
                <div class="matchup-selectors">
                    <h3 style="border:none; margin-bottom:5px; color:white; font-size:0.9rem;">Selecci√≥n de Partido (An√°lisis de Edge)</h3>
                    <div class="control-group">
                        <label>Equipo Local</label>
                        <select id="teamHomeSelect"><option value="">Sel. Local</option></select>
                    </div>
                    <div class="vs-badge">VS</div>
                    <div class="control-group">
                        <label>Equipo Visitante</label>
                        <select id="teamAwaySelect"><option value="">Sel. Visita</option></select>
                    </div>
                    <button class="btn" style="background:var(--accent); color:black; width:100%; justify-content:center; margin-top:5px;" onclick="analyzeMatchup()">
                        <i class="fas fa-chart-bar"></i> Calcular Edge & EV
                    </button>
                </div>

                <hr class="separator">

                <h3 style="border:none; margin-bottom:10px; color:white; font-size:0.9rem;">üìà Volatilidad Hist√≥rica por Liga (Actual)</h3>
                <div class="table-scroll" style="max-height: 250px;">
                    <table id="volatilityTable">
                        <thead><tr><th>Liga</th><th>Bets</th><th>Yield %</th><th>Volatilidad (VF)</th></tr></thead>
                        <tbody id="volatilityTableBody"></tbody>
                    </table>
                </div>

            </div>
            
            <button class="btn btn-run" onclick="runBacktest()"><i class="fas fa-play"></i> EJECUTAR BACKTEST</button>
            
        </aside>

        <main class="main">
            
            <div id="statsCard" class="stats-card"></div> 

            <div class="kpi-wrapper">
                <div class="kpi-grid">
                    <div class="kpi-card"><div class="kpi-title">Apuestas con EV > 0</div><div class="kpi-value" id="valBets">0</div></div>
                    <div class="kpi-card"><div class="kpi-title">Valor Esperado Promedio (EV)</div><div class="kpi-value" id="valAvgEV">0.00%</div></div>
                    <div class="kpi-card"><div class="kpi-title">Profit Neto</div><div class="kpi-value" id="valProfit">0.00</div></div>
                    <div class="kpi-card"><div class="kpi-title">Yield Total</div><div class="kpi-value" id="valYield">0%</div></div>
                    <div class="kpi-card"><div class="kpi-title">CLV Promedio (Edge Real)</div><div class="kpi-value" id="valCLV">0.00%</div></div> 
                    <div class="kpi-card"><div class="kpi-title">Drawdown M√°x.</div><div class="kpi-value text-red" id="valDrawdown">0%</div></div>
                    <div class="kpi-card"><div class="kpi-title">Riesgo Ruina (RoR)</div><div class="kpi-value text-blue" id="valRoR">0%</div></div>
                </div>
            </div>
            
            <div class="split-row">
                <div class="panel-box" style="width: 70%;">
                    <div class="chart-box-full">
                        <canvas id="equityChart"></canvas>
                    </div>
                </div>
                <div class="panel-box" style="width: 30%;">
                    <div class="panel-header"><span class="panel-title"><i class="fas fa-chart-area"></i> Drawdown de Banca</span></div>
                    <div class="dd-chart-box">
                        <canvas id="drawdownChart"></canvas>
                    </div>
                </div>
            </div>


            <div class="opt-card" style="padding:10px; border: 1px solid var(--accent); background: #2f496e;">
                <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:5px; margin-bottom:5px;">
                    <div class="kpi-title" style="color:white; font-size:0.85rem;">üéØ RENDIMIENTO EN EL RANGO √ìPTIMO (<span id="rangeDisplay">N/A</span>)</div>
                    <span id="compStatus" style="font-size:0.75rem; font-weight:bold; padding:2px 6px; border-radius:4px; background:var(--warning);">N/A</span>
                </div>

                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; text-align:center;">
                    <div>
                        <div class="kpi-title">YIELD TOTAL</div>
                        <div class="kpi-value text-green" id="valOptimalOddsYield" style="font-size:1.2rem;">0.00%</div>
                        <div class="kpi-title" style="margin-top:3px;">Bets: <b id="valOptimalOddsBets">0</b></div>
                    </div>

                    <div style="border-left:1px dashed #334155; padding-left:10px;">
                        <div class="kpi-title"><i class="fas fa-calendar-check"></i> <span id="currentYear">Actual</span></div>
                        <div class="kpi-value text-orange" id="currentYield" style="font-size:1.2rem;">N/A</div>
                        <div class="kpi-title" id="currentSample" style="font-size:0.7rem; margin-top:3px;">(Muestra: 0)</div>
                    </div>

                    <div style="border-left:1px dashed #334155; padding-left:10px;">
                        <div class="kpi-title"><i class="fas fa-calendar-alt"></i> <span id="previousYear">Anterior</span></div>
                        <div class="kpi-value text-orange" id="previousYield" style="font-size:1.2rem;">N/A</div>
                        <div class="kpi-title" id="previousSample" style="font-size:0.7rem; margin-top:3px;">(Muestra: 0)</div>
                    </div>
                </div>
            </div>


            <div class="split-row">
                <div class="panel-box">
                    <div class="panel-header"><span class="panel-title"><i class="fas fa-calendar-day"></i> Rendimiento por Periodo (Mensual/Anual)</span></div>
                    <div class="table-scroll" style="max-height: 250px;">
                        <table class="monthly-table">
                            <thead>
                                <tr>
                                    <th>Periodo</th>
                                    <th>Bets</th>
                                    <th>Profit</th>
                                    <th>Yield %</th>
                                </tr>
                            </thead>
                            <tbody id="monthlyTableBody">
                                </tbody>
                        </table>
                    </div>
                </div>
                <div class="panel-box">
                    <div class="panel-header"><span class="panel-title"><i class="fas fa-chart-line"></i> Profit por Liga (Top 10)</span></div>
                    <div class="league-chart-box">
                        <canvas id="leagueChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="panel-box" style="width:100%;">
                <div class="panel-header"><span class="panel-title"><i class="fas fa-users"></i> Ranking Equipos (Profit)</span></div>
                <div class="table-scroll">
                    <table id="teamTable">
                        <thead>
                            <tr>
                                <th>Equipo</th>
                                <th><i class="fas fa-globe-americas"></i> Overall</th>
                                <th><i class="fas fa-home"></i> Home</th>
                                <th><i class="fas fa-plane-departure"></i> Away</th>
                            </tr>
                        </thead>
                        <tbody id="teamTableBody"></tbody>
                    </table>
                </div>
            </div>

        </main>
    </div>

    <script>
        // *** COMIENZO DE LA L√ìGICA JAVASCRIPT - VALUE HACKER v10.1 (Optimizado) ***
        let rawData = [];
        let seasonYears = { current: null, previous: null };
        let currentSeasonData = []; 
        let currentStats = null; 
        let chartEq=null, chartLg=null, chartDD=null; 
        const RoR_BANK_FRACTION = 0.5; 
        let globalWinRate = 0; 
        let totalStakeUnits = 0; 
        let lgAnalysisCache = {}; 

        // --- Tabs Logic (Mismo que v9.1) ---
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));

            document.getElementById('tab' + tabId.charAt(0).toUpperCase() + tabId.slice(1)).classList.add('active');
            const btnId = tabId === 'estadisticas' ? 'tabEstadisticasBtn' : 'tabConfigBtn';
            document.getElementById(btnId).classList.add('active');
            
            if (tabId !== 'estadisticas') {
                document.getElementById('statsCard').style.display = 'none';
            }
        }

        // --- FUNCIONES MATEM√ÅTICAS ---
        
        function calculateKellyStake(p, o, denominator) {
            const b = o - 1;
            const q = 1 - p;
            let f = ((b * p) - q) / b;
            f = f / denominator;
            return Math.max(0.005, f);
        }

        // Correcci√≥n de RoR: Utiliza el tama√±o promedio de apuesta como unidad.
        function calculateRiskOfRuina(totalBets, totalStake, globalWinRate, avgOdds) {
            if (totalBets === 0 || totalStake === 0) return 100;
            
            const W = globalWinRate;
            const L = 1 - W;
            const breakEven = 1 / (avgOdds || 2.0);
            if (W <= breakEven) return 100; 

            const bankUnits = parseFloat(document.getElementById('initialBank').value);
            const avgStake = totalStake / totalBets; 
            
            // Asumiendo que la unidad de riesgo es la apuesta promedio.
            const B_units = bankUnits / (avgStake || 1); 
            const RoR_Estimate = Math.pow((L / W), B_units * RoR_BANK_FRACTION); // RoR_BANK_FRACTION (0.5) usado para mitigar RoR si se asume Kelly.

            return Math.min(100, RoR_Estimate * 100);
        }
        
        function calculateStandardDeviation(values, mean) {
            const squaredDifferences = values.map(value => Math.pow(value - mean, 2));
            const avgSquaredDifference = squaredDifferences.reduce((sum, val) => sum + val, 0) / values.length;
            return Math.sqrt(avgSquaredDifference);
        }

        // --- Implementaci√≥n de Poisson para Goles ---
        function factorial(n) {
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function poisson(lambda, k) {
            // P(k) = (e^-lambda * lambda^k) / k!
            if (lambda < 0 || k < 0) return 0;
            return (Math.exp(-lambda) * Math.pow(lambda, k)) / factorial(k);
        }

        // --- CARGA Y PROCESAMIENTO DE DATOS ---
        document.getElementById('fileInput').addEventListener('change', loadFromLocalFiles);
        
        function loadFromLocalFiles(e) {
            const files = e.target.files;
            
            if (files.length === 0) return;
            if (files.length !== 2) {
                alert("Por favor, selecciona EXACTAMENTE dos archivos CSV: uno para la temporada actual y uno para la temporada anterior.");
                document.getElementById('fileInput').value = ''; 
                return;
            }

            document.getElementById('loadingOverlay').style.display = 'flex';

            let combinedData = [];
            const parseFile = (file) => {
                return new Promise((resolve, reject) => {
                    Papa.parse(file, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true,
                        complete: (results) => {
                            const validData = results.data.filter(r => Object.keys(r).length > 0 && r.HomeTeam);
                            if (validData.length === 0 && file.size > 0) {
                                reject(`El archivo ${file.name} no contiene datos utilizables.`);
                            } else {
                                resolve(validData);
                            }
                        },
                        error: (error, file) => {
                            reject(`Error de parsing en el archivo ${file.name}. Mensaje: ${error.message}`);
                        }
                    });
                });
            };

            Promise.all(Array.from(files).map(parseFile))
                .then(dataArrays => {
                    dataArrays.forEach(data => combinedData.push(...data));
                    if (combinedData.length === 0) {
                        throw new Error("No se encontraron datos utilizables en los archivos combinados. Verifique el formato CSV.");
                    }
                    processData(combinedData);
                })
                .catch(error => {
                    console.error("Error al cargar archivos locales:", error);
                    alert(`‚ùå Error cargando archivos locales:\n\n${error}`);
                    document.getElementById('loadingOverlay').style.display = 'none';
                    document.getElementById('fileInput').value = ''; 
                });
        }
        
        async function loadFromUrls() {
            const urlCurrent = document.getElementById('urlInputCurrent').value.trim();
            const urlPrevious = document.getElementById('urlInputPrevious').value.trim();
            
            if (!urlCurrent) return alert("La URL de la Temporada Actual es obligatoria.");

            document.getElementById('loadingOverlay').style.display = 'flex';

            const corsProxy = 'https://api.allorigins.win/raw?url=';
            const urls = [urlCurrent];
            if (urlPrevious) urls.push(urlPrevious);

            try {
                const fetchPromises = urls.map(url => 
                    fetch(corsProxy + encodeURIComponent(url))
                        .then(res => {
                            if (!res.ok) throw new Error(`Fallo al obtener datos de ${url}. Estado: ${res.status}`);
                            return res.text();
                        })
                );
                
                const texts = await Promise.all(fetchPromises);
                
                let combinedData = [];
                let parsingErrors = []; 

                texts.forEach((text, index) => {
                    const url = urls[index];
                    Papa.parse(text, { 
                        header: true, 
                        dynamicTyping: true, 
                        skipEmptyLines: true, 
                        complete: (results) => {
                            const validData = results.data.filter(r => Object.keys(r).length > 0 && r.HomeTeam); 
                            if (validData.length === 0 && text.length > 0) parsingErrors.push(`La URL ${url} no devolvi√≥ datos utilizables o el formato es incorrecto.`);
                            combinedData.push(...validData); 
                        },
                        error: (error, file) => {
                            console.error(`Error de PapaParse en la URL ${url}. Mensaje: ${error.message}`);
                            parsingErrors.push(`Error de parsing en la URL ${url}. Mensaje: ${error.message}`);
                        }
                    });
                });
                
                if (parsingErrors.length > 0) throw new Error(parsingErrors.join('\n'));
                if (combinedData.length === 0) throw new Error("No se encontraron datos utilizables. Aseg√∫rese de que las URLs sean enlaces directos a CSVs y no est√©n vac√≠os.");

                processData(combinedData);

            } catch(e){ 
                console.error("Error general en carga:", e);
                alert(`‚ùå Error cargando datos:\n\n${e.message || "Verifique si las URLs son enlaces directos a CSVs accesibles o si el archivo no est√° vac√≠o."}`); 
                document.getElementById('loadingOverlay').style.display='none'; 
            }
        }
        
        function calculateCurrentSeasonStats(data) {
            const teamStats = {};
            let totalMatches = 0;
            let totalHomeGoals = 0;
            let totalAwayGoals = 0;
            
            data.forEach(r => {
                if(r.goalsH >= 0 && r.goalsA >= 0) {
                    totalMatches++;
                    totalHomeGoals += r.goalsH;
                    totalAwayGoals += r.goalsA;

                    const updateStats = (team, goalsScored, goalsConceded, isHome) => {
                        if (!teamStats[team]) {
                            teamStats[team] = { playedH: 0, scoredH: 0, concededH: 0, playedA: 0, scoredA: 0, concededA: 0, gd: 0 };
                        }
                        const goalsDifference = goalsScored - goalsConceded;
                        teamStats[team].gd += goalsDifference;
                        
                        if (isHome) {
                            teamStats[team].playedH++;
                            teamStats[team].scoredH += goalsScored;
                            teamStats[team].concededH += goalsConceded;
                        } else {
                            teamStats[team].playedA++;
                            teamStats[team].scoredA += goalsScored;
                            teamStats[team].concededA += goalsConceded;
                        }
                    };

                    updateStats(r.home, r.goalsH, r.goalsA, true);
                    updateStats(r.away, r.goalsA, r.goalsH, false);
                }
            });
            
            if (totalMatches === 0) return null;

            const avgGoalsHome = totalHomeGoals / totalMatches;
            const avgGoalsAway = totalAwayGoals / totalMatches;
            const avgTotalGoals = (totalHomeGoals + totalAwayGoals) / totalMatches; 

            const teamCoeffs = {};
            for (const team in teamStats) {
                const stats = teamStats[team];
                
                // Ataque y Defensa por Frecuencia Home (Usados en Poisson)
                const attH_factor = (stats.playedH > 0 && avgGoalsHome > 0) ? (stats.scoredH / stats.playedH) / avgGoalsHome : 1.0; 
                const defH_factor = (stats.playedH > 0 && avgGoalsAway > 0) ? (stats.concededH / stats.playedH) / avgGoalsAway : 1.0; 
                
                // Ataque y Defensa por Frecuencia Away (Usados en Poisson)
                const attA_factor = (stats.playedA > 0 && avgGoalsAway > 0) ? (stats.scoredA / stats.playedA) / avgGoalsAway : 1.0; 
                const defA_factor = (stats.playedA > 0 && avgGoalsHome > 0) ? (stats.concededA / stats.playedA) / avgGoalsHome : 1.0; 

                // Factor de Potencia (GD Ponderado) para el 1X2
                const gdPower = stats.gd / (stats.playedH + stats.playedA); 
                const powerFactor = 1 + (gdPower * 0.05); // Simple linear weighting

                teamCoeffs[team] = { 
                    attH_factor, defH_factor, attA_factor, defA_factor,
                    playedH: stats.playedH, 
                    playedA: stats.playedA,
                    powerFactor: powerFactor
                };
            }

            return {
                globalAverages: { avgGoalsHome, avgGoalsAway, avgTotalGoals, totalMatches }, 
                teamCoeffs: teamCoeffs
            };
        }


        function processData(data) {
            rawData = data.map(r => {
                if(!r.Date || !r.HomeTeam || isNaN(r.FTHG) || isNaN(r.FTAG)) return null;
                
                let d = r.Date; 
                if(typeof d === 'string' && d.includes('/')) { 
                    const p = d.split('/');
                    if (p.length === 3) {
                        let year = p[2];
                        if (year.length === 2) {
                            const currentYear = new Date().getFullYear();
                            const century = (currentYear - (currentYear % 100)); 
                            year = (parseInt(year) < 70) ? (century + parseInt(year)).toString() : (century - 100 + parseInt(year)).toString();
                        }
                        d = `${year}-${p[1].padStart(2,'0')}-${p[0].padStart(2,'0')}`; 
                    }
                } 
                
                const getOdds = (key, fallbackKey) => {
                    let val = r[key] || r[fallbackKey];
                    return (typeof val === 'number' && val > 1.01) ? val : 1.01;
                };

                const getClOdds = (clKey, openKey) => {
                    let val = r[clKey];
                    // Fallback a Cuota de Apertura si Cuota de Cierre no existe o es inv√°lida
                    return (typeof val === 'number' && val > 1.01) ? val : r[openKey] || 1.01; 
                };

                return {
                    date:d, league:r.Div, home:r.HomeTeam, away:r.AwayTeam, res:r.FTR, goalsH:r.FTHG, goalsA:r.FTAG,
                    // Cuotas de Apuesta
                    oddsH:getOdds('B365H', 'AvgH'), oddsD:getOdds('B365D', 'AvgD'), oddsA:getOdds('B365A', 'AvgA'),
                    oddsO25:getOdds('B365>2.5', 'Avg25'), oddsU25:getOdds('B365<2.5', 'Avg25_1'),
                    // Cuotas de Cierre (Usando Avg como fallback para CL)
                    clH:getClOdds('CLH', 'B365H'), clD:getClOdds('CLD', 'B365D'), clA:getClOdds('CLA', 'B365A'),
                    clO25:getClOdds('CL>2.5', 'B365>2.5'), clU25:getClOdds('CL<2.5', 'B365<2.5'), 
                    totalGoals: r.FTHG + r.FTAG
                };
            }).filter(x=>x && x.oddsH > 1.01); 

            rawData.sort((a, b) => a.date.localeCompare(b.date));
            
            const allDates = rawData.map(r => r.date.substring(0, 4));
            const uniqueYears = [...new Set(allDates)].sort().reverse(); 
            
            seasonYears.current = uniqueYears.length > 0 ? uniqueYears[0] : null;
            seasonYears.previous = uniqueYears.length > 1 ? uniqueYears[1] : null;
            
            currentSeasonData = rawData.filter(r => seasonYears.current && r.date.startsWith(seasonYears.current));
            currentStats = calculateCurrentSeasonStats(currentSeasonData);
            
            if(currentStats) {
                const teams = Object.keys(currentStats.teamCoeffs).sort();
                const populate = (id) => {
                    const s = document.getElementById(id); s.innerHTML='<option value="">Seleccionar</option>';
                    teams.forEach(t => s.add(new Option(t,t)));
                };
                populate('teamHomeSelect'); populate('teamAwaySelect');
            }
            
            const lgSel = document.getElementById('leagueSelect'); lgSel.innerHTML='<option value="all">Todas</option>';
            [...new Set(rawData.map(x=>x.league))].sort().forEach(l=>lgSel.add(new Option(l,l)));

            document.getElementById('bankLabel').innerText = parseFloat(document.getElementById('initialBank').value).toFixed(0);

            document.getElementById('loadingOverlay').style.display='none';
            runBacktest(); 
        }

        // --- L√ìGICA CORE ---
        function getMarketOdds(row, mkt) {
            if(mkt==='H') return row.oddsH;
            if(mkt==='D') return row.oddsD;
            if(mkt==='A') return row.oddsA;
            if(mkt==='O25') return row.oddsO25;
            if(mkt==='U25') return row.oddsU25;
            return 0; 
        }
        
        function getClosingOdds(row, mkt) {
            if(mkt==='H') return row.clH;
            if(mkt==='D') return row.clD;
            if(mkt==='A') return row.clA;
            if(mkt==='O25') return row.clO25;
            if(mkt==='U25') return row.clU25;
            return getMarketOdds(row, mkt); 
        }

        function isWinningBet(row, mkt) {
            if(mkt==='H') return row.res==='H';
            if(mkt==='D') return row.res==='D';
            if(mkt==='A') return row.res==='A';
            if(mkt==='O25') return (row.goalsH+row.goalsA)>2; 
            if(mkt==='U25') return (row.goalsH+row.goalsA)<3; 
            return false;
        }

        // --- MODELO AVANZADO: C√°lculo de Probabilidades H√≠bridas (Ajuste para O/U con Poisson) ---
        function calculateHybridProbabilities(homeTeam, awayTeam, stats) {
            if (!stats) return null;
            const { globalAverages, teamCoeffs } = stats;
            const homeCoeffs = teamCoeffs[homeTeam];
            const awayCoeffs = teamCoeffs[awayTeam];
            
            if (!homeCoeffs || !awayCoeffs) return null;

            // --- 1. C√°lculo de Lambdas (Tasas de Goles Esperadas - Poisson) ---
            const lambdaH = homeCoeffs.attH_factor * awayCoeffs.defA_factor * globalAverages.avgGoalsHome;
            const lambdaA = awayCoeffs.attA_factor * homeCoeffs.defH_factor * globalAverages.avgGoalsAway;

            // --- 2. C√°lculo de Probabilidades 1X2 (GD Ponderado, no Poisson directo) ---
            
            // Frecuencias base (estimadas del Poisson para Normalizaci√≥n)
            let pHomeRaw = 0, pDrawRaw = 0, pAwayRaw = 0;
            // Sumamos las probabilidades de los 4 primeros resultados para 1X2 (0-0 a 3-3)
            for (let h = 0; h <= 3; h++) {
                for (let a = 0; a <= 3; a++) {
                    const p = poisson(lambdaH, h) * poisson(lambdaA, a);
                    if (h > a) pHomeRaw += p;
                    else if (h < a) pAwayRaw += p;
                    else pDrawRaw += p;
                }
            }
            // Normalizamos para obtener una base s√≥lida
            const sumRaw = pHomeRaw + pDrawRaw + pAwayRaw;
            let pHome = pHomeRaw / sumRaw;
            let pDraw = pDrawRaw / sumRaw;
            let pAway = pAwayRaw / sumRaw;
            
            // Re-aplicar el Factor de Potencia (GD) para ajustar ligeramente por la fuerza hist√≥rica
            const powerH = homeCoeffs.powerFactor;
            const powerA = awayCoeffs.powerFactor;
            
            pHome = pHome * powerH / powerA;
            pAway = pAway * powerA / powerH;
            
            // Normalizaci√≥n final 1X2
            const sum1X2 = pHome + pDraw + pAway;
            pHome /= sum1X2;
            pDraw /= sum1X2;
            pAway /= sum1X2;
            
            // --- 3. C√°lculo de Probabilidades O/U 2.5 (Poisson Puro) ---
            let pUnder25 = 0;
            // Suma de P(0-0) a P(2-0), P(0-2), P(1-1), P(2-1), P(1-2)
            for (let h = 0; h <= 2; h++) {
                for (let a = 0; a <= 2; a++) {
                    if (h + a < 3) {
                        pUnder25 += poisson(lambdaH, h) * poisson(lambdaA, a);
                    }
                }
            }
            const pOver25 = 1 - pUnder25;
            
            return {
                pHome, pDraw, pAway, pOver25, pUnder25,
                lambdaH, lambdaA,
                pTotal: pHome + pDraw + pAway 
            };
        }
        
        // --- FUNCI√ìN DE C√ÅLCULO DE PROFIT Y STAKE MEJORADA (Con Ponderaci√≥n EV/Volatilidad) ---
        function calculateProfit(row, mkt, stakeType, stakeValue, bank, minOdds, maxOdds, minEV, useValueFilter, lgAnalysis) {
            let o = getMarketOdds(row, mkt);
            if(!o || o<1.01) return null; 

            // --- 1. Filtro de Cuota Plana ---
            if (o < minOdds || o > maxOdds) return null; 

            let pModel = 0;
            let edge = 0;
            let EV_percent = 0;
            let isValueBet = false;
            let clOdds = getClosingOdds(row, mkt);
            let clv_percent = 0;
            
            const isKelly = (stakeType === 'kelly');
            const requiresModel = useValueFilter || isKelly || clOdds > 1.01;


            if (requiresModel) {
                const hybridRes = calculateHybridProbabilities(row.home, row.away, currentStats); 
                if (!hybridRes) return null; 

                if(mkt==='H') pModel = hybridRes.pHome;
                else if(mkt==='D') pModel = hybridRes.pDraw;
                else if(mkt==='A') pModel = hybridRes.pAway;
                else if(mkt==='O25') pModel = hybridRes.pOver25;
                else if(mkt==='U25') pModel = hybridRes.pUnder25;
                
                if (pModel <= 0) return null; 

                // C√°lculo de Edge y Valor Esperado (EV)
                edge = (pModel * o) - 1; 
                EV_percent = edge * 100;
                
                isValueBet = edge > minEV;

                // C√°lculo de CLV (Closing Line Value) - CORRECCI√ìN
                if (clOdds > 1.01) {
                    clv_percent = ((o / clOdds) - 1) * 100; // Si o > clOdds, CLV es positivo
                }

                // Filtro de Valor EV
                if (useValueFilter && !isValueBet) return null;
            }

            // --- L√≥gica de Stake (Ponderada por EV y Volatilidad) ---
            let actualStake;
            const kellyDenominator = (stakeType === 'kelly') ? stakeValue : 1; 

            if (stakeType === 'flat') {
                actualStake = stakeValue;
            } else if (stakeType === 'percent') {
                // Stake Porcentaje de la banca (stakeValue es el %)
                actualStake = bank * (stakeValue / 100);
            } else if (isKelly && isValueBet) {
                let kellyFraction = calculateKellyStake(pModel, o, kellyDenominator);
                
                // PONDERACI√ìN 1: Multiplicar la Fracci√≥n de Kelly por el EV Positivo
                // Factor de aumento: Si EV=5%, el multiplicador es 1.05
                if (EV_percent > 0) {
                    const evMultiplier = 1.0 + (EV_percent / 100); 
                    kellyFraction *= evMultiplier;
                }

                // PONDERACI√ìN 2: Ajuste por Volatilidad (VF)
                if (lgAnalysis[row.league] && parseFloat(lgAnalysis[row.league].vf) > 10) {
                    // Reducir el stake en un 10% si la volatilidad es alta (VF > 10)
                    kellyFraction *= 0.90; 
                }

                actualStake = bank * kellyFraction;
            } else {
                return null; 
            }
            
            // L√≠mite de Stake M√°ximo (10% de la banca) para control de riesgo
            actualStake = Math.min(actualStake, bank * 0.10); 
            actualStake = Math.max(actualStake, 0); 
            if (actualStake < 0.01) return null;
            
            // --- Cierre de Apuesta ---
            let w = isWinningBet(row, mkt);
            return { 
                pnl: w ? (actualStake * o - actualStake) : -actualStake, 
                won: w, 
                odds: o, 
                clOdds: clOdds,
                clv: clv_percent,
                stake: actualStake,
                EV: EV_percent,
                pModel: pModel
            };
        }
        
        // --- AN√ÅLISIS DE PARTIDO AVANZADO (Mismo que v10.0) ---
        function analyzeMatchup() {
            const homeTeam = document.getElementById('teamHomeSelect').value;
            const awayTeam = document.getElementById('teamAwaySelect').value;
            const mkt = document.getElementById('marketSelect').value;
            
            if (!homeTeam || !awayTeam || homeTeam === awayTeam) {
                document.getElementById('statsCard').style.display = 'none';
                return;
            }

            const hybridRes = calculateHybridProbabilities(homeTeam, awayTeam, currentStats);
            
            if (!hybridRes) {
                document.getElementById('statsCard').style.display = 'block';
                document.getElementById('statsCard').innerHTML = `<h3 style="color:var(--danger); margin:0;">No hay suficientes datos hist√≥ricos de la temporada actual para el an√°lisis h√≠brido.</h3>`;
                return;
            }

            const lastMatch = currentSeasonData.find(r => r.home === homeTeam && r.away === awayTeam); 
            
            updateStatsCard(homeTeam, awayTeam, hybridRes, lastMatch, mkt);
        }

        function updateStatsCard(home, away, res, lastMatch, selectedMkt) {
            const card = document.getElementById('statsCard');
            card.style.display = 'block';

            const homeCoeffs = currentStats.teamCoeffs[home];
            const awayCoeffs = currentStats.teamCoeffs[away];
            
            const teamPowerData = {
                home_power: homeCoeffs.powerFactor.toFixed(3), 
                away_power: awayCoeffs.powerFactor.toFixed(3), 
            };

            const markets = {
                'H': { p: res.pHome, odds: lastMatch ? lastMatch.oddsH : null, clOdds: lastMatch ? lastMatch.clH : null, label: 'Local (1)' },
                'D': { p: res.pDraw, odds: lastMatch ? lastMatch.oddsD : null, clOdds: lastMatch ? lastMatch.clD : null, label: 'Empate (X)' },
                'A': { p: res.pAway, odds: lastMatch ? lastMatch.oddsA : null, clOdds: lastMatch ? lastMatch.clA : null, label: 'Visita (2)' },
                'O25': { p: res.pOver25, odds: lastMatch ? lastMatch.oddsO25 : null, clOdds: lastMatch ? lastMatch.clO25 : null, label: 'O2.5 (Poisson)' },
                'U25': { p: res.pUnder25, odds: lastMatch ? lastMatch.oddsU25 : null, clOdds: lastMatch ? lastMatch.clU25 : null, label: 'U2.5 (Poisson)' }
            };

            let marketHTML = '';
            for (const key in markets) {
                const mkt = markets[key];
                const oddsModel = (mkt.p > 0 ? (1 / mkt.p) : 0);
                const oddsReal = mkt.odds;
                const oddsCL = mkt.clOdds;
                
                const edge = (mkt.p * oddsReal) - 1;
                const edgePercent = edge * 100;
                
                let clvIndicator = '';
                if(oddsReal && oddsCL && oddsCL > 1.01) {
                    const clv = ((oddsReal / oddsCL) - 1) * 100;
                    clvIndicator = `<span class="${clv>=0?'text-green':'text-red'}" style="font-size:0.9rem; font-weight:bold;">CLV: ${clv.toFixed(1)}%</span>`;
                }


                let edgeIndicator = '';
                if (edgePercent > 0.01) {
                    edgeIndicator = `<span class="text-green" style="font-size:0.9rem;">(+${edgePercent.toFixed(2)}% EV)</span>`;
                } else if (edgePercent < -0.01) {
                    edgeIndicator = `<span class="text-red" style="font-size:0.9rem;">(${edgePercent.toFixed(2)}% EV)</span>`;
                }

                const style = key === selectedMkt ? 'border: 2px solid var(--accent);' : '';
                
                marketHTML += `
                    <div class="stats-odds-item" style="${style}">
                        <div class="kpi-title" style="color:white; font-weight:bold;">${mkt.label}</div>
                        <div class="kpi-value" style="font-size:1.1rem; color:var(--stats-accent);">P. H√≠brida: ${(mkt.p * 100).toFixed(1)}%</div>
                        <div class="kpi-title" style="margin-top:3px; font-weight:bold;">Odds Impl√≠cita: ${oddsModel > 0 ? oddsModel.toFixed(2) : 'N/A'}</div>
                        <div class="kpi-title">Odds Tomada: ${oddsReal ? oddsReal.toFixed(2) : 'N/A'} ${edgeIndicator}</div>
                        <div class="kpi-title">Odds Cierre: ${oddsCL ? oddsCL.toFixed(2) : 'N/A'} ${clvIndicator}</div>
                    </div>
                `;
            }

            let matrixHTML = `
                <div class="score-matrix">
                    <h4 style="margin:0 0 5px 0; color:white; font-size:0.85rem;">M√©tricas Avanzadas (Temp. Actual)</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>M√©trica</th>
                                <th>${home}</th>
                                <th>${away}</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="text-align:left; font-weight:bold; color:var(--accent);">Factor de Potencia (GD)</td>
                                <td>${teamPowerData.home_power}</td>
                                <td>${teamPowerData.away_power}</td>
                            </tr>
                            <tr>
                                <td style="text-align:left; font-weight:bold; color:var(--stats-accent);">$\lambda$ Esperada (Poisson)</td>
                                <td>${res.lambdaH.toFixed(2)}</td>
                                <td>${res.lambdaA.toFixed(2)}</td>
                            </tr>
                        </tbody>
                    </table>
                    <p style="font-size:0.75rem; color:var(--text-secondary); margin-top:10px;">*Probabilidad H√≠brida: 1X2 ajustado por GD Power. O/U calculado por Poisson.</p>
                </div>
            `;


            card.innerHTML = `
                <h3 style="margin-top:0; color:white; border-bottom:1px solid var(--accent); padding-bottom:5px; font-size:0.9rem; text-transform:none;">üéØ An√°lisis de Valor: ${home} vs ${away}</h3>
                
                <div style="display:flex; justify-content:space-around; text-align:center; padding:5px 0; border-bottom:1px solid var(--stats-dark);">
                    <div style="font-size:0.75rem;">
                        <span class="text-secondary" style="font-weight:600;"><i class="fas fa-home"></i> Muestra ${home}:</span> <b>${homeCoeffs.playedH} Loc.</b>
                    </div>
                    <div style="font-size:0.75rem;">
                        <span class="text-secondary" style="font-weight:600;"><i class="fas fa-plane-departure"></i> Muestra ${away}:</span> <b>${awayCoeffs.playedA} Vis.</b>
                    </div>
                </div>

                <div class="stats-grid-wrapper">
                    <div class="stats-odds-grid">
                        ${marketHTML}
                    </div>
                    ${matrixHTML}
                </div>
            `;
        }


        // --- FUNCI√ìN PRINCIPAL DE BACKTESTING ---
        function runBacktest() {
            if(!rawData.length || !currentStats) {
                document.getElementById('statsCard').style.display = 'block';
                document.getElementById('statsCard').innerHTML = `<h3 style="color:var(--danger); margin:0;">Cargue datos primero (URL o Archivos) para iniciar el backtest.</h3>`;
                return;
            }
            
            const mkt = document.getElementById('marketSelect').value;
            const useValueFilter = document.getElementById('useFrequencyValue').checked; 
            const stT = document.getElementById('stakeType').value;
            const stV = parseFloat(document.getElementById('stakeValue').value);
            const bank0 = parseFloat(document.getElementById('initialBank').value);
            const minO = parseFloat(document.getElementById('minOdds').value);
            const maxO = parseFloat(document.getElementById('maxOdds').value);
            const minEV = parseFloat(document.getElementById('minEV').value);
            const lg = document.getElementById('leagueSelect').value;

            let bank=bank0, peak=bank0, maxDD=0, wins=0, hist=[{x:'Inicio', y:bank0}], drawdownHist=[{x:'Inicio', y:0}], rows=[], lgP={};
            let tmPRanking = {}; 
            let optimizableBetsCombined = [];
            let totalProfitUnits = 0;
            totalStakeUnits = 0; 
            let totalBets = 0;
            let totalEV = 0;
            let oddsSum = 0;
            let totalCLV = 0; 
            let clvBetCount = 0; 
            let monthlyResults = {}; 
            
            // Recalcular an√°lisis de volatilidad SOLO con datos de la temporada actual
            const currentSeasonOptimizable = currentSeasonData.map(r => {
                 // Usar Stake Plano 1.0 y EV > 0 para definir apuestas optimizables (para c√°lculo de VF)
                const resOpt = calculateProfit(r, mkt, 'flat', 1.0, 10000, 1.0, 50.0, 0.001, true, {}); 
                if (resOpt) return { odds: resOpt.odds, pnl: resOpt.pnl, year: r.date.substring(0, 4), league: r.league, EV: resOpt.EV };
                return null;
            }).filter(Boolean);
            
            lgAnalysisCache = analyzeLeagueVolatility(currentSeasonOptimizable); // USAR SOLO DATOS ACTUALES

            const filtered = rawData.filter(r => lg==='all' || r.league===lg);

            filtered.forEach(r => {
                const res = calculateProfit(r, mkt, stT, stV, bank, minO, maxO, minEV, useValueFilter, lgAnalysisCache);
                
                // Generaci√≥n de lista de apuestas optimizables (para el rango √≥ptimo) - usa datos completos para rango
                const resOptimizable = calculateProfit(r, mkt, 'flat', 1.0, 10000, 1.0, 50.0, 0.001, true, {}); 
                if(resOptimizable) {
                    const optBet = { 
                        odds: resOptimizable.odds, 
                        pnl: resOptimizable.pnl, 
                        year: r.date.substring(0, 4), 
                        league: r.league,
                        EV: resOptimizable.EV
                    };
                    optimizableBetsCombined.push(optBet);
                }

                if(res) {
                    bank += res.pnl;
                    totalProfitUnits += res.pnl;
                    totalStakeUnits += res.stake;
                    totalBets++;
                    totalEV += res.EV;
                    oddsSum += res.odds;
                    
                    if(res.clv !== 0) {
                        totalCLV += res.clv;
                        clvBetCount++;
                    }
                    
                    if(res.won) wins++;
                    
                    // C√°lculo de Drawdown
                    if(bank>peak) peak=bank;
                    let dd = (peak-bank)/peak*100; if(dd>maxDD) maxDD=dd;

                    hist.push({x:r.date, y:bank});
                    drawdownHist.push({x:r.date, y:dd});
                    rows.push({date:r.date, match:`${r.home} v ${r.away}`, sel:mkt, odds:res.odds, stake:res.stake, res:`${r.goalsH}-${r.goalsA}`, pnl:res.pnl, bank:bank, EV:res.EV});

                    // Acumulaci√≥n de Profit/Loss por Liga
                    if(!lgP[r.league]) lgP[r.league]=0; lgP[r.league]+=res.pnl;
                    
                    // Acumulaci√≥n de Profit/Loss Mensual
                    const monthYear = r.date.substring(0, 7);
                    if (!monthlyResults[monthYear]) monthlyResults[monthYear] = { pnl: 0, stake: 0, bets: 0 };
                    monthlyResults[monthYear].pnl += res.pnl;
                    monthlyResults[monthYear].stake += res.stake;
                    monthlyResults[monthYear].bets++;


                    // Acumulaci√≥n de Profit/Loss por Equipo (Ranking Mejorado)
                    const updateTeamRanking = (team, pnl, type) => {
                        if (!tmPRanking[team]) {
                            tmPRanking[team] = { overall: 0, home: 0, away: 0 };
                        }
                        tmPRanking[team].overall += pnl;
                        if (type === 'home') {
                            tmPRanking[team].home += pnl;
                        } else if (type === 'away') {
                            tmPRanking[team].away += pnl;
                        }
                    };

                    updateTeamRanking(r.home, res.pnl, 'home'); 
                    updateTeamRanking(r.away, res.pnl, 'away'); 
                }
            });

            globalWinRate = totalBets > 0 ? wins / totalBets : 0;
            const avgOdds = totalBets > 0 ? oddsSum / totalBets : 0;
            const avgEV = totalBets > 0 ? totalEV / totalBets : 0;
            const avgCLV = clvBetCount > 0 ? totalCLV / clvBetCount : 0; 

            // --- AN√ÅLISIS DE RANGO √ìPTIMO ---
            const currentData = optimizableBetsCombined.filter(b => seasonYears.current && b.year == seasonYears.current);
            const previousData = optimizableBetsCombined.filter(b => seasonYears.previous && b.year == seasonYears.previous);
            const optimalRangeCombined = findOptimalOddsRange(optimizableBetsCombined);
            const compatibility = checkCompatibility(optimalRangeCombined, currentData, previousData); 
            
            updateOptimalOddsUI(optimalRangeCombined, compatibility); 
            
            const RoR = calculateRiskOfRuina(totalBets, totalStakeUnits, globalWinRate, avgOdds);

            updateGlobalUI(hist, drawdownHist, rows, wins, bank0, bank, maxDD, lgP, tmPRanking, totalStakeUnits, RoR, avgEV, avgCLV, monthlyResults, lgAnalysisCache);
            
            document.getElementById('statsCard').style.display = 'none';
        }
        
        // --- FUNCIONES DE VOLATILIDAD Y RANKING ---
        function analyzeLeagueVolatility(optimizableBets) {
            const leagueYields = {};
            const leagueAnalysis = {};
            const STAKE_UNIT = 1.0; 

            optimizableBets.forEach(bet => {
                if (!leagueYields[bet.league]) leagueYields[bet.league] = { pnls: [], totalPnl: 0, totalStake: 0 };
                
                const yieldPerBet = bet.pnl / STAKE_UNIT; 
                leagueYields[bet.league].pnls.push(yieldPerBet);
                leagueYields[bet.league].totalPnl += bet.pnl;
                leagueYields[bet.league].totalStake += STAKE_UNIT;
            });

            for (const league in leagueYields) {
                const data = leagueYields[league];
                if (data.pnls.length < 50) {
                    leagueAnalysis[league] = { yield: 0, bets: data.pnls.length, vf: 1000, status: 'MUESTRA INSUF' };
                    continue;
                }
                
                const avgYield = data.totalPnl / data.totalStake;
                const stdDev = calculateStandardDeviation(data.pnls, avgYield);
                
                // VF: Coeficiente de Variaci√≥n (StdDev / Mean) - Alto VF = Volatilidad Alta
                const vf = (avgYield !== 0 && avgYield > 0.01) ? (stdDev / avgYield) : 1000;
                
                let status = 'ALTO RIESGO';
                if (vf < 5.0 && avgYield > 0.05) status = 'BAJA VOLATILIDAD'; 
                else if (vf < 10.0 && avgYield > 0.01) status = 'RIESGO MEDIO';
                
                leagueAnalysis[league] = { 
                    yield: (avgYield * 100).toFixed(1), 
                    bets: data.pnls.length, 
                    vf: vf.toFixed(2), 
                    status: status 
                };
            }

            return leagueAnalysis;
        }

        function findOptimalOddsRange(optimizableBets) {
            const minBetsRequired = 50; 
            if (optimizableBets.length < minBetsRequired) return { min: 'N/A', max: 'N/A', yield: 0, bets: 0 }; 

            let bestYield = -100;
            let bestMin = 0, bestMax = 0;
            let bestBets = 0;
            
            const maxOddsLimit = 15.00; 

            const uniqueOdds = [...new Set(optimizableBets.map(b => b.odds))].sort((a, b) => a - b);
            
            const effectiveOddsToTest = uniqueOdds.filter(o => o <= maxOddsLimit);

            for (let i = 0; i < effectiveOddsToTest.length; i++) {
                let min_o = effectiveOddsToTest[i];
                
                for (let j = i; j < effectiveOddsToTest.length; j++) {
                    let max_o = effectiveOddsToTest[j];
                    
                    min_o = parseFloat(min_o.toFixed(2));
                    max_o = parseFloat(max_o.toFixed(2));

                    let totalProfit = 0;
                    let totalBets = 0;
                    let totalStake = 0; 

                    for (const bet of optimizableBets) {
                        if (bet.odds >= min_o && bet.odds <= max_o) {
                            totalProfit += bet.pnl;
                            totalBets++;
                            totalStake += 1.0; 
                        }
                    }

                    if (totalBets >= minBetsRequired) { 
                        const currentYield = (totalProfit / totalStake) * 100; 
                        
                        if (currentYield > bestYield || (currentYield.toFixed(2) === bestYield.toFixed(2) && totalBets > bestBets)) {
                            bestYield = currentYield;
                            bestMin = min_o;
                            bestMax = max_o;
                            bestBets = totalBets;
                        }
                    }
                }
            }
            
            if (bestBets === 0 || bestYield <= 0.5) { 
                 return { min: 'N/A', max: 'N/A', yield: 0, bets: 0 };
            }

            return { 
                min: bestMin.toFixed(2), 
                max: bestMax.toFixed(2), 
                yield: bestYield.toFixed(2), 
                bets: bestBets 
            };
        }
        
        function checkCompatibility(optimalRange, currentData, previousData) {
            const min = parseFloat(optimalRange.min);
            const max = parseFloat(optimalRange.max); 
            const STAKE_UNIT = 1.0; 
            
            if (min === 0 || max === 0 || optimalRange.min === 'N/A') return { current: 'N/A', previous: 'N/A', currentBets: 0, previousBets: 0, status: 'NO HAY MUESTRA' };

            let currentPnl = 0, currentBets = 0, currentStake = 0;
            currentData.forEach(bet => {
                if (bet.odds >= min && bet.odds <= max) {
                    currentPnl += bet.pnl;
                    currentBets++;
                    currentStake += STAKE_UNIT;
                }
            });
            const currentYield = currentStake > 0 ? (currentPnl / currentStake) * 100 : 0; 

            let previousPnl = 0, previousBets = 0, previousStake = 0;
            previousData.forEach(bet => {
                if (bet.odds >= min && bet.odds <= max) {
                    previousPnl += bet.pnl;
                    previousBets++;
                    previousStake += STAKE_UNIT;
                }
            });
            const previousYield = previousStake > 0 ? (previousPnl / previousStake) * 100 : 0; 

            const isCompatible = (currentYield > 1.0 && previousYield > 1.0); 

            let status = 'BAJA COMPATIBILIDAD';
            if (currentBets < 5 || previousBets < 5) { 
                status = 'MUESTRA INSUFICIENTE';
            } else if (isCompatible) {
                 status = 'ALTA COMPATIBILIDAD';
            }


            return { 
                current: currentYield.toFixed(1) + '%', 
                previous: previousYield.toFixed(1) + '%', 
                currentBets: currentBets,
                previousBets: previousBets,
                status: status
            };
        }

        function updateOptimalOddsUI(optimalRange, compatibility) {
            document.getElementById('rangeDisplay').innerText = optimalRange.min + ' - ' + optimalRange.max;
            document.getElementById('valOptimalOddsYield').innerText = optimalRange.yield + '%';
            document.getElementById('valOptimalOddsBets').innerText = optimalRange.bets;

            document.getElementById('compStatus').innerText = compatibility.status;
            
            let compColor = 'var(--warning)';
            if (compatibility.status === 'ALTA COMPATIBILIDAD') compColor = 'var(--success)';
            else if (compatibility.status === 'BAJA COMPATIBILIDAD') compColor = 'var(--danger)';
            document.getElementById('compStatus').style.backgroundColor = compColor;
            
            document.getElementById('currentYear').innerText = seasonYears.current || 'N/A';
            document.getElementById('previousYear').innerText = seasonYears.previous || 'N/A';

            document.getElementById('currentYield').innerText = compatibility.current;
            document.getElementById('previousYield').innerText = compatibility.previous;
            
            const isCurrentYieldNegative = compatibility.current.includes('-') || compatibility.current === 'N/A';
            document.getElementById('currentYield').className = "kpi-value " + (isCurrentYieldNegative ? 'text-red' : 'text-green');
            
            const isPreviousYieldNegative = compatibility.previous.includes('-') || compatibility.previous === 'N/A';
            document.getElementById('previousYield').className = "kpi-value " + (isPreviousYieldNegative ? 'text-red' : 'text-green');


            document.getElementById('currentSample').innerText = `(Muestra: ${compatibility.currentBets})`;
            document.getElementById('previousSample').innerText = `(Muestra: ${compatibility.previousBets})`;
        }


        // --- UI UPDATES (Global and Charts + NUEVO Mensual) ---
        function updateGlobalUI(hist, drawdownHist, rows, wins, start, end, dd, lgData, tmPRanking, totalStakeUnits, RoR, avgEV, avgCLV, monthlyResults, lgAnalysis) {
            const tot = rows.length;
            const prof = end-start;
            const yieldVal = totalStakeUnits>0?((prof/totalStakeUnits)*100).toFixed(1):'0';
            
            document.getElementById('valBets').innerText = tot;
            document.getElementById('valAvgEV').innerText = avgEV.toFixed(2) + '%';
            document.getElementById('valProfit').innerText = prof.toFixed(2);
            document.getElementById('valYield').innerText = yieldVal + '%';
            document.getElementById('valDrawdown').innerText = '-'+dd.toFixed(2)+'%';
            document.getElementById('valRoR').innerText = RoR.toFixed(1) + '%';
            
            // NUEVO KPI: CLV
            document.getElementById('valCLV').innerText = avgCLV.toFixed(2) + '%'; 


            document.getElementById('valProfit').className = `kpi-value ${prof>=0?'text-green':'text-red'}`;
            document.getElementById('valAvgEV').className = `kpi-value ${avgEV>=0.1?'text-green':'text-red'}`;
            document.getElementById('valRoR').className = `kpi-value ${RoR<=10?'text-blue':'text-red'}`;
            document.getElementById('valCLV').className = `kpi-value ${avgCLV>=0.1?'text-green':'text-red'}`; // CLV es la prueba de Edge

            // Tabla Volatilidad (usa el cache de lgAnalysis)
            const tbVol = document.getElementById('volatilityTableBody'); tbVol.innerHTML='';
            Object.entries(lgAnalysis)
                .sort(([, a], [, b]) => (a.vf === '1000' || b.vf === '1000') ? 0 : parseFloat(b.vf) - parseFloat(a.vf)) // Ordenado por VF (m√°s vol√°til arriba)
                .forEach(([league, data]) => {
                let colorClass = data.status === 'BAJA VOLATILIDAD' ? 'text-success' : (data.status === 'RIESGO MEDIO' ? 'text-warning' : 'text-red');
                if (data.status === 'MUESTRA INSUF') colorClass = 'text-secondary';

                tbVol.innerHTML += `
                    <tr>
                        <td style="text-align:left; font-weight:bold; color:white;">${league}</td>
                        <td>${data.bets}</td>
                        <td class="${data.yield >= 0 ? 'text-green' : 'text-red'}">${data.yield}%</td>
                        <td class="${colorClass}">${data.vf}</td>
                    </tr>
                `;
            });

            // NUEVO: Tabla Rendimiento Mensual
            const tbMonthly = document.getElementById('monthlyTableBody'); tbMonthly.innerHTML='';
            Object.entries(monthlyResults)
                .sort((a,b) => b[0].localeCompare(a[0])) // Mostrar el m√°s reciente primero
                .forEach(([monthYear, data]) => {
                const monthlyYield = data.stake > 0 ? (data.pnl / data.stake) * 100 : 0;
                const yieldClass = monthlyYield >= 0 ? 'text-green' : 'text-red';

                tbMonthly.innerHTML += `
                    <tr>
                        <td style="text-align:left; font-weight:bold; color:white;">${monthYear}</td>
                        <td>${data.bets}</td>
                        <td class="${yieldClass}">${data.pnl.toFixed(2)}</td>
                        <td class="${yieldClass}">${monthlyYield.toFixed(1)}%</td>
                    </tr>
                `;
            });


            // Tabla Equipos
            const tbTeam = document.getElementById('teamTableBody'); tbTeam.innerHTML='';
            const teamRankArray = Object.entries(tmPRanking)
                .map(([team, stats]) => ({ team, ...stats }))
                .sort((a, b) => b.overall - a.overall);

            teamRankArray.slice(0,20).forEach(t => {
                const formatPnl = (pnl) => {
                    return `<span class="${pnl>=0?'text-green':'text-red'}">${pnl.toFixed(2)}</span>`;
                };

                tbTeam.innerHTML += `
                    <tr>
                        <td style="font-weight:bold;">${t.team}</td>
                        <td>${formatPnl(t.overall)}</td>
                        <td>${formatPnl(t.home)}</td>
                        <td>${formatPnl(t.away)}</td>
                    </tr>
                `;
            });

            renderCharts(hist, drawdownHist, lgData);
        }

        function renderCharts(hist, drawdownHist, lgData) {
            const ctxEq = document.getElementById('equityChart').getContext('2d');
            if(chartEq) chartEq.destroy();
            const pts = hist.length>800 ? hist.filter((_,i)=>i%5===0) : hist;
            chartEq = new Chart(ctxEq, { type:'line', data:{labels:pts.map(p=>p.x), datasets:[{label:'Banca', data:pts.map(p=>p.y), borderColor:'var(--accent)', borderWidth:2, pointRadius:0, fill:true, backgroundColor:'rgba(245, 158, 11, 0.1)'}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}, title:{display:true, text:'Evoluci√≥n de Banca (Kelly Ponderado por EV)', color:'white', font:{size:14, weight:'600'}}}, scales:{x:{display:false},y:{grid:{color:'#334155'}, ticks:{color:'white'}}}}});

            const ctxDD = document.getElementById('drawdownChart').getContext('2d');
            if(chartDD) chartDD.destroy();
            const ddPts = drawdownHist.length>800 ? drawdownHist.filter((_,i)=>i%5===0) : drawdownHist;
            chartDD = new Chart(ctxDD, { type:'line', data:{labels:ddPts.map(p=>p.x), datasets:[{label:'Drawdown (%)', data:ddPts.map(p=>p.y), borderColor:'var(--danger)', borderWidth:1, pointRadius:0, fill:true, backgroundColor:'rgba(239, 68, 68, 0.2)'}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}, title:{display:true, text:'Drawdown M√°ximo (%)', color:'white', font:{size:14, weight:'600'}}}, scales:{x:{display:false},y:{min:0, max:Math.max(30, ddPts.map(p=>p.y).reduce((a, b) => Math.max(a, b), 0)+5), grid:{color:'#334155'}, ticks:{color:'white'}}}}});

            // Gr√°fico de Barras de Profit por Liga (Top 10)
            const ctxLg = document.getElementById('leagueChart').getContext('2d');
            if(chartLg) chartLg.destroy();
            const lgArr = Object.entries(lgData)
                .sort((a,b)=>b[1]-a[1]) // Ordenar por Profit de mayor a menor
                .slice(0, 10);
                
            chartLg = new Chart(ctxLg, { 
                type:'bar', 
                data:{
                    labels:lgArr.map(x=>x[0]), 
                    datasets:[{
                        data:lgArr.map(x=>x[1]), 
                        backgroundColor:lgArr.map(x=>x[1]>=0?'var(--success)':'var(--danger)')
                    }]
                }, 
                options:{
                    responsive:true, 
                    maintainAspectRatio:false, 
                    indexAxis:'y', 
                    plugins:{
                        legend:{display:false},
                        title:{display:true, text:'Profit por Liga (Top 10)', color:'white', font:{size:14, weight:'600'}}
                    }, 
                    scales:{
                        x:{grid:{color:'#334155'}, ticks:{color:'white'}}, 
                        y:{ticks:{color:'white'}}
                    }
                }
            });
        }
    </script>
</body>
</html>
