<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Estadísticas Over/Under (con acordeones)</title>
<style>
  :root{
    --bg:#0a0f1c; --card:#121826; --panel:#1a2333; --text:#e5e7eb; --muted:#94a3b8;
    --accent:#3b82f6; --green:#10b981; --amber:#f59e0b; --red:#ef4444; --line:#263143;
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Segoe UI,Arial,sans-serif;background:var(--bg);color:var(--text);margin:0;padding:16px}
  h1{color:var(--accent);text-align:center;margin:8px 0 16px}

  .card{background:var(--card);border-radius:14px;padding:16px;margin:16px 0;border:3px solid transparent;transition:.2s border-color}
  label{display:block;margin:10px 0 6px;color:var(--muted);font-size:.95rem}
  select,input,button{width:100%;padding:12px;border-radius:10px;border:1px solid var(--line);background:#0f1726;color:#e5e7eb;font-size:16px}
  button{background:var(--accent);border-color:var(--accent);font-weight:600;cursor:pointer}
  button:hover{filter:brightness(1.05)}

  .tabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .tab{flex:1;min-width:110px;background:#0f1726;border:1px solid var(--line);color:#94a3b8;padding:10px;border-radius:10px;cursor:pointer;text-align:center}
  .tab.active{background:var(--accent);color:#fff;border-color:var(--accent);font-weight:700}

  .grid{display:grid;gap:12px}
  @media(min-width:900px){.grid{grid-template-columns:1fr 1fr}}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .panel h3{margin:0 0 10px;font-size:1.05rem;color:#cbd5e1}

  .kv{display:flex;justify-content:space-between;align-items:center;padding:8px 10px;border-bottom:1px dashed var(--line)}
  .kv:last-child{border-bottom:0}
  .muted{color:var(--muted)}
  .mono{font-variant-numeric:tabular-nums}
  .badge{display:inline-block;min-width:52px;text-align:center;padding:3px 8px;border-radius:999px;font-weight:700;color:#fff}
  .b-green{background:var(--green)} .b-amber{background:var(--amber)} .b-red{background:var(--red)}
  .b-soft{background:#0f1726;border:1px solid var(--line);color:#cbd5e1}

  table{width:100%;border-collapse:collapse;font-size:.95rem;margin-top:8px;overflow:hidden;border-radius:10px;border:1px solid var(--line)}
  th,td{padding:8px 10px;text-align:center;border-bottom:1px solid var(--line)}
  th{background:#0f1726;color:#cbd5e1;font-weight:600}
  tr:last-child td{border-bottom:0}

  .valueBox{margin-top:10px;padding:10px;border-radius:10px;text-align:center;font-weight:800}
  .value{background:var(--green);color:#fff} .novalue{background:var(--red);color:#fff}

  .row{display:grid;gap:10px}
  @media(min-width:640px){.row{grid-template-columns:1fr 1fr}}

  .pills{display:grid;grid-template-columns:repeat(2,1fr);gap:10px}
  @media(min-width:900px){.pills{grid-template-columns:repeat(3,1fr)}}
  .pill{
    position:relative;background:#0f1726;border:1px solid var(--line);
    border-radius:18px;padding:12px 12px 6px;text-align:center;min-height:84px;
    display:flex;flex-direction:column;justify-content:space-between;gap:6px;
    box-shadow:inset 0 -3px 0 0 rgba(255,255,255,0.06);
  }
  .pill .big{font-weight:800;font-size:1.05rem}
  .pill .caption{color:#cbd5e1;font-weight:600}
  .pill.ok{outline:2px solid var(--green)} .pill.warn{outline:2px solid var(--amber)} .pill.bad{outline:2px solid var(--red)}
  .spark{width:100%;height:28px}

  .preview{display:flex;gap:8px;flex-wrap:wrap;align-items:center;background:#0f1726;border:1px solid var(--line);border-radius:16px;padding:10px 12px;margin-top:12px}
  .preview .chip{display:inline-flex;align-items:center;gap:8px;background:#0b1324;border:1px solid var(--line);border-radius:999px;padding:8px 12px;font-weight:700;color:#e5e7eb;box-shadow:inset 0 -2px 0 rgba(255,255,255,.04)}
  .preview .chip .dot{width:8px;height:8px;border-radius:50%}
  .preview .chip.league .dot{background:var(--accent)}
  .preview .chip.home  .dot{background:var(--green)}
  .preview .chip.away  .dot{background:var(--red)}

  #status{margin-top:8px;font-size:.92rem}
  #status.ok{color:var(--green)}
  #status.err{color:var(--red)}

  .divider{height:8px}

  /* Acordeones */
  details.acc{background:var(--panel);border:1px solid var(--line);border-radius:14px;margin-top:12px;overflow:hidden}
  details.acc>summary{
    list-style:none;cursor:pointer;padding:14px 16px;font-weight:700;letter-spacing:.2px;
    display:flex;justify-content:space-between;align-items:center
  }
  details.acc>summary::-webkit-details-marker{display:none}
  .chev{transition:.2s transform}
  details[open] .chev{transform:rotate(180deg)}
  .acc-body{padding:0 14px 14px}
</style>
</head>
<body>
  <h1>Estadísticas Over/Under</h1>

  <div class="card">
    <input type="file" id="fileInput" accept=".json,.txt"><br>

    <div class="row">
      <div>
        <label>Selecciona Liga</label>
        <select id="leagueSelect"></select>
      </div>
      <div>
        <label>Odd Over 2.5</label>
        <input type="number" id="oddOver" step="0.01" placeholder="Ej: 1.90">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Equipo Local</label>
        <select id="homeSelect"></select>
      </div>
      <div>
        <label>Odd Under 2.5</label>
        <input type="number" id="oddUnder" step="0.01" placeholder="Ej: 2.00">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Odd 1</label>
        <input type="number" id="odd1" step="0.01" placeholder="Ej: 2.10">
      </div>
      <div>
        <label>Odd X</label>
        <input type="number" id="oddX" step="0.01" placeholder="Ej: 3.20">
      </div>
    </div>
    <div class="row">
      <div>
        <label>Odd 2</label>
        <input type="number" id="odd2" step="0.01" placeholder="Ej: 3.50">
      </div>
      <div>
        <label>Línea Corners FT (opcional)</label>
        <input type="number" id="cornersLine" step="0.5" placeholder="Ej: 9.5">
      </div>
    </div>

    <div class="tabs" id="tabs">
      <div class="tab active" data-period="FT">Full Time</div>
      <div class="tab" data-period="1H">First Half</div>
      <div class="tab" data-period="2H">Second Half</div>
    </div>

    <button id="analyzeBtn" style="margin-top:10px">Analizar</button>
    <div id="status" class="muted"></div>

    <div id="selectionPreview" class="preview" style="display:none">
      <div class="chip league"><span class="dot"></span><span id="pvLeague">—</span></div>
      <div class="chip home"><span class="dot"></span><span id="pvHome">—</span></div>
      <div class="chip away"><span class="dot"></span><span id="pvAway">—</span></div>
    </div>
  </div>

  <div id="results" class="card"></div>

<script>
let rawMatches = [];
let allMatches = []; // normalizados + ts + idx
let currentPeriod = "FT";

/* ---------- Utils ---------- */
const toNum = v => (v===null||v===undefined||v==='')? null : Number(v);
function tryParseJSON(text){
  try { return JSON.parse(text); } catch(e){}
  const wrapped = "[" + text.trim().replace(/(^,)|(,$)/g,"").replace(/\n+/g,"\n").replace(/\}\s*,\s*\{/g,"},{") + "]";
  try { return JSON.parse(wrapped); } catch(e2){ return []; }
}
function pct(a,b){ return b ? Math.round((a/b)*100) : 0; }
function cls(p){ return p>=70?"b-green":(p>=50?"b-amber":"b-red"); }
function badge(p){ return `<span class="badge ${cls(p)}">${p}%</span>`; }
function setStatus(msg, ok=false, err=false){
  const el = document.getElementById('status');
  el.textContent = msg || '';
  el.classList.remove('ok','err');
  if(ok) el.classList.add('ok');
  if(err) el.classList.add('err');
}
function acc(title, bodyHtml){
  return `
  <details class="acc">
    <summary>${title}<svg class="chev" width="18" height="18" viewBox="0 0 24 24"><path fill="#94a3b8" d="M7 10l5 5 5-5z"/></svg></summary>
    <div class="acc-body">${bodyHtml}</div>
  </details>`;
}

/* ===== Normalización robusta ===== */
function getVal(obj, keys){
  for(const k of keys){ if(obj[k]!==undefined && obj[k]!==null && obj[k]!=='') return obj[k]; }
  return undefined;
}
function splitTeams(matchStr){
  if(typeof matchStr !== 'string') return [null,null];
  const parts = matchStr.split(/\s+-\s+|\s+vs\.?\s+|\s+v\s+/i);
  if(parts.length>=2) return [parts[0].trim(), parts[1].trim()];
  return [null,null];
}

/* === Parser de fecha flexible (ES/ISO) === */
function parseDateFlexible(v){
  if(v===null || v===undefined || v==='') return null;

  if(typeof v === 'number'){
    if(v > 1e12) return v;
    if(v > 1e9)  return v * 1000;
    return null;
  }

  if(typeof v !== 'string') return null;
  let s = v.trim();

  s = s.replace(/^(lun|mar|mi[eé]|jue|vie|s[aá]b|dom)\.?,?\s*/i, '');

  const dISO = Date.parse(s);
  if(!isNaN(dISO)) return dISO;

  let m = s.match(/^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if(m){
    let dd=parseInt(m[1],10), mm=parseInt(m[2],10)-1, yy=parseInt(m[3],10);
    if(yy<100) yy += 2000;
    let hh=parseInt(m[4]||'0',10), mi=parseInt(m[5]||'0',10), ss=parseInt(m[6]||'0',10);
    return new Date(yy,mm,dd,hh,mi,ss).getTime();
  }

  m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})(?:[ T](\d{1,2}):(\d{2})(?::(\d{2}))?)?$/);
  if(m){
    let mm=parseInt(m[1],10)-1, dd=parseInt(m[2],10), yy=parseInt(m[3],10);
    if(yy<100) yy += 2000;
    let hh=parseInt(m[4]||'0',10), mi=parseInt(m[5]||'0',10), ss=parseInt(m[6]||'0',10);
    return new Date(yy,mm,dd,hh,mi,ss).getTime();
  }

  const months = {'ene':'01','feb':'02','mar':'03','abr':'04','may':'05','jun':'06','jul':'07','ago':'08','sep':'09','sept':'09','set':'09','oct':'10','nov':'11','dic':'12'};
  m = s.match(/^(\d{1,2})\s+([a-záéíóúñ\.]+)\s+(\d{2,4})(?:\s+(\d{1,2}):(\d{2})(?::(\d{2}))?)?$/i);
  if(m){
    let dd = parseInt(m[1],10);
    let mon = (m[2]||'').toLowerCase().replace(/\./g,'').normalize('NFD').replace(/[\u0300-\u036f]/g,'');
    let yy = parseInt(m[3],10); if(yy<100) yy += 2000;
    let hh = parseInt(m[4]||'0',10), mi=parseInt(m[5]||'0',10), ss=parseInt(m[6]||'0',10);
    const mm = months[mon];
    if(mm){
      return new Date(`${yy}-${mm}-${String(dd).padStart(2,'0')}T${String(hh).padStart(2,'0')}:${String(mi).padStart(2,'0')}:${String(ss).padStart(2,'0')}`).getTime();
    }
  }
  return null;
}

/* === Cuota O2.5 desde Desired Outcome + Odd === */
function isDesiredO25(x){
  if(!x) return false;
  const s = String(x).toLowerCase().replace(/\s+/g,'');
  return s==='o25' || s==='o2.5' || s==='over2.5' || s==='over25' || s==='over_2_5';
}
function extractOddO25(m){
  if(isDesiredO25(m['Desired Outcome']) || isDesiredO25(m['DesiredOutcome'])){
    const od = toNum(m.Odd ?? m.odd ?? m['Odd PreMatch'] ?? m['Odd Prematch'] ?? m['Precio'] ?? m['Price']);
    if(od && od>1) return od;
  }
  const direct = m.O25 ?? m.o25 ?? m["Over 2.5"] ?? m["over2.5"] ?? m.over25 ?? m.over_2_5 ??
                 m["Odd Over 2.5"] ?? m.odd_o25 ?? m.o2_5 ?? m["Odds Over 2.5"] ?? m.price_o25 ?? m.pre_o25;
  let val = toNum(direct);
  if(val && val>1) return val;
  for(const k of Object.keys(m)){
    const lk = k.toLowerCase();
    if( /(over|o)\s*2[._\s-]*5/.test(lk) && /(odd|cuota|price|odds|pre)/.test(lk) ){
      const v = toNum(m[k]); if(v && v>1) return v;
    }
  }
  return null;
}

function normalizeRow(m, idx){
  const league = getVal(m, ['League','league','Liga','liga','Competition','competition','league_name']) || '';
  let home = null, away = null;
  const matchStr = getVal(m, ['Match','match','Partido','fixture','evento']);
  if(matchStr){ [home, away] = splitTeams(matchStr); }
  if(!home) home = getVal(m, ['Home','home','Home Team','home_team','team_home','Local','local']);
  if(!away) away = getVal(m, ['Away','away','Away Team','away_team','team_away','Visitante','visitante']);
  home = (home||'').toString().trim();
  away = (away||'').toString().trim();

  const getScore = (keysStr) => {
    const s = getVal(m, keysStr);
    if(typeof s==='string' && /-/.test(s)){ const [a,b]=s.split('-').map(x=>parseInt(x,10)); return [a||0,b||0]; }
    return [null,null];
  };
  const [htH1, htA1] = getScore(['Result HT','result_ht','HT','ht','Half Time','halftime']);
  const [ftH1, ftA1] = getScore(['Result FT','result_ft','FT','ft','Full Time','fulltime','score']);
  const htH = (htH1!==null) ? htH1 : (toNum(getVal(m, ['home_ht','ht_home','Home HT'])) ?? 0);
  const htA = (htA1!==null) ? htA1 : (toNum(getVal(m, ['away_ht','ht_away','Away HT'])) ?? 0);
  const ftH = (ftH1!==null) ? ftH1 : (toNum(getVal(m, ['home_ft','ft_home','Home FT','home_goals','goals_home'])) ?? 0);
  const ftA = (ftA1!==null) ? ftA1 : (toNum(getVal(m, ['away_ft','ft_away','Away FT','away_goals','goals_away'])) ?? 0);

  const hcft = toNum(getVal(m, ['Home Corners at FT','home_corners_ft','home_corners','corners_home_ft']));
  const acft = toNum(getVal(m, ['Away Corners at FT','away_corners_ft','away_corners','corners_away_ft']));

  const dateRaw = getVal(m, [
    'Date','date','Fecha','fecha','Match Date','match_date','Kickoff','kickoff','Start','start','UtcDate','utcDate','game_date','time','timestamp','ts','datetime'
  ]);
  const ts = parseDateFlexible(dateRaw);

  const oddO25 = extractOddO25(m);

  return {
    idx, ts: (ts||null),
    league,
    home, away,
    Match: (home && away) ? `${home} - ${away}` : (matchStr || ''),
    htHome: htH||0, htAway: htA||0,
    ftHome: ftH||0, ftAway: ftA||0,
    home_corners_ft: hcft ?? 0,
    away_corners_ft: acft ?? 0,
    odd_o25: oddO25
  };
}

/* ===== Core (sobre datos normalizados) ===== */
function goalsByPeriod(m, period){
  if(period==="FT") return [m.ftHome, m.ftAway];
  if(period==="1H") return [m.htHome, m.htAway];
  return [(m.ftHome - m.htHome), (m.ftAway - m.htAway)];
}
function periodGoalsN(m){
  return goalsByPeriod(m, currentPeriod);
}
function lastMatchesByRole(matches, team, role){
  const arr = matches
    .filter(m => role==="home" ? m.home===team : m.away===team)
    .sort((a,b)=>{
      if(a.ts && b.ts) return a.ts - b.ts;
      if(a.ts && !b.ts) return 1;
      if(!a.ts && b.ts) return -1;
      return a.idx - b.idx;
    });
  return arr.slice(-10);
}
function percentOver(lastMatches, line){
  const n = lastMatches.length; let over=0;
  lastMatches.forEach(m=>{ const [h,a]=periodGoalsN(m); if(h+a>line) over++; });
  return pct(over,n);
}
function percentBTTS(lastMatches){
  const n = lastMatches.length; let yes=0;
  lastMatches.forEach(m=>{ const [h,a]=periodGoalsN(m); if(h>0 && a>0) yes++; });
  return pct(yes,n);
}
function teamAveragesForPeriod(lastMatches, team, period){
  let s=0,c=0,t=0,n=lastMatches.length||1;
  lastMatches.forEach(m=>{
    const [h,a]=goalsByPeriod(m, period);
    const forTeam = (team===m.home)? h : (team===m.away)? a : null;
    const opp     = (team===m.home)? a : (team===m.away)? h : null;
    if(forTeam==null) return;
    s+=forTeam; c+=opp; t+=forTeam+opp;
  });
  return {avgScored:(s/n), avgConceded:(c/n), avgGoals:(t/n)};
}
function teamAverages(lastMatches, team){
  const o = teamAveragesForPeriod(lastMatches, team, currentPeriod);
  return {avgScored:o.avgScored.toFixed(1), avgConceded:o.avgConceded.toFixed(1), avgGoals:o.avgGoals.toFixed(1)};
}
function avgCornersFT(lastMatches){
  let sum=0, n=0;
  lastMatches.forEach(m=>{
    const c = Number(m.home_corners_ft||0) + Number(m.away_corners_ft||0);
    if(!isNaN(c)){ sum += c; n++; }
  });
  return n? (sum/n) : 0;
}

/* ---------- Helpers de summary 3/5/10 ---------- */
function buildSummaryStats(arr){
  return { o05: percentOver(arr,0.5), o15: percentOver(arr,1.5), o25: percentOver(arr,2.5), o35: percentOver(arr,3.5), btts: percentBTTS(arr) };
}

/* ---------- Poisson helpers ---------- */
function poisPMF(k, lambda){ return Math.exp(-lambda)*Math.pow(lambda,k)/fact(k); }
const factMemo=[1]; function fact(n){ if(factMemo[n]!=null) return factMemo[n]; let r=factMemo[factMemo.length-1],i=factMemo.length; for(;i<=n;i++) r=factMemo[i]=r*i; return r; }
function poisCDF(k, lambda){
  let p0 = Math.exp(-lambda), sum = p0;
  let p = p0;
  for(let i=1;i<=k;i++){ p = p*(lambda/i); sum += p; }
  return sum;
}
function probTeamOver(lambda, lineHalf){ const k = Math.floor(lineHalf); return 1 - poisCDF(k, lambda); }
function probTotalOver(lambdaH, lambdaA, lineHalf){ const L = lambdaH + lambdaA; const k = Math.floor(lineHalf); return 1 - poisCDF(k, L); }
function probBTTS(lambdaH, lambdaA){ return 1 - Math.exp(-lambdaH) - Math.exp(-lambdaA) + Math.exp(-(lambdaH+lambdaA)); }
function matrix1X2(lambdaH, lambdaA, maxG=12){
  const pH = Array.from({length:maxG+1},(_,h)=>poisPMF(h,lambdaH));
  const pA = Array.from({length:maxG+1},(_,a)=>poisPMF(a,lambdaA));
  let p1=0,pX=0,p2=0;
  for(let h=0;h<=maxG;h++){
    for(let a=0;a<=maxG;a++){
      const p = pH[h]*pA[a];
      if(h>a) p1+=p; else if(h===a) pX+=p; else p2+=p;
    }
  }
  const rem1 = 1 - (p1+pX+p2); // masa truncada
  // reparte sobrante según tendencia
  const tot = p1+pX+p2; return {p1:p1/(tot), pX:pX/(tot), p2:p2/(tot), trunc:rem1};
}

/* ---------- Panels ya existentes ---------- */
function calcTeamBlock(matches, team, role){
  const last = lastMatchesByRole(matches, team, role); const n = last.length;
  let noScore=0, noConcede=0, s=0,c=0,t=0;
  last.forEach(m=>{
    const [h,a]=periodGoalsN(m);
    const forTeam=(team===m.home)?h:(team===m.away)?a:null;
    const opp=(team===m.home)?a:(team===m.away)?h:null;
    if(forTeam==null) return; if(forTeam===0) noScore++; if(opp===0) noConcede++; s+=forTeam; c+=opp; t+=forTeam+opp;
  });
  return {
    n, last,
    avgScored: n?(s/n).toFixed(1):"0.0",
    avgConceded: n?(c/n).toFixed(1):"0.0",
    avgGoals: n?(t/n).toFixed(1):"0.0",
    pNoScore: pct(noScore,n),
    pNoConcede: pct(noConcede,n)
  };
}
function renderTeamPanel(title, stats){
  return `
  <div class="panel">
    <div class="kv"><span class="muted"><strong>${title}</strong></span><span class="mono"></span></div>
    <div class="kv"><span class="muted">Avg. Scored</span><span class="mono">${stats.avgScored}</span></div>
    <div class="kv"><span class="muted">Avg. Suffer</span><span class="mono">${stats.avgConceded}</span></div>
    <div class="kv"><span class="muted">Avg. Goals</span><span class="mono">${stats.avgGoals}</span></div>
    <div class="divider"></div>
    <div class="kv"><span>Games without Scoring</span><span><span class="badge ${cls(stats.pNoScore)}">${stats.pNoScore}%</span></span></div>
    <div class="kv"><span>Games without Conceding</span><span><span class="badge ${cls(stats.pNoConcede)}">${stats.pNoConcede}%</span></span></div>
  </div>`;
}

/* Summary básico */
function renderSummaryTableN(homeLast10, awayLast10, n){
  const hArr = homeLast10.slice(-n);
  const aArr = awayLast10.slice(-n);
  const H = buildSummaryStats(hArr);
  const A = buildSummaryStats(aArr);
  const avg = (x,y)=>Math.round((x+y)/2);
  const row = (label, key)=>`
    <tr>
      <td>${label}</td>
      <td>${badge(H[key])}</td>
      <td>${badge(A[key])}</td>
      <td><span class="badge ${cls(avg(H[key],A[key]))}">${avg(H[key],A[key])}%</span></td>
    </tr>`;
  return `
    <div class="panel">
      <h3>Summary (Histórico · últimos ${n})</h3>
      <table>
        <tr><th></th><th>Home</th><th>Away</th><th>Match</th></tr>
        ${row('Over 0.5','o05')}
        ${row('Over 1.5','o15')}
        ${row('Over 2.5','o25')}
        ${row('Over 3.5','o35')}
        ${row('BTTS','btts')}
      </table>
    </div>`;
}

/* ----- Predicciones & Poisson resumidos (para acordeones) ----- */
function buildSeries(homeLast, awayLast){
  const len = Math.min(homeLast.length, awayLast.length, 10);
  const H = homeLast.slice(-len);
  const A = awayLast.slice(-len);

  const sOver = line => { const out=[]; for(let i=0;i<len;i++){ const [h1,a1]=goalsByPeriod(H[i], currentPeriod); const [h2,a2]=goalsByPeriod(A[i], currentPeriod); const v1=(h1+a1>line)?1:0, v2=(h2+a2>line)?1:0; out.push( (v1+v2)/2 * 100 ); } return out; };
  const sBTTS = ()=>{ const out=[]; for(let i=0;i<len;i++){ const [h1,a1]=goalsByPeriod(H[i], currentPeriod); const [h2,a2]=goalsByPeriod(A[i], currentPeriod); const v1=(h1>0&&a1>0)?1:0, v2=(h2>0&&a2>0)?1:0; out.push( (v1+v2)/2 * 100 ); } return out; };
  const sGoals = ()=>{ const out=[]; for(let i=0;i<len;i++){ const [h1,a1]=goalsByPeriod(H[i], currentPeriod); const [h2,a2]=goalsByPeriod(A[i], currentPeriod); out.push( (h1+h2 + a1+a2)/2 ); } return out; };
  const sCorners = ()=>{ const out=[]; for(let i=0;i<len;i++){ const c1 = Number(H[i].home_corners_ft||0) + Number(H[i].away_corners_ft||0); const c2 = Number(A[i].home_corners_ft||0) + Number(A[i].away_corners_ft||0); out.push((c1+c2)/2); } return out; };
  return { o05: sOver(0.5), o25: sOver(2.5), o15: sOver(1.5), btts: sBTTS(), goals: sGoals(), corners: sCorners() };
}
function drawSpark(canvas, series){
  if(!canvas) return;
  const dpr = window.devicePixelRatio||1;
  const w = canvas.clientWidth, h = canvas.clientHeight;
  canvas.width = Math.round(w*dpr); canvas.height = Math.round(h*dpr);
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr,dpr); ctx.clearRect(0,0,w,h);
  if(!series || series.length===0){ return; }
  let min = Math.min(...series), max = Math.max(...series);
  if (min===max){ min = min-1; max = max+1; }
  const nx = i => (i/(series.length-1))*(w-4)+2;
  const ny = v => h-2 - ((v-min)/(max-min))*(h-6);
  ctx.beginPath(); ctx.lineWidth = 2; ctx.strokeStyle = '#22d3ee';
  for(let i=0;i<series.length;i++){ const x = nx(i), y = ny(series[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke();
  const lastY = ny(series[series.length-1]); const lastX = nx(series.length-1);
  ctx.lineTo(lastX,h-2); ctx.lineTo(2,h-2); ctx.closePath(); ctx.fillStyle = 'rgba(34,211,238,0.10)'; ctx.fill();
  ctx.beginPath(); ctx.arc(lastX,lastY,2.5,0,Math.PI*2); ctx.fillStyle = '#22d3ee'; ctx.fill();
}
function smallPill(big, caption, klass=''){
  return `<div class="pill ${klass}"><div class="big">${big}</div><div class="caption">${caption}</div><canvas class="spark"></canvas></div>`;
}

/* --- Game Predictions (histórico simple) --- */
function renderPredictions(homeTeam, awayTeam, homeLast, awayLast){
  const pO05 = Math.round((percentOver(homeLast,0.5)+percentOver(awayLast,0.5))/2);
  const pO25 = Math.round((percentOver(homeLast,2.5)+percentOver(awayLast,2.5))/2);
  const pO15 = Math.round((percentOver(homeLast,1.5)+percentOver(awayLast,1.5))/2);
  const pBTTS = Math.round((percentBTTS(homeLast)+percentBTTS(awayLast))/2);

  const hAvg = teamAveragesForPeriod(homeLast, homeTeam, currentPeriod);
  const aAvg = teamAveragesForPeriod(awayLast, awayTeam, currentPeriod);
  const expGoals = Math.round((hAvg.avgScored+aAvg.avgScored));
  const avgCorners = Math.round((avgCornersFT(homeLast) + avgCornersFT(awayLast))/2);

  const pillClass = p => p>=70?'ok':(p>=50?'warn':'bad');
  const S = buildSeries(homeLast, awayLast);

  setTimeout(()=>{ document.querySelectorAll('.spark').forEach((cv,i)=>{
    const keys=['o05','o15','o25','btts','goals','corners']; drawSpark(cv, S[keys[i%keys.length]]);
  }); },0);

  return `
    <div class="pills">
      ${smallPill(`${pO05}%`, 'Over 0.5FT', pillClass(pO05))}
      ${smallPill(`${pO15}%`, 'Over 1.5FT', pillClass(pO15))}
      ${smallPill(`${pO25}%`, 'Over 2.5FT', pillClass(pO25))}
      ${smallPill(`${pBTTS}%`, 'BTTS', pillClass(pBTTS))}
      ${smallPill(`${expGoals}`, 'Goals')}
      ${smallPill(`${avgCorners}`, 'Corners')}
    </div>`;
}

/* --- Poisson total & 1X2 --- */
function valueBox(prob, odd){
  if(!odd || odd<=1) return "";
  const implied = Math.round(100/odd);
  return prob > implied
    ? `<div class="valueBox value">VALUE (Modelo ${prob}% vs ${implied}% imp.)</div>`
    : `<div class="valueBox novalue">NO VALUE (Modelo ${prob}% vs ${implied}% imp.)</div>`;
}

/* ===== Rentabilidad O2.5 (últimos 10 por rol) ===== */
function ftTotalGoals(m){ return (m.ftHome + m.ftAway); }
function getOver25Odd(m){ return (m.odd_o25 && m.odd_o25>1)? m.odd_o25 : null; }
function computeO25PnlForRole(matches, team, role){
  const last = lastMatchesByRole(matches, team, role).slice(-10);
  let considered=0, hits=0, fails=0, sumOdds=0, profit=0;
  const details = [];
  last.forEach((m, idx)=>{
    const odd = getOver25Odd(m);
    const tg = ftTotalGoals(m);
    const hit = tg > 2.5;
    let stakeProfit = null;
    if(odd && odd>1){
      considered++;
      if(hit){ hits++; stakeProfit = +(odd-1).toFixed(4); profit += (odd-1); }
      else   { fails++; stakeProfit = -1; profit -= 1; }
      sumOdds += odd;
    }
    details.push({idx: idx+1, match: m.Match || `${m.home} - ${m.away}`, result_ft: `${m.ftHome}-${m.ftAway}`, odd_o25: (odd && odd>1)? odd : '', hit: (odd && odd>1)? (hit?'✔':'✘') : '—', pnl: (odd && odd>1)? stakeProfit : '—'});
  });
  const avgOdd = considered ? (sumOdds/considered) : 0;
  const roi = considered ? (profit/considered)*100 : 0;
  return { team, role, played:last.length, considered, hits, fails, avgOdd, profit, roi, details };
}
function renderProfitabilityPanel(leagueMatches, homeTeam, awayTeam){
  const homeRes = computeO25PnlForRole(leagueMatches, homeTeam, 'home');
  const awayRes = computeO25PnlForRole(leagueMatches, awayTeam, 'away');
  const row = r => `
    <tr>
      <td>${r.team}</td>
      <td>${r.role.toUpperCase()}</td>
      <td>${r.played}</td>
      <td>${r.considered}</td>
      <td>${r.hits}</td>
      <td>${r.fails}</td>
      <td>${r.avgOdd? r.avgOdd.toFixed(2) : '—'}</td>
      <td style="font-weight:700; ${r.profit>=0?'color:#10b981':'color:#ef4444'}">${r.profit.toFixed(2)}</td>
      <td style="${r.roi>=0?'color:#10b981':'color:#ef4444'}">${r.roi.toFixed(1)}%</td>
    </tr>`;
  return `
    <div class="panel">
      <h3>Rentabilidad O2.5 (últimos 10 por rol · stake 1u)</h3>
      <table>
        <tr>
          <th>Equipo</th><th>Rol</th><th>Jugados</th><th>Considerados</th>
          <th>Hits</th><th>Fails</th><th>Odd media</th><th>Profit (u)</th><th>ROI</th>
        </tr>
        ${row(homeRes)}${row(awayRes)}
      </table>
      <div class="muted" style="margin-top:6px;font-size:.9rem">
        Nota: “Considerados” excluye partidos sin cuota O2.5 válida. Ordenamos por fecha cuando existe; si no, por el orden del archivo.
      </div>
    </div>`;
}
/* ===== FIN Rentabilidad ===== */

/* ---------- Carga ---------- */
document.getElementById("fileInput").addEventListener("change", (e)=>{
  const file = e.target.files[0]; if(!file){ setStatus('No se seleccionó archivo.', false, true); return; }
  const rd = new FileReader();
  rd.onload = ev=>{
    try{
      rawMatches = tryParseJSON(ev.target.result);
      if(!Array.isArray(rawMatches) || rawMatches.length===0){ setStatus('No se pudo leer JSON o está vacío.', false, true); return; }
      allMatches = rawMatches.map((m,idx)=>normalizeRow(m, idx)).filter(r => r.home && r.away);
      if(allMatches.length===0){ setStatus('No se encontraron partidos válidos tras normalizar.', false, true); return; }

      const leagues = [...new Set(allMatches.map(m=>m.league).filter(Boolean))].sort();
      const leagueSel = document.getElementById("leagueSelect");
      leagueSel.innerHTML = "<option value=''>--Selecciona--</option>" + leagues.map(l=>`<option>${l}</option>`).join("");
      setStatus(`Cargados ${allMatches.length} partidos · ${leagues.length} ligas`, true, false);
      updateSelectionPreview();
    }catch(err){ console.error(err); setStatus('Error al procesar el archivo. Revisa la consola.', false, true); }
  };
  rd.readAsText(file);
});

document.getElementById("leagueSelect").addEventListener("change", function(){
  const league = this.value;
  const leagueMatches = allMatches.filter(m=>m.league===league);
  const teams = [...new Set(leagueMatches.flatMap(m=>[m.home, m.away]))].sort();
  document.getElementById("homeSelect").innerHTML = teams.map(t=>`<option>${t}</option>`).join("");
  document.getElementById("awaySelect").innerHTML = teams.map(t=>`<option>${t}</option>`).join("");
  setStatus(league ? `Liga: ${league} · ${leagueMatches.length} partidos` : '');
  setTimeout(updateSelectionPreview,0);
});

document.getElementById("tabs").addEventListener("click", (e)=>{
  const t = e.target.closest(".tab"); if(!t) return;
  document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
  t.classList.add("active"); currentPeriod = t.dataset.period;
});

/* ---------- Analizar ---------- */
document.getElementById("analyzeBtn").addEventListener("click", ()=>{
  try{
    updateSelectionPreview();

    const league = document.getElementById("leagueSelect").value;
    const homeTeam = document.getElementById("homeSelect").value;
    const awayTeam = document.getElementById("awaySelect").value;

    if(!allMatches.length){ setStatus('Primero carga un archivo JSON.', false, true); return; }
    if(!league){ setStatus('Selecciona liga.', false, true); return; }
    if(!homeTeam || !awayTeam || homeTeam===awayTeam){ setStatus('Selecciona equipos válidos (distintos).', false, true); return; }

    const oddOver = parseFloat(document.getElementById("oddOver").value);
    const oddUnder = parseFloat(document.getElementById("oddUnder").value);
    const odd1 = parseFloat(document.getElementById("odd1").value);
    const oddX = parseFloat(document.getElementById("oddX").value);
    const odd2 = parseFloat(document.getElementById("odd2").value);
    const cornersLine = parseFloat(document.getElementById("cornersLine").value);

    const leagueMatches = allMatches.filter(m=>m.league===league);
    if(leagueMatches.length===0){ setStatus('La liga seleccionada no tiene partidos válidos.', false, true); return; }

    const homeLast = lastMatchesByRole(leagueMatches, homeTeam, "home");
    const awayLast = lastMatchesByRole(leagueMatches, awayTeam, "away");
    setStatus(`OK · ${homeTeam} (home): ${homeLast.length} partidos · ${awayTeam} (away): ${awayLast.length} partidos.`, true, false);

    const homeStats = calcTeamBlock(leagueMatches, homeTeam, "home");
    const awayStats = calcTeamBlock(leagueMatches, awayTeam, "away");

    /* Lambdas FT y 1H para 1X2 y HT/FT */
    const hFT = teamAveragesForPeriod(homeLast, homeTeam, "FT");
    const aFT = teamAveragesForPeriod(awayLast, awayTeam, "FT");
    const lambdaH_FT = Math.max(0, hFT.avgScored||0);
    const lambdaA_FT = Math.max(0, aFT.avgScored||0);

    const h1H = teamAveragesForPeriod(homeLast, homeTeam, "1H");
    const a1H = teamAveragesForPeriod(awayLast, awayTeam, "1H");
    const lambdaH_HT = Math.max(0, h1H.avgScored||0);
    const lambdaA_HT = Math.max(0, a1H.avgScored||0);

    /* ---- Acordeones ---- */

    // Cabecera equipos
    const teamsGrid = `
      <div class="grid">
        ${renderTeamPanel(homeTeam, homeStats)}
        ${renderTeamPanel(awayTeam, awayStats)}
      </div>`;

    // Goles Under/Over (resúmenes + Poisson)
    const summary3  = renderSummaryTableN(homeLast, awayLast, 3);
    const summary5  = renderSummaryTableN(homeLast, awayLast, 5);
    const summary10 = renderSummaryTableN(homeLast, awayLast, 10);
    const poissonOU = (()=> {
      const lines=[0.5,1.5,2.5,3.5];
      const rows = lines.map(L=>{
        const ph = Math.round(probTeamOver(lambdaH_FT, L)*100);
        const pa = Math.round(probTeamOver(lambdaA_FT, L)*100);
        const pm = Math.round(probTotalOver(lambdaH_FT, lambdaA_FT, L)*100);
        return `<tr><td>Over ${L.toFixed(1)}</td><td>${badge(ph)}</td><td>${badge(pa)}</td><td><span class="badge ${cls(pm)}">${pm}%</span></td></tr>`;
      }).join("");
      const bttsMatch = Math.round(probBTTS(lambdaH_FT, lambdaA_FT)*100);
      return `
        <div class="panel">
          <h3>Poisson (FT)</h3>
          <table>
            <tr><th></th><th>Home</th><th>Away</th><th>Match</th></tr>
            ${rows}
            <tr><td>BTTS</td><td colspan="2"></td><td><span class="badge ${cls(bttsMatch)}">${bttsMatch}%</span></td></tr>
          </table>
        </div>`;
    })();

    // GG/NG (BTTS)
    const pBTTS_hist = Math.round((percentBTTS(homeLast)+percentBTTS(awayLast))/2);
    const pBTTS_pois = Math.round(probBTTS(lambdaH_FT, lambdaA_FT)*100);
    const bttsPanel = `
      <div class="panel">
        <h3>GG / NG (BTTS)</h3>
        <div class="kv"><span>Histórico</span><span class="badge ${cls(pBTTS_hist)}">${pBTTS_hist}%</span></div>
        <div class="kv"><span>Poisson</span><span class="badge ${cls(pBTTS_pois)}">${pBTTS_pois}%</span></div>
      </div>`;

    // 1X2 (Poisson + Value)
    const m1x2 = matrix1X2(lambdaH_FT, lambdaA_FT, 12);
    const p1 = Math.round(m1x2.p1*100), pX = Math.round(m1x2.pX*100), p2 = Math.round(m1x2.p2*100);
    const oneXtwoPanel = `
      <div class="panel">
        <h3>1X2 (Poisson + Value)</h3>
        <table>
          <tr><th>Selección</th><th>% Modelo</th><th>Cuota</th><th>Implícita</th></tr>
          <tr><td>1</td><td>${badge(p1)}</td><td>${isNaN(odd1)?'—':odd1}</td><td>${!isNaN(odd1)? Math.round(100/odd1)+'%':'—'}</td></tr>
          <tr><td>X</td><td>${badge(pX)}</td><td>${isNaN(oddX)?'—':oddX}</td><td>${!isNaN(oddX)? Math.round(100/oddX)+'%':'—'}</td></tr>
          <tr><td>2</td><td>${badge(p2)}</td><td>${isNaN(odd2)?'—':odd2}</td><td>${!isNaN(odd2)? Math.round(100/odd2)+'%':'—'}</td></tr>
        </table>
        ${valueBox(p1, odd1)}
        ${valueBox(pX, oddX)}
        ${valueBox(p2, odd2)}
        <div class="muted" style="margin-top:6px">Nota: matriz truncada a 12 goles por lado (masa perdida: ${(m1x2.trunc*100).toFixed(2)}%).</div>
      </div>`;

    // Doble oportunidad
    const p1X = p1 + pX, p12 = p1 + p2, pX2 = pX + p2;
    const doubleChance = `
      <div class="panel">
        <h3>Doble oportunidad</h3>
        <table>
          <tr><th>Mercado</th><th>% Modelo</th></tr>
          <tr><td>1X</td><td>${badge(p1X)}</td></tr>
          <tr><td>12</td><td>${badge(p12)}</td></tr>
          <tr><td>X2</td><td>${badge(pX2)}</td></tr>
        </table>
      </div>`;

    // Goles totales (exactos)
    const L = lambdaH_FT + lambdaA_FT;
    const exactRows = [0,1,2,3,4,5].map(k=>`<tr><td>${k}</td><td><span class="badge ${cls(Math.round(poisPMF(k,L)*100))}">${Math.round(poisPMF(k,L)*100)}%</span></td></tr>`).join("");
    const p4plus = Math.max(0, 100 - Math.round([0,1,2,3].reduce((s,k)=>s+poisPMF(k,L),0)*100));
    const totalsPanel = `
      <div class="panel">
        <h3>Goles totales (Poisson FT)</h3>
        <table>
          <tr><th>Total</th><th>%</th></tr>
          ${exactRows}
          <tr><td>4+</td><td><span class="badge ${cls(p4plus)}">${p4plus}%</span></td></tr>
        </table>
      </div>`;

    // Corners Under/Over (histórico)
    let cornersHTML = '';
    const avgC_H = avgCornersFT(homeLast), avgC_A = avgCornersFT(awayLast);
    const avgC = (avgC_H + avgC_A)/2;
    cornersHTML += `<div class="kv"><span>Promedio corners (últ.10 por rol)</span><span class="mono">${avgC.toFixed(1)}</span></div>`;
    if(!isNaN(cornersLine)){
      let over=0, n=0;
      const both = [...homeLast, ...awayLast].slice(-20);
      both.forEach(m=>{ const c=(m.home_corners_ft||0)+(m.away_corners_ft||0); if(c!==0||c===0){ n++; if(c>cornersLine) over++; }});
      const pOverC = pct(over,n);
      cornersHTML += `<div class="kv"><span>Prob. histórica Over ${cornersLine.toFixed(1)}</span><span class="badge ${cls(pOverC)}">${pOverC}%</span></div>`;
    }
    const cornersPanel = `<div class="panel"><h3>Corners Under / Over</h3>${cornersHTML}</div>`;

    // Partidos sin encajar (clean sheets)
    const cleanPanel = `
      <div class="panel">
        <h3>Partidos sin encajar goles</h3>
        <div class="kv"><span>${homeTeam} (home) no concede</span><span class="badge ${cls(homeStats.pNoConcede)}">${homeStats.pNoConcede}%</span></div>
        <div class="kv"><span>${awayTeam} (away) no concede</span><span class="badge ${cls(awayStats.pNoConcede)}">${awayStats.pNoConcede}%</span></div>
        <div class="kv"><span>${homeTeam} (home) no anota</span><span class="badge ${cls(homeStats.pNoScore)}">${homeStats.pNoScore}%</span></div>
        <div class="kv"><span>${awayTeam} (away) no anota</span><span class="badge ${cls(awayStats.pNoScore)}">${awayStats.pNoScore}%</span></div>
      </div>`;

    // 1X2 HT/FT (aprox. independencia entre periodos)
    const ht = matrix1X2(lambdaH_HT, lambdaA_HT, 8);
    const pHT = {H:Math.round(ht.p1*100), X:Math.round(ht.pX*100), A:Math.round(ht.p2*100)};
    const ft = {H:p1, X:pX, A:p2}; // de FT
    const combos = [
      ['1/1','H','H'],['1/X','H','X'],['1/2','H','A'],
      ['X/1','X','H'],['X/X','X','X'],['X/2','X','A'],
      ['2/1','A','H'],['2/X','A','X'],['2/2','A','A'],
    ];
    const rowsHTFT = combos.map(([lbl,hf,ff])=>{
      const p = Math.round((pHT[hf]*ft[ff])/100); // producto simple
      return `<tr><td>${lbl}</td><td><span class="badge ${cls(p)}">${p}%</span></td></tr>`;
    }).join("");
    const htftPanel = `
      <div class="panel">
        <h3>1X2 HT/FT (aprox.)</h3>
        <table><tr><th>Combo</th><th>%</th></tr>${rowsHTFT}</table>
        <div class="muted" style="margin-top:6px">Aproximación multiplicativa (HT independiente de FT). Úsalo como guía.</div>
      </div>`;

    // Value Check OU rápido
    const matchOver25 = Math.round((percentOver(homeLast,2.5)+percentOver(awayLast,2.5))/2);
    const valueOver = valueBox(matchOver25, oddOver);
    const valueUnder = valueBox(100-matchOver25, oddUnder);

    // Rentabilidad O2.5
    const pnlPanel = renderProfitabilityPanel(leagueMatches, homeTeam, awayTeam);

    // Acordeones ensamblados
    const resultsHTML = `
      <div class="kv"><span class="muted">Periodo activo</span><span class="badge b-soft">${currentPeriod}</span></div>
      <div class="divider"></div>
      ${teamsGrid}

      ${acc('GOLES UNDER / OVER', `
        <div class="grid" style="margin-top:12px">${summary3}${summary5}</div>
        <div class="grid" style="margin-top:12px">${summary10}${poissonOU}</div>
        <div class="panel" style="margin-top:12px"><h3>Value Check O/U 2.5</h3>
          <div class="grid">
            <div class="panel"><h3>Over 2.5</h3>${valueOver||'<div class="muted">Ingresa Odd Over 2.5</div>'}</div>
            <div class="panel"><h3>Under 2.5</h3>${valueUnder||'<div class="muted">Ingresa Odd Under 2.5</div>'}</div>
          </div>
        </div>
      `)}

      ${acc('GG / NG', bttsPanel)}

      ${acc('1X2', oneXtwoPanel)}

      ${acc('DOBLE OPORT.', doubleChance)}

      ${acc('GOLES TOTALES', totalsPanel)}

      ${acc('CORNERS UNDER / OVER', cornersPanel)}

      ${acc('PARTIDOS SIN ENCAJAR GOLES', cleanPanel)}

      ${acc('1X2 HT/FT', htftPanel)}

      ${acc('Game Predicción (histórico con tendencia)', '<div class=\"panel\">'+renderPredictions(homeTeam, awayTeam, homeLast, awayLast)+'</div>')}

      ${acc('Rentabilidad O2.5 (últimos 10 por rol)', pnlPanel)}
    `;

    const res = document.getElementById("results");
    res.innerHTML = resultsHTML;

    if (matchOver25 >= 70) res.style.borderColor = "var(--green)";
    else if (matchOver25 >= 50) res.style.borderColor = "var(--amber)";
    else res.style.borderColor = "var(--red)";
  }catch(err){ console.error(err); setStatus('Ocurrió un error al analizar. Revisa la consola.', false, true); }
});

/* ===== Vista previa de selección (chips) ===== */
function updateSelectionPreview(){
  const league = document.getElementById("leagueSelect").value || "";
  const home   = document.getElementById("homeSelect").value || "";
  const away   = document.getElementById("awaySelect").value || "";
  const pv     = document.getElementById("selectionPreview");
  document.getElementById("pvLeague").textContent = league || "—";
  document.getElementById("pvHome").textContent   = home   || "—";
  document.getElementById("pvAway").textContent   = away   || "—";
  pv.style.display = (league && home && away && home!==away) ? "flex" : "none";
}
["leagueSelect","homeSelect","awaySelect"].forEach(id=>{
  document.getElementById(id).addEventListener("change", updateSelectionPreview);
});
</script>
</body>
</html>