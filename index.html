<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Conversor Universal a JSON</title>
<style>
  :root{
    --bg:#0b1220;--card:#121a2b;--muted:#93a0b2;--text:#e6ecf2;--accent:#22d3ee;--ok:#22c55e;--warn:#f59e0b;--err:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#081022,#0b1426);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  header{padding:28px 20px;text-align:center}
  header h1{margin:0 0 6px;font-size:clamp(20px,3.5vw,30px)}
  header p{margin:0;color:var(--muted)}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  .panel{background:var(--card);border:1px solid #1b2540;border-radius:14px;padding:16px;margin-bottom:16px}
  .grid{display:grid;gap:12px}
  @media(min-width:900px){.grid{grid-template-columns:1.1fr 1fr}}
  .drop{
    border:2px dashed #243455;border-radius:12px;padding:20px;text-align:center;cursor:pointer;
    transition:0.2s background,0.2s border-color
  }
  .drop.drag{background:#0f1b34;border-color:var(--accent)}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .row > *{flex:0 0 auto}
  input[type="file"]{display:none}
  button, select{background:#17233f;border:1px solid #233153;color:var(--text);padding:10px 14px;border-radius:10px;cursor:pointer}
  button:hover{border-color:#33508a}
  .pill{padding:6px 10px;border-radius:999px;background:#0e1a31;border:1px solid #1b2b4e;color:var(--muted);font-size:12px}
  .options{display:flex;gap:10px;flex-wrap:wrap}
  textarea{width:100%;min-height:300px;background:#0c162b;color:#eaf2ff;border:1px solid #1b2540;border-radius:10px;padding:12px;font-family:ui-monospace,SFMono-Regular,Consolas,Monaco,monospace}
  .footer{display:flex;gap:8px;flex-wrap:wrap;justify-content:space-between;align-items:center;margin-top:10px}
  .small{color:var(--muted);font-size:12px}
  .tag{font-family:ui-monospace,monospace;background:#0b1730;border:1px solid #1a2a52;border-radius:8px;padding:4px 8px}
  .status{font-size:13px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  .hidden{display:none}
  .kbd{font-family:ui-monospace,monospace;background:#0d1a33;border:1px solid #213158;border-radius:6px;padding:0 6px}
</style>
</head>
<body>
  <header>
    <h1>Conversor Universal a JSON</h1>
    <p>Sube, arrastra o pega archivos y conviértelos a JSON. Soporta JSON, CSV/TSV, Excel, YAML, XML/HTML, INI, TXT y binarios.</p>
  </header>

  <div class="wrap">
    <div class="panel grid">
      <div>
        <label for="file" class="drop" id="drop">
          <div style="font-size:15px;margin-bottom:6px;">Arrastra y suelta archivos aquí</div>
          <div class="small">o haz clic para elegir…</div>
          <div style="margin-top:10px" class="row">
            <span class="pill">Múltiples archivos</span>
            <span class="pill">Hasta ~50MB por archivo*</span>
          </div>
        </label>
        <input id="file" type="file" multiple />
        <div class="row" style="margin-top:10px;gap:8px;">
          <button id="btnPaste">Pegar desde portapapeles</button>
          <span class="small">Tip: presiona <span class="kbd">Ctrl/⌘ + V</span> en la página para pegar texto o imágenes.</span>
        </div>
        <div id="pasteZone" class="panel hidden" style="margin-top:12px">
          <div class="row" style="justify-content:space-between">
            <strong>Zona de pegado</strong>
            <button id="closePaste">Cerrar</button>
          </div>
          <p class="small">Pega texto, imágenes o archivos (desde el explorador) aquí abajo:</p>
          <div id="pasteTarget" contenteditable="true" style="min-height:120px;border:1px dashed #27406f;border-radius:10px;padding:10px;"></div>
          <div class="small">El contenido pegado se convertirá igual que un archivo subido.</div>
        </div>
      </div>

      <div>
        <div class="panel">
          <strong>Opciones</strong>
          <div class="options" style="margin-top:10px">
            <label class="tag">Indentación: 
              <select id="indent">
                <option value="2">2</option>
                <option value="4" selected>4</option>
                <option value="0">Compacto</option>
              </select>
            </label>
            <label class="tag">Modo CSV:
              <select id="csvMode">
                <option value="auto" selected>Auto (detecta cabeceras)</option>
                <option value="rows">Filas (array de arrays)</option>
                <option value="objects">Objetos (usa primera fila)</option>
              </select>
            </label>
            <label class="tag">Base64 binarios:
              <select id="b64Limit">
                <option value="full">Completo</option>
                <option value="200000">Truncar ~200KB</option>
                <option value="0" selected>Sin base64 (solo metadatos)</option>
              </select>
            </label>
          </div>
          <div class="small" style="margin-top:8px">*Navegadores pueden limitar lectura de archivos muy grandes.</div>
        </div>

        <div class="panel">
          <strong>Acciones</strong>
          <div class="row" style="margin-top:10px">
            <button id="btnCopy">Copiar JSON</button>
            <button id="btnDownload">Descargar .json</button>
            <button id="btnClear">Limpiar</button>
          </div>
          <div id="status" class="status small" style="margin-top:8px"></div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="row" style="justify-content:space-between;align-items:center">
        <strong>Resultado JSON</strong>
        <span class="small">Salida combina todos los archivos en un array si subes más de uno.</span>
      </div>
      <textarea id="output" spellcheck="false" placeholder='[{"name":"archivo.ext","data":{...}}]'></textarea>
    </div>
  </div>

  <!-- Dependencias desde CDN (ligeras y ampliamente usadas) -->
  <!-- CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js" integrity="" crossorigin="anonymous"></script>
  <!-- Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" integrity="" crossorigin="anonymous"></script>
  <!-- YAML -->
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js" integrity="" crossorigin="anonymous"></script>

  <script>
  (function(){
    const fileInput = document.getElementById('file');
    const drop = document.getElementById('drop');
    const output = document.getElementById('output');
    const statusEl = document.getElementById('status');
    const indentSel = document.getElementById('indent');
    const csvModeSel = document.getElementById('csvMode');
    const b64LimitSel = document.getElementById('b64Limit');

    const btnCopy = document.getElementById('btnCopy');
    const btnDownload = document.getElementById('btnDownload');
    const btnClear = document.getElementById('btnClear');

    const btnPaste = document.getElementById('btnPaste');
    const pasteZone = document.getElementById('pasteZone');
    const closePaste = document.getElementById('closePaste');
    const pasteTarget = document.getElementById('pasteTarget');

    const setStatus = (msg, type='')=>{
      statusEl.className = 'status small ' + (type||'');
      statusEl.textContent = msg;
    };

    // Utilidades
    const extOf = name => (name.split('.').pop()||'').toLowerCase();
    const isTextType = type => /^text\/|javascript|json|xml|yaml|yml/.test(type);
    const readAsText = file => new Promise((res,rej)=>{
      const r=new FileReader(); r.onerror=rej; r.onload=()=>res(r.result); r.readAsText(file);
    });
    const readAsArrayBuffer = file => new Promise((res,rej)=>{
      const r=new FileReader(); r.onerror=rej; r.onload=()=>res(r.result); r.readAsArrayBuffer(file);
    });
    const readAsDataURL = file => new Promise((res,rej)=>{
      const r=new FileReader(); r.onerror=rej; r.onload=()=>res(r.result); r.readAsDataURL(file);
    });

    function parseINI(text){
      const result = {}; let section = result;
      const sectionStack = [];
      text.split(/\r?\n/).forEach(line=>{
        line=line.trim();
        if(!line || line.startsWith(';') || line.startsWith('#')) return;
        const mSec = line.match(/^\[(.+?)\]$/);
        if(mSec){
          const path = mSec[1].split('.');
          section = result;
          for(const p of path){ section[p] = section[p] || {}; section = section[p]; }
          return;
        }
        const mKV = line.match(/^([^=]+)=(.*)$/);
        if(mKV){
          const key=mKV[1].trim(); let val=mKV[2].trim();
          // intenta numerico/booleano
          if(/^(true|false)$/i.test(val)) val = /^true$/i.test(val);
          else if(!isNaN(Number(val))) val = Number(val);
          else if(/^".*"$|^'.*'$/.test(val)) val = val.slice(1,-1);
          section[key]=val;
        }
      });
      return result;
    }

    function xmlNodeToJson(node){
      // Element, Text, CDATA
      if(node.nodeType === 3 || node.nodeType === 4){
        const t = node.nodeValue.trim();
        return t ? t : undefined;
      }
      if(node.nodeType !== 1) return undefined;

      const obj = {};
      // atributos
      if(node.attributes && node.attributes.length){
        obj['@attrs'] = {};
        for(const attr of node.attributes){
          obj['@attrs'][attr.name] = attr.value;
        }
      }
      // hijos
      const childMap = {};
      for(const child of node.childNodes){
        const j = xmlNodeToJson(child);
        if(j === undefined) continue;
        const key = child.nodeType===1 ? child.nodeName : '#text';
        if(!childMap[key]) childMap[key] = [];
        childMap[key].push(j);
      }
      for(const k in childMap){
        obj[k] = childMap[k].length===1 ? childMap[k][0] : childMap[k];
      }
      if(Object.keys(obj).length===0) return null;
      return obj;
    }

    async function convertFile(file){
      const name = file.name || 'pasted';
      const type = file.type || '';
      const ext = extOf(name);

      try{
        // JSON
        if(ext==='json' || /application\/json/.test(type)){
          const text = await readAsText(file);
          return { name, type, data: JSON.parse(text) };
        }

        // CSV/TSV
        if(ext==='csv' || ext==='tsv' || /^text\/(csv|tsv)/.test(type)){
          const text = await readAsText(file);
          let config = {skipEmptyLines:true, dynamicTyping:true};
          if(csvModeSel.value==='rows'){ config.header=false }
          else if(csvModeSel.value==='objects'){ config.header=true }
          else { config.header='infer' } // ext: soporte auto (Papa no lo tiene nativo)
          // hack infer: si la primera fila no repite campos, asumimos header
          if(config.header==='infer'){
            const probe = Papa.parse(text, {preview:2}).data||[];
            const first = probe[0]||[], second = probe[1]||[];
            const unique = new Set(first).size === first.length;
            config.header = unique && first.length===second.length;
          }
          const parsed = Papa.parse(text, config);
          return { name, type: type||'text/csv', data: parsed.data };
        }

        // Excel (xlsx/xls)
        if(['xlsx','xls','xlsb','xlsm','ods','fods'].includes(ext)){
          const buf = await readAsArrayBuffer(file);
          const wb = XLSX.read(buf, { type:'array' });
          const sheets = {};
          wb.SheetNames.forEach(sn=>{
            sheets[sn] = XLSX.utils.sheet_to_json(wb.Sheets[sn], {defval:null});
          });
          return { name, type: type||'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', data: sheets };
        }

        // YAML
        if(['yaml','yml'].includes(ext) || /(yaml|yml)/.test(type)){
          const text = await readAsText(file);
          const data = jsyaml.load(text);
          return { name, type: type||'text/yaml', data };
        }

        // XML / HTML
        if(['xml','html','xhtml','svg'].includes(ext) || /(xml|html|svg)/.test(type)){
          const text = await readAsText(file);
          const parser = new DOMParser();
          const mime = ext==='html' ? 'text/html' : 'application/xml';
          const doc = parser.parseFromString(text, mime);
          // errores de parseo?
          if(doc.querySelector('parsererror')) throw new Error('XML/HTML inválido');
          const root = doc.documentElement || doc;
          const data = {};
          data[root.nodeName] = xmlNodeToJson(root);
          return { name, type: type||mime, data };
        }

        // INI
        if(['ini','cfg','conf','properties'].includes(ext)){
          const text = await readAsText(file);
          const data = parseINI(text);
          return { name, type: type||'text/plain', data };
        }

        // TXT (por descarte si es texto)
        if(isTextType(type) || ['txt','log','md','rtf'].includes(ext)){
          const text = await readAsText(file);
          const lines = text.split(/\r?\n/);
          return { name, type: type||'text/plain', data: lines };
        }

        // Binarios (PDF, imágenes, etc.)
        const b64Mode = b64LimitSel.value;
        const meta = { name, mime: type||'application/octet-stream', size: file.size };
        if(b64Mode !== '0'){
          const dataURL = await readAsDataURL(file);
          let base64 = dataURL.split(',')[1] || '';
          const limit = b64Mode==='full' ? Infinity : Number(b64Mode);
          if(base64.length > limit){
            base64 = base64.slice(0, limit);
            meta.base64_truncated = true;
            meta.base64_note = 'Truncado para evitar archivos JSON gigantes';
          }
          meta.base64 = base64;
        }
        return { name, type: type||'application/octet-stream', data: meta };

      } catch(err){
        return { name, type, error: true, message: (err && err.message) ? err.message : String(err) };
      }
    }

    async function handleFiles(fileList){
      if(!fileList || !fileList.length) return;
      setStatus('Convirtiendo ' + fileList.length + ' archivo(s)…');
      const results = [];
      for(const file of fileList){
        results.push( await convertFile(file) );
      }
      const indent = Number(indentSel.value);
      const json = results.length===1 ? results[0] : results;
      output.value = JSON.stringify(json, null, indent);
      const errors = (Array.isArray(json)?json:[json]).filter(x=>x && x.error);
      if(errors.length){
        setStatus('Convertido con errores en ' + errors.length + ' archivo(s). Revisa mensajes.', 'warn');
      } else {
        setStatus('Conversión completada.', 'ok');
      }
    }

    // Arrastrar/soltar
    ['dragenter','dragover'].forEach(evt=>{
      drop.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.add('drag'); });
    });
    ['dragleave','drop'].forEach(evt=>{
      drop.addEventListener(evt, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.remove('drag'); });
    });
    drop.addEventListener('drop', e=>{
      const items = e.dataTransfer.items;
      if(items && items.length){
        const files = [];
        for(const it of items){
          if(it.kind==='file'){ files.push(it.getAsFile()); }
        }
        handleFiles(files);
      } else {
        handleFiles(e.dataTransfer.files);
      }
    });
    drop.addEventListener('click', ()=> fileInput.click());
    fileInput.addEventListener('change', e=> handleFiles(e.target.files));

    // Portapapeles (botón)
    btnPaste.addEventListener('click', async ()=>{
      pasteZone.classList.remove('hidden');
      try{
        if(!navigator.clipboard || !navigator.clipboard.read){
          setStatus('Tu navegador no permite leer archivos del portapapeles automáticamente. Pega en la zona y se procesará.', 'warn');
          return;
        }
        const items = await navigator.clipboard.read();
        const files = [];
        for(const it of items){
          for(const type of it.types){
            const blob = await it.getType(type);
            const name = 'clipboard.' + (type.split('/')[1]||'bin');
            files.push(new File([blob], name, {type}));
          }
        }
        if(files.length) handleFiles(files);
      }catch(e){
        setStatus('No se pudo leer del portapapeles: ' + e.message, 'warn');
      }
    });
    closePaste.addEventListener('click', ()=> pasteZone.classList.add('hidden'));

    // Pegar directo en la página (Ctrl/⌘+V)
    document.addEventListener('paste', e=>{
      const files = [];
      if(e.clipboardData && e.clipboardData.items){
        for(const it of e.clipboardData.items){
          if(it.kind==='file'){
            const f = it.getAsFile();
            if(f) files.push(f);
          }
        }
      }
      if(files.length){
        e.preventDefault();
        handleFiles(files);
      } else {
        // texto pegado
        const text = e.clipboardData.getData('text');
        if(text){
          e.preventDefault();
          // lo tratamos como archivo txt
          const blob = new Blob([text], {type:'text/plain'});
          const file = new File([blob], 'clipboard.txt', {type:'text/plain'});
          handleFiles([file]);
        }
      }
    });

    // Botones
    btnCopy.addEventListener('click', async ()=>{
      try{
        await navigator.clipboard.writeText(output.value);
        setStatus('JSON copiado al portapapeles.', 'ok');
      }catch(e){
        setStatus('No se pudo copiar: ' + e.message, 'err');
      }
    });
    btnDownload.addEventListener('click', ()=>{
      const blob = new Blob([output.value||''], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'convertido.json';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus('Descarga iniciada.', 'ok');
    });
    btnClear.addEventListener('click', ()=>{
      output.value='';
      fileInput.value='';
      setStatus('Limpio.');
    });

    // React a cambio de opciones (reformatea)
    [indentSel,csvModeSel,b64LimitSel].forEach(el=>{
      el.addEventListener('change', ()=> {
        // solo reintenta parsear si hay archivos? No los conservamos.
        // Así que solo re-indentamos si es JSON válido.
        try{
          const current = JSON.parse(output.value);
          output.value = JSON.stringify(current, null, Number(indentSel.value));
          setStatus('Formato actualizado.', 'ok');
        }catch{}
      });
    });
  })();
  </script>
</body>
</html>