<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Backtesting ROI ‚Äî Full Tool</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#f5f7fb; --card:#fff; --accent:#0b6ed0; --muted:#6b7280;
    --success:#16a34a; --danger:#dc2626;
  }
  *{box-sizing:border-box}
  body{font-family:Inter,system-ui,Arial,sans-serif;background:var(--bg);margin:0;padding:20px;color:#0f1724}
  .wrap{max-width:1200px;margin:0 auto}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap}
  header h1{margin:0;font-size:20px}
  .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:12px;margin-top:14px}
  @media(max-width:900px){.controls{grid-template-columns:repeat(1,1fr)}}
  .card{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(12,20,30,0.06)}
  label{display:block;font-weight:600;margin-bottom:6px}
  input[type=file], select, input[type=number], input[type=text]{width:100%;padding:8px;border:1px solid #e6e9ee;border-radius:8px}
  button{background:var(--accent);color:white;border:none;padding:10px 12px;border-radius:8px;cursor:pointer}
  button.secondary{background:#334155}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:12px}
  .small{font-size:13px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
  th,td{padding:8px;border:1px solid #e6e9ee;text-align:left}
  th{background:#0f1724;color:white}
  tr:nth-child(even){background:#fbfdff}
  .good{color:var(--success);font-weight:700}
  .bad{color:var(--danger);font-weight:700}
  .inline{display:inline-block;margin-right:8px}
  #log{background:#0b1220;color:#dbe9ff;padding:8px;border-radius:6px;height:110px;overflow:auto;font-size:12px}
  .flex{display:flex;gap:12px;align-items:center}
  .col{display:flex;flex-direction:column}
  .chart-wrap{height:320px;padding:10px}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Backtesting ROI ‚Äî Herramienta completa</h1>
      <div class="small">Bank referencia 100 u ¬∑ stake por defecto 1 u ¬∑ Safari-friendly</div>
    </div>
    <div class="flex">
      <button id="saveIndexed">üíæ Guardar en IndexedDB</button>
      <button id="loadIndexed" class="secondary">üìÇ Cargar desde IndexedDB</button>
      <button id="clearIndexed" style="background:#d03b3b">üóë Borrar IndexedDB</button>
    </div>
  </header>

  <section style="margin-top:16px" class="card">
    <div class="controls">
      <div>
        <label>1) Subir HISTORIAL (JSON)</label>
        <input id="histInput" type="file" accept=".json">
        <div class="small" style="margin-top:6px">Formato flexible: array, objetos separados por comas, l√≠neas... (ver logs si hay error)</div>
      </div>

      <div>
        <label>2) Subir PARTIDOS FUTUROS (JSON)</label>
        <input id="futInput" type="file" accept=".json">
      </div>

      <div>
        <label>3) Filtro por LIGA</label>
        <select id="leagueFilter"><option value="all">Todas</option></select>
      </div>

      <div>
        <label>4) Filtro por EQUIPO (opcional)</label>
        <input id="teamFilter" type="text" placeholder="Escribe parte del nombre del equipo...">
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div style="flex:0 0 150px">
        <label>Stake por apuesta</label>
        <input id="stakeInput" type="number" min="0.1" step="0.1" value="1">
      </div>

      <div style="flex:0 0 180px">
        <label>Bank (referencia)</label>
        <input id="bankInput" type="number" min="1" step="1" value="100">
      </div>

      <div style="flex:1">
        <label>Opciones</label>
        <div class="row">
          <button id="runBtn">üîç Hacer Backtesting</button>
          <button id="exportCsv" class="secondary">‚¨á Exportar CSV</button>
          <button id="clearBtn" style="background:#ef4444">Limpiar memoria</button>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div style="flex:1">
        <label>Logs</label>
        <pre id="log"></pre>
      </div>
      <div style="flex:1">
        <label>Resumen</label>
        <div id="summary" class="card small" style="height:110px;padding:10px;overflow:auto">Sin datos</div>
      </div>
    </div>
  </section>

  <section class="card" style="margin-top:12px">
    <h3 style="margin:0 0 8px 0">ROI por equipo (resultado del Backtesting)</h3>
    <div class="small">Equipos con ROI positivo resaltados.</div>
    <div style="overflow:auto;margin-top:10px">
      <table id="teamTable">
        <thead>
          <tr>
            <th>Equipo</th><th>Partidos</th><th>Ganados</th><th>Perdidos</th><th>Profit total</th><th>Avg profit/part</th><th>ROI %</th><th>Kelly %</th><th>Kelly stake</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section class="card" style="margin-top:12px">
    <div style="display:flex;gap:12px;align-items:center">
      <h3 style="margin:0">Gr√°fica ROI por equipo</h3>
      <div class="small">Top 30 por defecto</div>
    </div>
    <div class="chart-wrap">
      <canvas id="roiChart"></canvas>
    </div>
  </section>
</div>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* ---------------- CONFIG ---------------- */
const logEl = document.getElementById('log');
const histInput = document.getElementById('histInput');
const futInput = document.getElementById('futInput');
const leagueFilter = document.getElementById('leagueFilter');
const teamFilter = document.getElementById('teamFilter');
const runBtn = document.getElementById('runBtn');
const exportCsvBtn = document.getElementById('exportCsv');
const clearBtn = document.getElementById('clearBtn');
const saveIndexed = document.getElementById('saveIndexed');
const loadIndexed = document.getElementById('loadIndexed');
const clearIndexed = document.getElementById('clearIndexed');

let historialUploaded = null;
let futurosUploaded = null;
let teamStats = {}; // normalizedName -> stats
let chart = null;

/* ---------------- UTILS ---------------- */
function log(msg){
  const t = new Date().toLocaleTimeString();
  logEl.textContent = `[${t}] ${msg}\n` + logEl.textContent;
}
function safeParseJSON(content){
  content = String(content || '').trim();
  if(!content) throw new Error('Contenido vac√≠o');
  // try direct
  try { const p = JSON.parse(content); return Array.isArray(p) ? p : [p]; } catch(e){}
  // try wrap as array
  try {
    const wrapped = '[' + content.replace(/,\s*$/, '') + ']';
    const p = JSON.parse(wrapped);
    return Array.isArray(p) ? p : [p];
  } catch(e){}
  // try lines
  const lines = content.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  if(lines.length>1){
    const out=[];
    for(let ln of lines){ if(ln.endsWith(',')) ln = ln.slice(0,-1); try{ out.push(JSON.parse(ln)); }catch(e){} }
    if(out.length) return out;
  }
  // regex {...}
  const objs=[]; const re=/{[^}]*}/g; let m;
  while((m=re.exec(content))!==null){ try{ objs.push(JSON.parse(m[0])); }catch(e){} }
  if(objs.length) return objs;
  throw new Error('No se pudo parsear JSON. Aseg√∫rate del formato.');
}
function normalize(s){
  if(!s && s!==0) return '';
  let x = String(s).trim().toLowerCase();
  x = x.normalize('NFD').replace(/\p{Diacritic}/gu,'');
  x = x.replace(/[^a-z0-9\- ]/g,' ');
  x = x.replace(/\s+/g,' ').trim();
  return x;
}
function mean(arr){ return arr.length? arr.reduce((a,b)=>a+b,0)/arr.length : NaN; }

/* ---------------- READ FILES INTO MEMORY (Safari-friendly) ---------------- */
histInput.addEventListener('change', async (e)=>{
  try{
    const f = e.target.files[0];
    if(!f) return;
    const txt = await f.text();
    const parsed = safeParseJSON(txt);
    historialUploaded = parsed;
    log(`Historial cargado: ${parsed.length} registros (archivo: ${f.name})`);
    buildLeagueOptions();
  }catch(err){ log('ERROR parse historial: '+err.message); }
});
futInput.addEventListener('change', async (e)=>{
  try{
    const f = e.target.files[0];
    if(!f) return;
    const txt = await f.text();
    const parsed = safeParseJSON(txt);
    futurosUploaded = parsed;
    log(`Futuros cargados: ${parsed.length} registros (archivo: ${f.name})`);
    buildLeagueOptions();
  }catch(err){ log('ERROR parse futuros: '+err.message); }
});

/* ---------------- Build league filter options from both datasets ---------------- */
function buildLeagueOptions(){
  const s = new Set();
  if(Array.isArray(historialUploaded)) historialUploaded.forEach(x=>{ if(x.League) s.add(String(x.League)); });
  if(Array.isArray(futurosUploaded)) futurosUploaded.forEach(x=>{ if(x.League) s.add(String(x.League)); });
  const prev = leagueFilter.value || 'all';
  leagueFilter.innerHTML = '<option value="all">Todas</option>';
  Array.from(s).sort().forEach(l => {
    const opt = document.createElement('option'); opt.value = l; opt.textContent = l;
    leagueFilter.appendChild(opt);
  });
  leagueFilter.value = prev;
}

/* ---------------- CORE: run backtesting using teams from futuros ---------------- */
runBtn.addEventListener('click', ()=>{
  try{
    if(!historialUploaded || !futurosUploaded){ log('Debes cargar ambos archivos primero.'); return; }
    const stake = parseFloat(document.getElementById('stakeInput').value) || 1;
    const bank = parseFloat(document.getElementById('bankInput').value) || 100;
    const ligaSel = leagueFilter.value;
    const teamQuery = (teamFilter.value||'').trim().toLowerCase();

    teamStats = {}; // reset

    // list equipos a procesar - from futuros (apply league filter + team filter)
    const equiposSet = new Set();
    futurosUploaded.forEach(f=>{
      if(!f.Match) return;
      if(ligaSel !== 'all' && f.League !== ligaSel) return;
      const [home, away] = String(f.Match).split(' - ').map(s=> (s||'').trim());
      if(home && (!teamQuery || home.toLowerCase().includes(teamQuery))) equiposSet.add(home);
      if(away && (!teamQuery || away.toLowerCase().includes(teamQuery))) equiposSet.add(away);
    });

    if(equiposSet.size === 0){ log('No se encontraron equipos en partidos futuros con los filtros aplicados.'); return; }
    log(`Se analizar√°n ${equiposSet.size} equipos (extra√≠dos de partidos futuros)`);

    // Preprocess historial: map normalized match teams to entries for faster search
    // We'll iterate historial and for each record, check if either team is in equiposSet
    const equiposArray = Array.from(equiposSet);
    const normToDisplay = {}; // normalized -> display
    equiposArray.forEach(e=> normToDisplay[normalize(e)] = e);

    // initialize stats
    equiposArray.forEach(e => {
      teamStats[normalize(e)] = { display:e, matches:0, wins:0, losses:0, profit:0, odds:[] };
    });

    // iterate historial once, check membership
    historialUploaded.forEach(h=>{
      if(!h.Match) return;
      const parts = String(h.Match).split(' - ').map(s=> (s||'').trim());
      const home = parts[0]||'';
      const away = parts[1]||'';
      const hNorm = normalize(home);
      const aNorm = normalize(away);

      // check if either team in our set
      [hNorm,aNorm].forEach((tNorm, idx) => {
        if(teamStats[tNorm]){
          // record one match for that team (we count each historical match for both teams if both are in set)
          teamStats[tNorm].matches++;
          // determine result: we consider h.Result === "Winning" as a win for the bet context (original data semantics)
          const res = (h.Result || '').toString().toLowerCase();
          const isWin = /win|won|winning|ganad/i.test(res);
          if(isWin) teamStats[tNorm].wins++;
          else teamStats[tNorm].losses++;
          // profit: using stake per-historical-bet: if win => (odd -1) * stake ; else => -stake
          const odd = parseFloat(h.Odd) || NaN;
          let gain = 0;
          if(isNaN(odd)){
            // If odd missing, approximate: treat win as 0 profit (or maintain counting but not change profit)
            gain = isWin ? 0 : -stake;
          } else {
            gain = isWin ? ((odd - 1) * stake) : (-stake);
            teamStats[tNorm].odds.push(odd);
          }
          teamStats[tNorm].profit += gain;
        }
      });
    });

    // compute derived stats: roi%, avgProfit, winRate, kelly
    const results = [];
    Object.keys(teamStats).forEach(n => {
      const s = teamStats[n];
      if(s.matches === 0) return; // omit teams without history
      const avgProfit = s.profit / s.matches;
      const roiPct = (s.profit / (s.matches * stake)) * 100; // profit / total staked
      const winRate = s.wins / s.matches;
      const avgOdd = mean(s.odds.filter(Boolean));
      // Kelly: fraction = (b*p - q) / b, b = avgOdd - 1, p = winRate, q = 1-p
      let kellyFrac = NaN;
      let kellyStake = NaN;
      if(!isNaN(avgOdd) && avgOdd > 1 && s.matches > 0){
        const b = avgOdd - 1;
        const p = winRate;
        const q = 1 - p;
        const frac = ((b * p) - q) / b;
        kellyFrac = Math.max(-1, Math.min(1, frac)); // clamp -1..1
        if(!isNaN(kellyFrac)){
          kellyStake = kellyFrac * bank; // recommended units
        }
      }
      results.push({
        display: s.display,
        matches: s.matches,
        wins: s.wins,
        losses: s.losses,
        profit: s.profit,
        avgProfit,
        roiPct,
        winRate,
        avgOdd: isNaN(avgOdd)?null:avgOdd,
        kellyFrac,
        kellyStake
      });
    });

    // sort by ROI desc
    results.sort((a,b) => b.roiPct - a.roiPct);

    // save results for export & chart
    window._backtestResults = results;
    renderTeamTable(results);
    renderChart(results.slice(0,30)); // top 30

    // summary
    const totalTeams = results.length;
    const teamsPositive = results.filter(r=> r.roiPct>0).length;
    document.getElementById('summary').innerHTML = `
      <div><b>Equipos analizados:</b> ${totalTeams}</div>
      <div><b>Con ROI positivo:</b> ${teamsPositive}</div>
      <div><b>Stake:</b> ${stake} ¬∑ <b>Bank:</b> ${bank}</div>
      <div class="small">Kelly calculado solo si hay odds hist√≥ricas v√°lidas</div>
    `;
    log(`Backtesting finalizado: ${totalTeams} equipos procesados. ${teamsPositive} con ROI positivo.`);
  }catch(err){
    log('ERROR en backtesting: '+ (err && err.message ? err.message : err));
  }
});

/* ---------------- RENDER TABLE ---------------- */
function renderTeamTable(data){
  const tbody = document.querySelector('#teamTable tbody');
  tbody.innerHTML = '';
  data.forEach(d=>{
    const tr = document.createElement('tr');
    if(d.roiPct > 0) tr.classList.add('positivo');
    tr.innerHTML = `<td>${d.display}</td>
      <td>${d.matches}</td>
      <td>${d.wins}</td>
      <td>${d.losses}</td>
      <td>${d.profit.toFixed(3)}</td>
      <td>${d.avgProfit.toFixed(3)}</td>
      <td class="${d.roiPct>=0?'good':'bad'}">${d.roiPct.toFixed(2)}%</td>
      <td>${isNaN(d.kellyFrac)?'N/A':(d.kellyFrac*100).toFixed(2)+'%'}</td>
      <td>${isNaN(d.kellyStake)?'N/A':d.kellyStake.toFixed(3)+' u'}</td>
    `;
    tbody.appendChild(tr);
  });
}

/* ---------------- CHART ---------------- */
function renderChart(data){
  const ctx = document.getElementById('roiChart').getContext('2d');
  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type:'bar',
    data:{
      labels: data.map(d=>d.display),
      datasets:[{
        label:'ROI %',
        data: data.map(d=>d.roiPct),
        backgroundColor: data.map(d=> d.roiPct>0 ? 'rgba(16,185,129,0.8)' : 'rgba(239,68,68,0.8)')
      }]
    },
    options:{
      responsive:true,
      plugins:{legend:{display:false}},
      scales:{y:{beginAtZero:true}}
    }
  });
}

/* ---------------- EXPORT CSV ---------------- */
exportCsvBtn.addEventListener('click', ()=>{
  const rows = window._backtestResults || [];
  if(!rows.length){ log('No hay resultados para exportar.'); return; }
  let csv = 'Equipo,Matches,Wins,Losses,Profit,AvgProfit,ROI%,WinRate,AvgOdd,KellyFrac,KellyStake\n';
  rows.forEach(r=>{
    csv += `"${r.display.replace(/"/g,'""')}",${r.matches},${r.wins},${r.losses},${r.profit.toFixed(3)},${r.avgProfit.toFixed(3)},${r.roiPct.toFixed(3)},${(r.winRate*100).toFixed(2)}%,${r.avgOdd?r.avgOdd.toFixed(3):''},${isNaN(r.kellyFrac)?'':r.kellyFrac.toFixed(4)},${isNaN(r.kellyStake)?'':r.kellyStake.toFixed(3)}\n`;
  });
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'backtesting_results.csv'; a.click();
  URL.revokeObjectURL(url);
  log('CSV exportado.');
});

/* ---------------- CLEAR MEMORY ---------------- */
clearBtn.addEventListener('click', ()=>{
  historialUploaded = null; futurosUploaded = null; teamStats = {}; window._backtestResults = null;
  document.querySelector('#teamTable tbody').innerHTML = '';
  if(chart) chart.destroy();
  log('Memoria limpiada.');
});

/* ---------------- INDEXEDDB (simple wrapper using idb-like minimal) ---------------- */
const DB_NAME = 'backtest-db-v1';
const STORE = 'files';
function openDb(){
  return new Promise((res,rej)=>{
    const r = indexedDB.open(DB_NAME,1);
    r.onupgradeneeded = e => {
      const db = e.target.result;
      if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    r.onsuccess = ()=> res(r.result);
    r.onerror = ()=> rej(r.error);
  });
}
async function idbPut(key, val){
  const db = await openDb();
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,'readwrite');
    tx.objectStore(STORE).put(val, key);
    tx.oncomplete = ()=> res();
    tx.onerror = ()=> rej(tx.error);
  });
}
async function idbGet(key){
  const db = await openDb();
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,'readonly');
    const req = tx.objectStore(STORE).get(key);
    req.onsuccess = ()=> res(req.result);
    req.onerror = ()=> rej(req.error);
  });
}
async function idbClear(){
  const db = await openDb();
  return new Promise((res,rej)=>{
    const tx = db.transaction(STORE,'readwrite');
    tx.objectStore(STORE).clear();
    tx.oncomplete = ()=> res();
    tx.onerror = ()=> rej(tx.error);
  });
}

saveIndexed.addEventListener('click', async ()=>{
  try{
    if(!historialUploaded && !futurosUploaded){ log('No hay datos para guardar.'); return; }
    await idbPut('historial', historialUploaded || []);
    await idbPut('futuros', futurosUploaded || []);
    log('Datos guardados en IndexedDB.');
  }catch(err){ log('ERROR guardar IndexedDB: '+err.message); }
});
loadIndexed.addEventListener('click', async ()=>{
  try{
    const h = await idbGet('historial');
    const f = await idbGet('futuros');
    if(h) { historialUploaded = h; log('Historial cargado desde IndexedDB: '+h.length+' registros'); }
    if(f) { futurosUploaded = f; log('Futuros cargados desde IndexedDB: '+f.length+' registros'); }
    buildLeagueOptions();
  }catch(err){ log('ERROR cargar IndexedDB: '+err.message); }
});
clearIndexed.addEventListener('click', async ()=>{
  try{ await idbClear(); log('IndexedDB limpiada.'); }catch(err){ log('ERROR limpiar IndexedDB: '+err.message); }
});

/* ---------------- UTILS ---------------- */
function mean(arr){ if(!arr || !arr.length) return NaN; return arr.reduce((a,b)=>a+b,0)/arr.length; }

log('Herramienta lista. Sube HISTORIAL y FUTUROS para comenzar.');

</script>
</body>
</html>