<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Backtesting ROI por Equipo ‚Äî Robust</title>
<style>
  :root{--bg:#f5f7fb;--card:#fff;--accent:#0b6ed0}
  body{font-family:Inter, Arial, sans-serif;background:var(--bg);margin:0;padding:18px;color:#111}
  .wrap{max-width:1100px;margin:0 auto}
  h1{margin:0 0 10px;font-size:20px}
  .row{display:flex;gap:12px;flex-wrap:wrap;margin-bottom:12px}
  .card{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 20px rgba(12,20,30,0.06);flex:1;min-width:260px}
  label{font-weight:700;display:block;margin-bottom:6px}
  input[type=file]{width:100%}
  button{background:var(--accent);color:#fff;border:0;padding:10px 14px;border-radius:8px;cursor:pointer}
  button.secondary{background:#16a34a;margin-left:8px}
  .small{font-size:13px;color:#555;margin-top:6px}
  table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
  th,td{border:1px solid #e6e9ee;padding:8px;text-align:left}
  th{background:#0f1724;color:#fff}
  pre.log{background:#0b1220;color:#dbe9ff;padding:8px;border-radius:6px;height:120px;overflow:auto;font-size:13px}
  .good{color:green;font-weight:700}
  .bad{color:red;font-weight:700}
  .badge{display:inline-block;background:#efefef;padding:4px 8px;border-radius:8px;margin-left:8px;font-weight:700}
  @media(max-width:820px){.row{flex-direction:column}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Backtesting ROI por Equipo ‚Äî versi√≥n robusta</h1>
  <div class="small">Bank referencia: <b>100</b> ‚Ä¢ Stake fijo: <b>1</b>. Carga los dos archivos (historial y futuros), luego presiona <b>Hacer Backtesting</b>.</div>

  <div class="row" style="margin-top:12px">
    <div class="card">
      <label>1) Archivo HISTORIAL (Backtesting)</label>
      <input id="histInput" type="file" accept=".json">
      <div class="small">Registros detectados: <span id="histCount" class="badge">0</span></div>
      <div class="small">Campos √∫tiles: <code>Match</code>, <code>Odd</code>, <code>Result</code> (Winning/Losing).</div>
    </div>

    <div class="card">
      <label>2) Archivo PARTIDOS FUTUROS</label>
      <input id="futInput" type="file" accept=".json">
      <div class="small">Registros detectados: <span id="futCount" class="badge">0</span></div>
      <div class="small">Campos sugeridos: <code>Match</code>, <code>Date</code>, <code>Odd</code> (opcional).</div>
    </div>
  </div>

  <div class="row" style="align-items:center">
    <div class="card" style="flex-basis:100%">
      <button id="runBtn">üîç Hacer Backtesting y Aplicar a Futuros</button>
      <button id="csvBtn" class="secondary">‚¨á Descargar CSV Predicciones</button>
      <button id="clearBtn" style="background:#d03b3b;margin-left:8px">üóë Limpiar memoria</button>
      <div class="small" style="margin-top:8px">Mensajes / logs:</div>
      <pre id="log" class="log"></pre>
    </div>
  </div>

  <div class="row">
    <div class="card">
      <h3 style="margin-top:0">Resumen</h3>
      <div id="summary" class="small">A√∫n no se ha procesado nada.</div>
    </div>
    <div class="card">
      <h3 style="margin-top:0">Controles</h3>
      <div class="small">Stake: <b>1</b> ‚Ä¢ Bank ref: <b>100</b></div>
      <div class="small" style="margin-top:8px">Normalizaci√≥n de nombres: activada (quita tildes/acentos y minusculiza).</div>
    </div>
  </div>

  <div class="row">
    <div class="card" style="flex-basis:60%">
      <h3 style="margin-top:0">ROI por Equipo (Historial)</h3>
      <table id="teamTable">
        <thead><tr><th>Equipo</th><th>Partidos</th><th>Victorias</th><th>Profit</th><th>ROI %</th><th>Profit / part. (avg)</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>

    <div class="card" style="flex-basis:40%">
      <h3 style="margin-top:0">Partidos Historial (procesados)</h3>
      <table id="histTable">
        <thead><tr><th>Fecha</th><th>Match</th><th>Odd</th><th>Result</th><th>Ganancia</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div class="card" style="margin-top:12px">
    <h3 style="margin-top:0">Predicci√≥n aplicada a Partidos Futuros</h3>
    <table id="predTable">
      <thead><tr><th>Fecha</th><th>Liga</th><th>Match</th><th>ROI Local</th><th>ROI Visit.</th><th>AvgProfit Local</th><th>AvgProfit Visit.</th><th>EV estimado</th><th>Recomendaci√≥n</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

</div>

<script>
/* ------------------ CONFIG ------------------ */
const STAKE = 1;
const BANK_REF = 100;

/* ------------------ STATE (persistente en memoria) ------------------ */
let historialUploaded = null;
let futurosUploaded = null;
let teamStats = {}; // key = normalized team name -> {displayName, matches, wins, profit}

/* ------------------ HELPERS ------------------ */

const $ = id => document.getElementById(id);
const logEl = $('log');

function log(msg){
  const now = new Date().toLocaleTimeString();
  logEl.textContent = `[${now}] ${msg}\n` + logEl.textContent;
}

function safeParseJSON(content){
  // robust parse: try many forms
  if(!content || !content.trim()) throw new Error('Archivo vac√≠o');
  content = content.trim();

  // 1) direct parse
  try {
    const parsed = JSON.parse(content);
    if(Array.isArray(parsed)) return parsed;
    if(typeof parsed === 'object') return [parsed];
  } catch(e){}

  // 2) if it's a list of objects separated by commas (common), try wrap
  try {
    const wrapped = '[' + content.replace(/,\s*$/,'') + ']';
    const p = JSON.parse(wrapped);
    if(Array.isArray(p)) return p;
  } catch(e){}

  // 3) line-delimited JSON objects
  const lines = content.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if(lines.length > 1){
    const out = [];
    for(const ln of lines){
      let s = ln;
      if(s.endsWith(',')) s = s.slice(0,-1);
      try { out.push(JSON.parse(s)); } catch(e){}
    }
    if(out.length) return out;
  }

  // 4) extract {...} blocks with regex
  const objs = [];
  const regex = /{[^}]*}/g;
  let m;
  while((m = regex.exec(content)) !== null){
    try {
      objs.push(JSON.parse(m[0]));
    } catch(e){}
  }
  if(objs.length) return objs;

  throw new Error('No se pudo parsear el JSON. Revisa el formato.');
}

function toNumber(v){
  if(v === null || v === undefined || v === '') return NaN;
  let s = String(v).replace(/\u00A0/g,'').trim();
  // handle comma decimals
  s = s.replace(/,(\d{1,})$/,'$1'.replace ? s : s); // fallback
  // better: replace last comma with dot when comma used as decimal
  if(/^\d+,\d+$/.test(s)) s = s.replace(',', '.');
  const n = parseFloat(s);
  return isNaN(n) ? NaN : n;
}

function normalizeName(name){
  if(!name && name !== 0) return '';
  // Remove special weird characters, convert to lower, remove diacritics and extra spaces
  let s = String(name).trim().toLowerCase();
  // normalize diacritics
  s = s.normalize('NFD').replace(/\p{Diacritic}/gu, '');
  // collapse multiple spaces and remove weird characters except alnum and -
  s = s.replace(/[^a-z0-9\-\s]/g, ' ');
  s = s.replace(/\s+/g, ' ').trim();
  return s;
}

/* ------------------ UI: handle file inputs (read & store in memory) ------------------ */

$('histInput').addEventListener('change', async (ev) => {
  try {
    const f = ev.target.files[0];
    if(!f) { historialUploaded = null; $('histCount').textContent = '0'; return; }
    const text = await f.text();
    const arr = safeParseJSON(text);
    historialUploaded = arr;
    $('histCount').textContent = arr.length;
    log(`Historial cargado: ${arr.length} registros (archivo: ${f.name}).`);
  } catch(err){
    historialUploaded = null;
    $('histCount').textContent = '0';
    log(`ERROR parseando historial: ${err.message}`);
  }
});

$('futInput').addEventListener('change', async (ev) => {
  try {
    const f = ev.target.files[0];
    if(!f) { futurosUploaded = null; $('futCount').textContent = '0'; return; }
    const text = await f.text();
    const arr = safeParseJSON(text);
    futurosUploaded = arr;
    $('futCount').textContent = arr.length;
    log(`Futuros cargados: ${arr.length} registros (archivo: ${f.name}).`);
  } catch(err){
    futurosUploaded = null;
    $('futCount').textContent = '0';
    log(`ERROR parseando futuros: ${err.message}`);
  }
});

/* ------------------ CLEAR MEMORY ------------------ */
$('clearBtn').addEventListener('click', () => {
  historialUploaded = null;
  futurosUploaded = null;
  teamStats = {};
  $('histCount').textContent = '0';
  $('futCount').textContent = '0';
  $('teamTable').querySelector('tbody').innerHTML = '';
  $('histTable').querySelector('tbody').innerHTML = '';
  $('predTable').querySelector('tbody').innerHTML = '';
  $('summary').textContent = 'Memoria limpiada.';
  log('Memoria limpiada por el usuario.');
});

/* ------------------ PROCESSING: build teamStats from historial ------------------ */
function processHistorial(){
  teamStats = {}; // reset
  const histBody = $('histTable').querySelector('tbody');
  histBody.innerHTML = '';

  let processedCount = 0;
  let totalProfit = 0;

  for(const item of (historialUploaded || [])){
    // Expect fields: Match, Odd, Result (but tolerant)
    const match = item.Match ?? item.Match ?? item['Match'] ?? '';
    if(!match) {
      log('Registro historial sin campo Match -> ignorado.');
      continue;
    }
    const date = item.Date ?? item.date ?? '';
    const oddRaw = item.Odd ?? item.odd ?? item['Odd 1 PreMatch'] ?? '';
    const odd = toNumber(oddRaw);
    const resultRaw = item.Result ?? item.result ?? '';
    const won = (typeof resultRaw === 'string' && /win|won|winning|ganad/i.test(resultRaw)) || (String(resultRaw).toLowerCase() === 'winning');

    // compute gain only if explicit result present (winning or losing)
    let gain = 0;
    if(resultRaw){
      if(won && !isNaN(odd)) gain = (odd - 1) * STAKE;
      else if(won && isNaN(odd)) gain = 0;
      else if(!won) gain = -STAKE;
      processedCount++;
      totalProfit += gain;
    } else {
      // no result -> show as 0 in table but not count in stats
      gain = 0;
    }

    // show in historial table
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${date}</td><td>${match}</td><td>${oddRaw ?? ''}</td><td>${resultRaw ?? ''}</td><td>${gain.toFixed(2)}</td>`;
    histBody.appendChild(tr);

    // update teamStats only when result present
    if(resultRaw){
      const parts = match.split(' - ');
      let home = parts[0] ? parts[0].trim() : null;
      let away = parts[1] ? parts[1].trim() : null;

      // if split not valid, store whole string as single key
      if(!home || !away){
        const keyNorm = normalizeName(match);
        if(!teamStats[keyNorm]) teamStats[keyNorm] = { display: match, matches:0, wins:0, profit:0 };
        teamStats[keyNorm].matches++;
        if(won) teamStats[keyNorm].wins++;
        teamStats[keyNorm].profit += gain;
      } else {
        const hNorm = normalizeName(home);
        const aNorm = normalizeName(away);

        if(!teamStats[hNorm]) teamStats[hNorm] = { display: home, matches:0, wins:0, profit:0 };
        if(!teamStats[aNorm]) teamStats[aNorm] = { display: away, matches:0, wins:0, profit:0 };

        teamStats[hNorm].matches++;
        teamStats[aNorm].matches++;
        if(won){
          teamStats[hNorm].wins++;
          teamStats[aNorm].wins++;
          // Note: we count a win toward BOTH teams ‚Äî this matches earlier behavior requested by you.
        }
        teamStats[hNorm].profit += gain;
        teamStats[aNorm].profit += gain;
      }
    }
  }

  // summary
  const globalROI = processedCount > 0 ? (totalProfit / (processedCount * STAKE)) * 100 : 0;
  $('summary').innerHTML = `<b>Historial:</b> ${processedCount} partidos con resultado ‚Ä¢ Profit total: ${totalProfit.toFixed(2)} ‚Ä¢ ROI global: ${globalROI.toFixed(2)}% (bank ref ${BANK_REF})`;

  renderTeamTable();
}

/* ------------------ RENDER TEAM TABLE ------------------ */
function renderTeamTable(){
  const tbody = $('teamTable').querySelector('tbody');
  tbody.innerHTML = '';

  // sort by profit desc
  const keys = Object.keys(teamStats).sort((a,b) => (teamStats[b].profit - teamStats[a].profit));
  for(const k of keys){
    const t = teamStats[k];
    const roiPct = t.matches > 0 ? (t.profit / (t.matches * STAKE)) * 100 : 0;
    const avgProfit = t.matches > 0 ? (t.profit / t.matches) : 0;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${t.display}</td><td>${t.matches}</td><td>${t.wins ?? 0}</td><td>${t.profit.toFixed(2)}</td><td class="${roiPct>=0?'good':'bad'}">${roiPct.toFixed(2)} %</td><td>${avgProfit.toFixed(3)}</td>`;
    tbody.appendChild(tr);
  }
}

/* ------------------ APPLY TO FUTUROS & PREDICT ------------------ */
function applyToFuturos(){
  const tbody = $('predTable').querySelector('tbody');
  tbody.innerHTML = '';

  for(const m of (futurosUploaded || [])){
    const match = m.Match ?? m.match ?? '';
    if(!match){
      log('Futuro sin campo Match -> ignorado.');
      continue;
    }
    const date = m.Date ?? m.date ?? '';
    const liga = m.League ?? m.league ?? '';

    const parts = match.split(' - ');
    const home = parts[0] ? parts[0].trim() : null;
    const away = parts[1] ? parts[1].trim() : null;

    const homeNorm = home ? normalizeName(home) : null;
    const awayNorm = away ? normalizeName(away) : null;

    const homeStats = (homeNorm && teamStats[homeNorm]) ? teamStats[homeNorm] : null;
    const awayStats = (awayNorm && teamStats[awayNorm]) ? teamStats[awayNorm] : null;

    const roiHome = homeStats && homeStats.matches>0 ? (homeStats.profit / (homeStats.matches * STAKE)) * 100 : null;
    const roiAway = awayStats && awayStats.matches>0 ? (awayStats.profit / (awayStats.matches * STAKE)) * 100 : null;
    const avgHome = homeStats && homeStats.matches>0 ? (homeStats.profit / homeStats.matches) : null;
    const avgAway = awayStats && awayStats.matches>0 ? (awayStats.profit / awayStats.matches) : null;

    // Recommendation logic
    let recommendation = 'Sin datos';
    let ev = null;
    if(avgHome !== null && avgAway !== null){
      ev = Math.max(avgHome, avgAway);
      recommendation = ev > 0 ? (avgHome > avgAway ? `${home} (Apostar)` : `${away} (Apostar)`) : 'No rentable (ev ‚â§ 0)';
    } else if(avgHome !== null){
      ev = avgHome;
      recommendation = avgHome > 0 ? `${home} (Apostar)` : 'No rentable (ev ‚â§ 0)';
    } else if(avgAway !== null){
      ev = avgAway;
      recommendation = avgAway > 0 ? `${away} (Apostar)` : 'No rentable (ev ‚â§ 0)';
    }

    const displayRoiHome = roiHome === null ? 'N/A' : roiHome.toFixed(2) + ' %';
    const displayRoiAway = roiAway === null ? 'N/A' : roiAway.toFixed(2) + ' %';
    const displayAvgHome = avgHome === null ? 'N/A' : avgHome.toFixed(3);
    const displayAvgAway = avgAway === null ? 'N/A' : avgAway.toFixed(3);
    const displayEV = ev === null ? 'N/A' : ev.toFixed(3);

    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${date}</td><td>${liga}</td><td>${match}</td>
                    <td class="${(roiHome||0)>=0?'good':'bad'}">${displayRoiHome}</td>
                    <td class="${(roiAway||0)>=0?'good':'bad'}">${displayRoiAway}</td>
                    <td>${displayAvgHome}</td>
                    <td>${displayAvgAway}</td>
                    <td>${displayEV}</td>
                    <td><b>${recommendation}</b></td>`;
    tbody.appendChild(tr);
  }
}

/* ------------------ CSV EXPORT ------------------ */
function exportPredictionsCSV(){
  const rows = [];
  rows.push(['Date','League','Match','ROI Local (%)','ROI Visitante (%)','AvgProfit Local','AvgProfit Visitante','EV','Recommendation']);
  const tbody = $('predTable').querySelector('tbody');
  for(const tr of tbody.querySelectorAll('tr')){
    const cols = Array.from(tr.children).map(td => td.innerText.replace(/\n/g,' ').trim());
    rows.push(cols);
  }
  if(rows.length <= 1){ log('No hay predicciones para exportar.'); return; }
  const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\r\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `predicciones_backtesting_${new Date().toISOString().slice(0,10)}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  log('CSV de predicciones generado.');
}

/* ------------------ RUN BUTTON ------------------ */
$('runBtn').addEventListener('click', () => {
  // validations
  if(!historialUploaded){ log('ERROR: debe cargar archivo HISTORIAL antes.'); $('summary').textContent = 'Carga el historial.'; return; }
  if(!futurosUploaded){ log('ERROR: debe cargar archivo FUTUROS antes.'); $('summary').textContent = 'Carga los partidos futuros.'; return; }

  // process
  log('Iniciando backtesting usando datos en memoria...');
  try {
    processHistorial();
    applyToFuturos();
    log('Backtesting finalizado correctamente.');
  } catch(err){
    log('ERROR durante backtesting: ' + (err && err.message ? err.message : err));
  }
});

/* ------------------ CSV BUTTON ------------------ */
$('csvBtn').addEventListener('click', exportPredictionsCSV);

/* ------------------ initial message ------------------ */
log('Interfaz lista. Sube los archivos y presiona "Hacer Backtesting".');
$('summary').textContent = 'Interfaz lista. Sube HISTORIAL y FUTUROS.';
</script>
</body>
</html>