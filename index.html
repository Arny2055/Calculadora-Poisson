<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Backtesting + Auto-Entrenamiento (Normal Bivariada)</title>
<style>
  body{margin:0;background:#0f1115;color:#e6eaf2;font:14px/1.45 system-ui,Inter,Segoe UI,Roboto,Arial}
  header{padding:14px 16px;border-bottom:1px solid #2a3140}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  .grid{display:grid;gap:16px}
  @media(min-width:980px){.grid{grid-template-columns:420px 1fr}}
  .card{background:#171a21;border:1px solid #2a3140;border-radius:12px;padding:14px}
  h1{font-size:18px;margin:0 0 6px} h2{font-size:15px;margin:0 0 10px}
  input,select,button{width:100%;background:#1f2430;color:#e6eaf2;border:1px solid #2a3140;border-radius:8px;padding:8px}
  .row{display:grid;grid-template-columns:1fr 220px;gap:8px;align-items:center;margin:8px 0}
  .btn{background:#7aa2ff;color:#0a1020;font-weight:700;cursor:pointer}
  .pill{display:inline-block;border:1px solid #2a3140;background:#1f2430;border-radius:999px;padding:4px 8px;margin:4px 6px 0 0}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #2a3140;padding:6px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  .muted{color:#9aa3b2;font-size:12px}
  .row2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
</style>
</head>
<body>
<header class="wrap">
  <h1>Backtesting + Auto-Entrenamiento — Normal Bivariada (EWMA, Round/Floor)</h1>
  <div class="muted">Importa JSON → elige liga/mercado → <b>Entrenar y fijar política</b> → <b>Correr Backtest</b>.</div>
</header>

<div class="wrap grid">
  <!-- Panel izquierdo -->
  <section class="card">
    <h2>Datos</h2>
    <div class="row"><label>Archivo JSON</label><input id="file" type="file" accept=".json"></div>
    <div class="row"><label>o Pegar JSON</label><button id="btnPaste" class="btn">Cargar portapapeles</button></div>
    <div class="row"><label>Liga</label><select id="league"><option value="">—</option></select></div>

    <h2>Mercado & Modelo</h2>
    <div class="row">
      <label>Mercado</label>
      <select id="market">
        <option value="OU">Over/Under</option>
        <option value="BTTS">BTTS (GG)</option>
        <option value="1X2">1X2 (mejor EV)</option>
      </select>
    </div>
    <div class="row" id="ouRow"><label>Línea O/U</label><input id="ou" type="number" step="0.5" value="2.5"></div>

    <div class="row"><label>α (EWMA)</label><input id="alpha" type="number" min="0" max="0.99" step="0.01" value="0.15"></div>
    <div class="row"><label>Discretización</label>
      <select id="disc"><option value="round">Round</option><option value="floor">Floor</option></select>
    </div>
    <div class="row"><label>EV mínimo</label><input id="evThr" type="number" step="0.01" value="0.02"></div>

    <div class="row"><label>Simulaciones</label><input id="nsims" type="number" min="4000" step="1000" value="12000"></div>
    <div class="row"><label>Mín. historial</label><input id="minHist" type="number" min="3" value="8"></div>
    <div class="row"><label>Stake</label><input id="stake" type="number" step="0.1" value="1"></div>

    <div class="row2">
      <button id="train" class="btn">Entrenar y fijar política (AUTO)</button>
      <button id="run" class="btn">Correr Backtest</button>
    </div>

    <h2>Mapeo de cuotas (opcional)</h2>
    <div class="muted">Si tus campos difieren, indícalos (se prueban primero).</div>
    <div class="row"><label>Odd Over 2.5</label><input id="fOddOver" placeholder="Odd Over25 / OddOver25"></div>
    <div class="row"><label>Odd Under 2.5</label><input id="fOddUnder" placeholder="Odd Under25 / OddUnder25"></div>
    <div class="row"><label>Odd BTTS (Sí)</label><input id="fOddBTTS" placeholder="Odd BTTS / Odd GG / Odd"></div>
    <div class="row"><label>Odd 1</label><input id="fOdd1" placeholder="Odd 1 PreMatch"></div>
    <div class="row"><label>Odd X</label><input id="fOddX" placeholder="Odd X PreMatch"></div>
    <div class="row"><label>Odd 2</label><input id="fOdd2" placeholder="Odd 2 PreMatch"></div>

    <p class="muted" id="info">—</p>
  </section>

  <!-- Panel derecho -->
  <section class="card">
    <h2>Resultados</h2>
    <div id="badges" class="muted">—</div>
    <div style="margin-top:8px">
      <span class="pill">Bets: <b id="bets">—</b></span>
      <span class="pill">Aciertos: <b id="hits">—</b></span>
      <span class="pill">Hit Rate: <b id="hr">—</b></span>
      <span class="pill">Unidades: <b id="units">—</b></span>
      <span class="pill">ROI: <b id="roi">—</b></span>
    </div>
    <h3 style="margin-top:12px;font-size:14px">Detalle (top 200 cronológico)</h3>
    <table id="tbl"><thead><tr>
      <th>Fecha</th><th>Partido</th><th>Mercado</th><th>Odd</th><th>p̂</th><th>EV</th><th>Res</th><th>Win</th>
    </tr></thead><tbody></tbody></table>
    <div style="margin-top:10px"><button id="btnCsv" class="btn">Descargar CSV</button></div>
  </section>
</div>

<script>
// ========= Utilidades básicas =========
const el=id=>document.getElementById(id);
const pct=x=>(x*100).toFixed(2)+'%';
const fmt=x=>(isFinite(x)?x.toFixed(3):'—');

function parseFT(s){const m=String(s||'').match(/(-?\d+)\s*[-:]\s*(-?\d+)/);return m?[+m[1],+m[2]]:[null,null];}
function parseDateAny(s){const d=new Date(s); if(!isNaN(d)) return d; return new Date(NaN);}

function mean(a){return a.reduce((s,x)=>s+x,0)/a.length;}
function variance(a,mu){let s=0; for(const x of a)s+=(x-mu)*(x-mu); return s/Math.max(1,a.length-1);}
function covariance(X,Y,mx,my){let s=0; for(let i=0;i<X.length;i++) s+=(X[i]-mx)*(Y[i]-my); return s/Math.max(1,X.length-1);}

function ewmaWeights(n,a){ if(a<=0)return null; const w=[]; for(let i=0;i<n;i++) w.push(Math.pow(1-a,i)); w.reverse(); return w; }
function meanW(a,w){const sw=w.reduce((s,x)=>s+x,0); let t=0; for(let i=0;i<a.length;i++) t+=a[i]*w[i]; return t/(sw||1);}
function varW(a,mu,w){const sw=w.reduce((s,x)=>s+x,0),sw2=w.reduce((s,x)=>s+x*x,0); let s=0; for(let i=0;i<a.length;i++) s+=w[i]*(a[i]-mu)*(a[i]-mu); const c=sw-(sw2/sw); return s/Math.max(1e-9,c);}
function covW(X,Y,mx,my,w){const sw=w.reduce((s,a)=>s+a,0),sw2=w.reduce((s,a)=>s+a*a,0); let s=0; for(let i=0;i<X.length;i++) s+=w[i]*(X[i]-mx)*(Y[i]-my); const c=sw-(sw2/sw); return s/Math.max(1e-9,c);}

function simulateQuick(muH,muA,sdH,sdA,rho,ns,disc,ou){
  const s=Math.sqrt(1-Math.min(0.999,Math.max(-0.999,rho))**2);
  let pOver=0,pUnder=0,pBTTS=0,p1=0,pX=0,p2=0; let nEff=0;
  const randn=()=>{let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
  const nPairs=Math.max(1,Math.floor(ns/2));
  for(let j=0;j<nPairs;j++){
    const z1=randn(), z2=randn();
    for(const aSign of [1,-1]){
      const X=muH+sdH*(aSign*z1), Y=muA+sdA*(rho*(aSign*z1)+s*(aSign*z2));
      const H=Math.max(0,disc==='round'?Math.round(X):Math.floor(X));
      const A=Math.max(0,disc==='round'?Math.round(Y):Math.floor(Y));
      if(H+A>ou)pOver++; else pUnder++;
      if(H>0&&A>0)pBTTS++;
      if(H>A)p1++; else if(H===A)pX++; else p2++;
      nEff++;
    }
  }
  return {pOver:pOver/nEff,pUnder:pUnder/nEff,pBTTS:pBTTS/nEff,p1:p1/nEff,pX:pX/nEff,p2:p2/nEff};
}

// ========= Estado y carga =========
let RAW=[], BY_LEAGUE=new Map();

el('file').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f)return;
  try{ingest(JSON.parse(await f.text()));}catch(err){alert('Error JSON: '+err);}
});
el('btnPaste').addEventListener('click', async ()=>{
  try{ingest(JSON.parse(await navigator.clipboard.readText()));}catch(err){alert('Portapapeles: '+err);}
});
el('market').addEventListener('change', ()=>{el('ouRow').style.display=(el('market').value==='OU')?'':'none';});

function ingest(arr){
  RAW=[]; BY_LEAGUE.clear();
  for(const r of arr){
    const league=String(r.League||'').trim(); if(!league) continue;
    const [h,a]=parseFT(r["Result FT"]||r.Result);
    const date=parseDateAny(r.Date||r.date||'');
    const match=String(r.Match||'').trim();
    if(!Number.isFinite(h)||!Number.isFinite(a)||isNaN(date)) continue;
    const row={league,date,match,h,a,raw:r};
    RAW.push(row);
    if(!BY_LEAGUE.has(league)) BY_LEAGUE.set(league,[]);
    BY_LEAGUE.get(league).push(row);
  }
  for(const rows of BY_LEAGUE.values()) rows.sort((x,y)=>x.date-y.date);
  el('league').innerHTML='<option value="">—</option>'+Array.from(BY_LEAGUE.keys()).sort().map(l=>`<option>${l}</option>`).join('');
  el('info').textContent=`Cargados ${RAW.length} partidos en ${BY_LEAGUE.size} ligas.`;
}

// ========= Odds helpers =========
function getOdds_OU(r, fOver, fUnder, line){
  const o=r.raw;
  const cO=[fOver,'Odd Over25','OddOver25','Over25','Over 2.5','OddOver2_5','OddOver2.5'].filter(Boolean);
  const cU=[fUnder,'Odd Under25','OddUnder25','Under25','Under 2.5','OddUnder2_5','OddUnder2.5'].filter(Boolean);
  const over=cO.map(k=>+o[k]).find(x=>x>1.01)||null, under=cU.map(k=>+o[k]).find(x=>x>1.01)||null;
  return {over,under,line};
}
function getOdds_BTTS(r, fBTTS){
  const o=r.raw; const c=[fBTTS,'Odd BTTS','OddBTTS','Odd GG','OddGG','Odd'].filter(Boolean);
  const yes=c.map(k=>+o[k]).find(x=>x>1.01)||null; return {yes};
}
function getOdds_1X2(r, f1,fX,f2){
  const o=r.raw;
  const o1=+o[f1]||+o['Odd 1 PreMatch']||null;
  const ox=+o[fX]||+o['Odd X PreMatch']||null;
  const o2=+o[f2]||+o['Odd 2 PreMatch']||null;
  return {o1:o1>1.01?o1:null, ox:ox>1.01?ox:null, o2:o2>1.01?o2:null};
}

// ========= Web Worker (rápido para backtest) =========
const workerSrc = `
let seed=0x9e3779b9; function mulberry32(){let t=seed+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}
function randn(){let u1=mulberry32(); if(u1<=1e-12) u1=1e-12; const u2=mulberry32(); const r=Math.sqrt(-2*Math.log(u1)), th=6.283185307179586*u2; return [r*Math.cos(th), r*Math.sin(th)];}
onmessage = e=>{
  const {jobs} = e.data; const out=[];
  for(const jb of jobs){
    seed = (jb.seed|0)>>>0;
    const {muH,muA,sdH,sdA,rho,ns,disc,ou} = jb;
    const s=Math.sqrt(Math.max(1e-12,1-rho*rho));
    let over=0,btts=0,wH=0,d=0,wA=0;
    const nPairs=Math.max(1,Math.floor(ns/2));
    for(let i=0;i<nPairs;i++){
      const [z1,z2]=randn();
      for(const aSign of [1,-1]){
        const X=muH+sdH*(aSign*z1), Y=muA+sdA*(rho*(aSign*z1)+s*(aSign*z2));
        const H = disc==='round'? Math.max(0,Math.round(X)) : Math.max(0,Math.floor(X));
        const A = disc==='round'? Math.max(0,Math.round(Y)) : Math.max(0,Math.floor(Y));
        if(H+A>ou) over++; if(H>0&&A>0) btts++;
        if(H>A) wH++; else if(H===A) d++; else wA++;
      }
    }
    const nTot=nPairs*2;
    out.push({id:jb.id,pOver:over/nTot,pUnder:1-over/nTot,pBTTS:btts/nTot,p1:wH/nTot,pX:d/nTot,p2:wA/nTot});
  }
  postMessage(out);
};`;
const worker = new Worker(URL.createObjectURL(new Blob([workerSrc],{type:'application/javascript'})));

// ========= Entrenamiento (grid) =========
function statsROI(trades, stake=1){
  if(trades.length===0) return {roi:0, units:0, sharpe:0};
  const pnl = trades.map(t=> t.win ? stake*(t.odd-1) : -stake);
  const units = pnl.reduce((s,x)=>s+x,0);
  const roi = units/(trades.length*stake);
  const mu = pnl.reduce((s,x)=>s+x,0)/pnl.length;
  const sd = Math.sqrt(pnl.reduce((s,x)=>s+(x-mu)**2,0)/Math.max(1,pnl.length-1));
  return {roi, units, sharpe: sd>0 ? mu/sd : 0};
}

async function backtestConfig(rows, market, ouLine, alpha, disc, evThr, ns, minHist, oddsMap){
  const trades=[]; const H=[],A=[];
  for(let i=0;i<rows.length;i++){
    const r=rows[i];
    if(H.length<minHist){ H.push(r.h); A.push(r.a); continue; }

    // parámetros
    let muH,muA,sdH,sdA,cov,rho;
    if(alpha>0){
      const w=ewmaWeights(H.length,alpha), sw=w.reduce((s,x)=>s+x,0), sw2=w.reduce((s,x)=>s+x*x,0);
      muH=meanW(H,w); muA=meanW(A,w);
      const vH=varW(H,muH,w), vA=varW(A,muA,w);
      const c=covW(H,A,muH,muA,w);
      sdH=Math.sqrt(Math.max(1e-9,vH)); sdA=Math.sqrt(Math.max(1e-9,vA));
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }else{
      muH=mean(H); muA=mean(A);
      sdH=Math.sqrt(Math.max(1e-9,variance(H,muH)));
      sdA=Math.sqrt(Math.max(1e-9,variance(A,muA)));
      const c=covariance(H,A,muH,muA);
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }

    const sim = simulateQuick(muH,muA,sdH,sdA,rho,Math.min(ns,8000),disc,ouLine); // ns de entrenamiento limitado

    let bet=null, odd=null, p=null, win=0;
    if(market==='OU'){
      const {over,under}=getOdds_OU(r,oddsMap.fOver,oddsMap.fUnder,ouLine);
      const cand=[]; if(over)  cand.push({lab:'Over '+ouLine, p:sim.pOver,  odd:over,  win:(r.h+r.a>ouLine)?1:0});
                      if(under) cand.push({lab:'Under '+ouLine,p:sim.pUnder, odd:under, win:(r.h+r.a<=ouLine)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p));
      cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0];
      if(pick && pick.ev>=evThr){ bet=pick.lab; p=pick.p; odd=pick.odd; win=pick.win; }
    }else if(market==='BTTS'){
      const {yes}=getOdds_BTTS(r,oddsMap.fBTTS);
      if(yes){
        const pBTTS=sim.pBTTS, ev=pBTTS*(yes-1)-(1-pBTTS);
        if(ev>=evThr){ bet='BTTS Sí'; p=pBTTS; odd=yes; win=(r.h>0&&r.a>0)?1:0; }
      }
    }else{
      const {o1,ox,o2}=getOdds_1X2(r,oddsMap.f1,oddsMap.fX,oddsMap.f2);
      const cand=[]; if(o1)cand.push({lab:'1',p:sim.p1,odd:o1,win:(r.h>r.a)?1:0});
                     if(ox)cand.push({lab:'X',p:sim.pX,odd:ox,win:(r.h===r.a)?1:0});
                     if(o2)cand.push({lab:'2',p:sim.p2,odd:o2,win:(r.h<r.a)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p));
      cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0];
      if(pick && pick.ev>=evThr){ bet=pick.lab; p=pick.p; odd=pick.odd; win=pick.win; }
    }
    if(bet) trades.push({odd,win});
    H.push(r.h); A.push(r.a);
  }
  return statsROI(trades, 1);
}

async function entrenarYSeleccionar(rows, market, ouLine, ns, minHist, oddsMap){
  const ALPHAS=[0.05,0.10,0.15,0.20];
  const DISCS =['round','floor'];
  const EVS   =[0.00,0.02,0.04];

  let best=null;
  for(const alpha of ALPHAS){
    for(const disc of DISCS){
      for(const evThr of EVS){
        const r = await backtestConfig(rows, market, ouLine, alpha, disc, evThr, ns, minHist, oddsMap);
        const score = 0.7*r.roi + 0.3*r.sharpe;
        if(!best || score>best.score){
          best = {alpha, disc, evThr, roi:r.roi, sharpe:r.sharpe, score};
        }
      }
    }
  }
  return best;
}

// ========= Botones =========
el('train').addEventListener('click', async ()=>{
  const L=el('league').value; if(!L){alert('Elige una liga.');return;}
  const rows=(BY_LEAGUE.get(L)||[]).slice(); if(rows.length< +el('minHist').value + 5){alert('Muy pocos partidos para entrenar.');return;}

  const market=el('market').value; const ou=+el('ou').value||2.5;
  const ns=+el('nsims').value||12000; const minHist=Math.max(3,+el('minHist').value||8);
  const oddsMap={
    fOver:el('fOddOver').value.trim(), fUnder:el('fOddUnder').value.trim(),
    fBTTS:el('fOddBTTS').value.trim(), f1:el('fOdd1').value.trim(),
    fX:el('fOddX').value.trim(), f2:el('fOdd2').value.trim()
  };

  el('info').textContent='Entrenando (rejilla α × disc × EV)…';
  const best = await entrenarYSeleccionar(rows, market, ou, ns, minHist, oddsMap);
  el('alpha').value = best.alpha.toFixed(2);
  el('disc').value  = best.disc;
  el('evThr').value = best.evThr.toFixed(2);
  el('info').textContent = `Política fijada → α=${best.alpha.toFixed(2)}, disc=${best.disc}, EV≥${best.evThr.toFixed(2)} | ROI=${pct(best.roi)} Sharpe=${fmt(best.sharpe)}`;
});

// Backtest rápido con Worker
el('run').addEventListener('click', ()=>{
  const L=el('league').value; if(!L){alert('Elige una liga.');return;}
  const rows=(BY_LEAGUE.get(L)||[]).slice();
  const ns=Math.max(4000,Math.floor(+el('nsims').value||12000));
  const alpha=Math.max(0,Math.min(0.99,+el('alpha').value||0.15));
  const disc=el('disc').value;
  const ou=+el('ou').value||2.5;
  const minHist=Math.max(3,Math.floor(+el('minHist').value||8));
  const stake=+el('stake').value||1;
  const market=el('market').value;
  const evMin=+el('evThr').value||0;

  const fOver=el('fOddOver').value.trim(), fUnder=el('fOddUnder').value.trim();
  const fBTTS=el('fOddBTTS').value.trim();
  const f1=el('fOdd1').value.trim(), fX=el('fOddX').value.trim(), f2=el('fOdd2').value.trim();

  // precompute histórico incremental
  const Hcum=[], Acum=[];
  for(let i=0;i<rows.length;i++){
    Hcum.push(rows.slice(0,i).map(x=>x.h));
    Acum.push(rows.slice(0,i).map(x=>x.a));
  }

  const jobs=[], oddsCache=[];
  for(let i=0;i<rows.length;i++){
    if(i<minHist) { oddsCache.push(null); continue; }
    const H=Hcum[i], A=Acum[i];
    let muH,muA,sdH,sdA,cov,rho;
    if(alpha>0){
      const w=ewmaWeights(H.length,alpha);
      muH=meanW(H,w); muA=meanW(A,w);
      const vH=varW(H,muH,w), vA=varW(A,muA,w), c=covW(H,A,muH,muA,w);
      sdH=Math.sqrt(Math.max(1e-9,vH)); sdA=Math.sqrt(Math.max(1e-9,vA));
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }else{
      muH=mean(H); muA=mean(A);
      sdH=Math.sqrt(Math.max(1e-9,variance(H,muH)));
      sdA=Math.sqrt(Math.max(1e-9,variance(A,muA)));
      const c=covariance(H,A,muH,muA);
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }
    jobs.push({id:i,seed:(1234567+i*97)>>>0,muH,muA,sdH,sdA,rho,ns,disc,ou});

    // odds por partido
    if(market==='OU') oddsCache.push(getOdds_OU(rows[i],fOver,fUnder,ou));
    else if(market==='BTTS') oddsCache.push(getOdds_BTTS(rows[i],fBTTS));
    else oddsCache.push(getOdds_1X2(rows[i],f1,fX,f2));
  }

  let bets=0,hits=0,units=0;
  const outRows=[];
  worker.onmessage = (ev)=>{
    const res=new Map(ev.data.map(o=>[o.id,o]));
    for(const jb of jobs){
      const i=jb.id; const r=rows[i]; const sim=res.get(i); if(!sim) continue;
      let bet=null, odd=null, p=null, win=0, result='';
      if(market==='OU'){
        const {over,under,line}=oddsCache[i]; const cand=[];
        if(over)  cand.push({lab:'Over '+line,  p:sim.pOver,  odd:over,  win:(r.h+r.a>line)?1:0});
        if(under) cand.push({lab:'Under '+line, p:sim.pUnder, odd:under, win:(r.h+r.a<=line)?1:0});
        cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
        const pick=cand[0]; if(pick && pick.ev>=evMin){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;}
        result=(r.h+r.a)+'g';
      }else if(market==='BTTS'){
        const {yes}=oddsCache[i];
        if(yes){ const pBTTS=sim.pBTTS, ev=pBTTS*(yes-1)-(1-pBTTS); if(ev>=evMin){bet='BTTS Sí'; p=pBTTS; odd=yes; win=(r.h>0&&r.a>0)?1:0;}}
        result=r.h+'-'+r.a;
      }else{
        const {o1,ox,o2}=oddsCache[i];
        const cand=[]; if(o1)cand.push({lab:'1',p:sim.p1,odd:o1,win:(r.h>r.a)?1:0});
                       if(ox)cand.push({lab:'X',p:sim.pX,odd:ox,win:(r.h===r.a)?1:0});
                       if(o2)cand.push({lab:'2',p:sim.p2,odd:o2,win:(r.h<r.a)?1:0});
        cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
        const pick=cand[0]; if(pick && pick.ev>=evMin){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;}
        result=r.h+'-'+r.a;
      }
      if(bet){
        bets++; hits+=win;
        const pnl=win? stake*(odd-1) : -stake; units+=pnl;
        outRows.push({date:r.date.toISOString().slice(0,10), match:r.match, market:bet, odd:odd?.toFixed(2),
                      p_hat:p?.toFixed(3), EV:(p*(odd-1)-(1-p)).toFixed(3), result, win:win?'✔':'✖'});
      }
    }
    const roi = bets? (units/(bets*stake)) : 0;
    el('bets').textContent=bets; el('hits').textContent=hits; el('hr').textContent=bets?pct(hits/bets):'—';
    el('units').textContent=fmt(units); el('roi').textContent=bets?pct(roi):'—';
    el('badges').innerHTML=`<span class="pill">Liga: <b>${L}</b></span>
      <span class="pill">Mercado: <b>${market}</b></span>
      <span class="pill">α: <b>${alpha}</b></span>
      <span class="pill">Disc: <b>${disc}</b></span>
      <span class="pill">EV≥ <b>${evMin}</b></span>
      <span class="pill">#Sims: <b>${ns}</b></span>
      <span class="pill">MinHist: <b>${minHist}</b></span>`;

    const tb=document.querySelector('#tbl tbody');
    tb.innerHTML = outRows.slice(0,200).map(r=>`<tr>
      <td>${r.date}</td><td>${r.match}</td><td>${r.market}</td>
      <td>${r.odd}</td><td>${r.p_hat}</td><td>${r.EV}</td><td>${r.result}</td><td>${r.win}</td>
    </tr>`).join('') || `<tr><td colspan="8" class="muted">No hubo apuestas con EV ≥ umbral.</td></tr>`;

    el('btnCsv').onclick=()=>{
      const rowsCsv=[['date','match','market','odd','p_hat','EV','result','win']]
        .concat(outRows.map(r=>[r.date,r.match,r.market,r.odd,r.p_hat,r.EV,r.result,r.win]));
      const csv=rowsCsv.map(r=>r.join(',')).join('\n');
      const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'});
      const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`backtest_${L}_${market}.csv`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    };
  };

  el('info').textContent='Backtest corriendo en segundo plano…';
  worker.postMessage({jobs});
});
</script>
</body>
</html>