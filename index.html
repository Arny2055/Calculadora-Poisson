<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öΩÔ∏è Analizador de Probabilidades de Goles (Largo y Corto Plazo)</title>
    <style>
        /* --- Estilos CSS --- */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #eef2f7; }
        .container { background: #ffffff; padding: 30px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        input[type="file"], button, select { 
            width: 100%; padding: 12px; margin: 10px 0; border-radius: 6px; 
            border: 1px solid #dcdfe6; box-sizing: border-box; font-size: 16px;
        }
        input[type="file"] { background-color: #f7f9fb; }
        button { 
            background-color: #007bff;
            color: white; 
            cursor: pointer; 
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #0056b3; }
        hr { border: 0; border-top: 1px solid #eee; margin: 20px 0; }
        .result-box { 
            margin-top: 25px; padding: 20px; border: 3px solid #333; 
            border-radius: 8px; background-color: #fff;
        }
        .analysis { 
            background: #fff8e1;
            padding: 15px; border-left: 5px solid #ffc107;
            margin-top: 20px; border-radius: 4px;
        }
        h2 { text-align: center; color: #333; margin-bottom: 25px; }
        p strong { color: #333; }
        .info { font-size: 0.9em; color: #6c757d; margin-top: -5px; }
    </style>
</head>
<body>

    <div class="container">
        <h2>‚öΩÔ∏è An√°lisis Predictivo de Goles</h2>

        <label for="jsonFile">**1. Cargar Historial de Partidos (JSON):**</label>
        <input type="file" id="jsonFile" accept=".json">
        <p class="info">El script usar√° el rendimiento hist√≥rico de cada equipo en la liga.</p>

        <hr>

        <label for="leagueSelect">**2. Seleccionar Liga:**</label>
        <select id="leagueSelect" onchange="populateTeams()" disabled>
            <option value="">Cargue el archivo primero...</option>
        </select>

        <label for="localTeam">**3. Equipo Local:**</label>
        <select id="localTeam" disabled>
            <option value="">Seleccione la liga para ver los equipos</option>
        </select>

        <label for="visitorTeam">**4. Equipo Visitante:**</label>
        <select id="visitorTeam" disabled>
            <option value="">Seleccione la liga para ver los equipos</option>
        </select>
        
        <p class="info">‚ö†Ô∏è An√°lisis basado en rendimiento **hist√≥rico (Largo Plazo)** y **√∫ltimos 10 partidos (Corto Plazo)**.</p>

        <button onclick="analyzeData()">Analizar Probabilidades</button>

        <hr>

        <div id="results" class="result-box" style="display: none;">
            <h3>üìä Predicci√≥n de Goles (Modelo de Ataque/Defensa)</h3>
            <p><strong>Goles Esperados (Media Ponderada):</strong> <span id="xGoals"></span></p>
            <p><strong>Probabilidad de M√°s de 2.5 Goles:</strong> <span id="prob25"></span></p>
            <p><strong>Probabilidad de Ambos Anotan (BTTS):</strong> <span id="probBTTS"></span></p>

            <div class="analysis">
                <h4>üß† Desglose del An√°lisis (Largo vs. Corto Plazo):</h4>
                <p id="personalAnalysis"></p>
            </div>
        </div>

    </div>

    <script>
        // --- Constantes para la ponderaci√≥n del an√°lisis ---
        const RECENT_MATCH_COUNT = 10; // Definici√≥n del "Corto Plazo" (√∫ltimos N partidos)
        const WEIGHT_RECENT = 0.6; // Peso dado a los √∫ltimos 10 partidos (60%)
        const WEIGHT_HISTORICAL = 0.4; // Peso dado al historial completo (40%)


        let matchHistory = [];
        const leagueSelect = document.getElementById('leagueSelect');
        const localTeamSelect = document.getElementById('localTeam');
        const visitorTeamSelect = document.getElementById('visitorTeam');

        /**
         * Funci√≥n para limpiar, mapear y normalizar los datos del JSON.
         */
        function cleanAndMapData(data) {
            
            const cleanedData = data.map(match => {
                const matchString = match.Match ? String(match.Match).trim() : null;
                const resultString = match['Result FT'] ? String(match['Result FT']).trim() : null;
                
                let local = '';
                let visitante = '';
                let golesLocal = 0;
                let golesVisitante = 0;
                
                if (matchString && matchString.includes(' - ')) {
                    const parts = matchString.split(' - ').map(p => p.trim());
                    if (parts.length === 2) {
                        local = parts[0];
                        visitante = parts[1];
                    }
                }
                
                if (resultString && resultString.includes('-')) {
                    const scoreParts = resultString.split('-').map(p => parseInt(p.trim()));
                    if (scoreParts.length === 2 && !isNaN(scoreParts[0]) && !isNaN(scoreParts[1])) {
                        golesLocal = scoreParts[0];
                        golesVisitante = scoreParts[1];
                    }
                }
                
                return {
                    // Mantener el resto de datos, pero necesitamos la fecha si queremos un an√°lisis riguroso de "recientes"
                    ...match, 
                    liga: match.League ? String(match.League).trim() : 'Sin Liga',
                    local: local,
                    visitante: visitante,
                    golesLocal: golesLocal,
                    golesVisitante: golesVisitante,
                    // Intentamos obtener una fecha para ordenar los partidos
                    date: new Date(match.Date), 
                    rawDate: match.Date
                };
            });
            
            // Filtramos y ordenamos por fecha (asumiendo que 'Date' es v√°lido y queremos los m√°s recientes al final)
            const validMatches = cleanedData
                .filter(match => match.local && match.visitante && !isNaN(match.golesLocal) && !isNaN(match.date))
                .sort((a, b) => a.date - b.date);
            
            return validMatches;
        }

        // Manejador para la carga de archivo JSON
        document.getElementById('jsonFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const rawData = JSON.parse(e.target.result);
                        const dataArray = Array.isArray(rawData) ? rawData : [rawData];
                        
                        matchHistory = cleanAndMapData(dataArray);
                        
                        if (matchHistory.length === 0) {
                             alert("‚ö†Ô∏è Archivo JSON cargado, pero no se encontraron partidos v√°lidos. Revisa el formato y la fecha.");
                        } else {
                            alert(`‚úÖ ¬°Archivo cargado! ${matchHistory.length} partidos listos para analizar.`);
                            populateLeagueSelector();
                        }
                    } catch (error) {
                        alert("‚ùå Error al parsear el archivo JSON. Aseg√∫rate de que el formato sea correcto.");
                        console.error("Error de parseo JSON:", error);
                        matchHistory = []; 
                        leagueSelect.disabled = true;
                    }
                };
                reader.readAsText(file);
            }
        });

        // ---------------------------------------------
        // FUNCIONES DE INTERFAZ (SELECTS)
        // ---------------------------------------------

        function populateLeagueSelector() {
            const uniqueLeagues = new Set();
            matchHistory.forEach(match => uniqueLeagues.add(match.liga));

            leagueSelect.innerHTML = '<option value="">-- Seleccione una Liga --</option>';
            uniqueLeagues.forEach(league => {
                const option = document.createElement('option');
                option.value = league;
                option.textContent = league;
                leagueSelect.appendChild(option);
            });
            
            leagueSelect.disabled = false;
            localTeamSelect.disabled = true;
            visitorTeamSelect.disabled = true;
        }

        function populateTeams() {
            const selectedLeague = leagueSelect.value;
            
            localTeamSelect.innerHTML = '';
            visitorTeamSelect.innerHTML = ''; 

            if (!selectedLeague) {
                localTeamSelect.disabled = true;
                visitorTeamSelect.disabled = true;
                localTeamSelect.innerHTML = '<option value="">Seleccione la liga para ver los equipos</option>';
                visitorTeamSelect.innerHTML = '<option value="">Seleccione la liga para ver los equipos</option>';
                return;
            }

            const leagueMatches = matchHistory.filter(match => match.liga === selectedLeague);
            const uniqueTeams = new Set();

            leagueMatches.forEach(match => {
                if (match.local) uniqueTeams.add(match.local);
                if (match.visitante) uniqueTeams.add(match.visitante);
            });
            
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "-- Seleccione un Equipo --";

            localTeamSelect.appendChild(defaultOption.cloneNode(true));
            visitorTeamSelect.appendChild(defaultOption.cloneNode(true));

            uniqueTeams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                localTeamSelect.appendChild(option.cloneNode(true));
                visitorTeamSelect.appendChild(option.cloneNode(true));
            });

            localTeamSelect.disabled = false;
            visitorTeamSelect.disabled = false;
        }


        // ---------------------------------------------
        // FUNCIONES DE C√ÅLCULO DE PLAZOS
        // ---------------------------------------------

        /**
         * Calcula el rendimiento (Ataque y Defensa) de un equipo en un conjunto de partidos.
         * @param {string} teamName - Nombre del equipo.
         * @param {string} opponentName - Nombre del oponente.
         * @param {Array<Object>} matches - Array de partidos a analizar.
         * @param {number} avgLeagueGoals - Goles promedio de toda la liga para normalizaci√≥n.
         * @returns {Object} { attackIndex, defenseIndex }
         */
        function calculateTeamIndices(teamName, opponentName, matches, avgLeagueGoals) {
            let matchesCount = 0;
            let scored = 0;
            let conceded = 0;
            
            if (matches.length === 0) {
                 return { attackIndex: 1, defenseIndex: 1 }; // Neutral si no hay datos
            }
            
            const teamLC = teamName.toLowerCase();

            matches.forEach(match => {
                const isLocal = match.local.toLowerCase() === teamLC;
                const isVisitor = match.visitante.toLowerCase() === teamLC;

                if (isLocal || isVisitor) {
                    matchesCount++;
                    
                    // Asegurarse de que no estamos contando goles en H2H si solo queremos el rendimiento del equipo
                    const G_scored = isLocal ? match.golesLocal : match.golesVisitante;
                    const G_conceded = isLocal ? match.golesVisitante : match.golesLocal;
                    
                    scored += G_scored;
                    conceded += G_conceded;
                }
            });

            if (matchesCount === 0) {
                return { attackIndex: 1, defenseIndex: 1 }; // Neutral si no jug√≥
            }

            const avgScored = scored / matchesCount;
            const avgConceded = conceded / matchesCount;

            // √çndice de Ataque = (Goles Anotados / Partidos) / (Goles Liga / Partidos Liga)
            const attackIndex = avgLeagueGoals > 0 ? (avgScored / avgLeagueGoals) : 1;
            // √çndice de Defensa = (Goles Recibidos / Partidos) / (Goles Liga / Partidos Liga)
            // Se invierte para que un √≠ndice bajo signifique una mejor defensa
            const defenseIndex = avgLeagueGoals > 0 ? (avgConceded / avgLeagueGoals) : 1;
            
            return {
                attackIndex: parseFloat(attackIndex.toFixed(3)), 
                defenseIndex: parseFloat(defenseIndex.toFixed(3)),
                matchesCount: matchesCount
            };
        }

        /**
         * Calcula la probabilidad de que se anote un n√∫mero espec√≠fico de goles (x)
         * utilizando la distribuci√≥n de Poisson.
         * @param {number} x - N√∫mero de goles.
         * @param {number} lambda - Goles esperados (media).
         * @returns {number} Probabilidad.
         */
        function poissonProbability(x, lambda) {
            if (lambda === 0) return x === 0 ? 1 : 0;
            // P(x; Œª) = (Œª^x * e^-Œª) / x!
            return (Math.pow(lambda, x) * Math.exp(-lambda)) / factorial(x);
        }

        /**
         * Calcula el factorial de un n√∫mero.
         */
        function factorial(n) {
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }

        // ---------------------------------------------
        // FUNCI√ìN PRINCIPAL DE AN√ÅLISIS
        // ---------------------------------------------

        function analyzeData() {
            const selectedLeague = leagueSelect.value;
            const localTeam = localTeamSelect.value.trim();
            const visitorTeam = visitorTeamSelect.value.trim();
            
            if (!localTeam || !visitorTeam || !selectedLeague) {
                alert("Por favor, selecciona la Liga, el Equipo Local y el Visitante.");
                return;
            }

            // 1. Filtrar partidos de la liga y calcular la media de goles de la liga (Largo Plazo Base)
            const leagueMatches = matchHistory.filter(match => match.liga === selectedLeague);
            
            let totalLeagueGoals = 0;
            leagueMatches.forEach(m => totalLeagueGoals += (m.golesLocal + m.golesVisitante));
            
            // Promedio de Goles de la Liga por partido
            const avgLeagueGoals = leagueMatches.length > 0 ? (totalLeagueGoals / leagueMatches.length) : 0;

            if (avgLeagueGoals === 0) {
                 alert("No hay suficientes datos de goles en esta liga para el an√°lisis.");
                 return;
            }

            // 2. Definir conjuntos de partidos
            // Partidos Hist√≥ricos (Largo Plazo)
            const historicalMatches = leagueMatches; 
            // Partidos Recientes (Corto Plazo): Los √∫ltimos N partidos de la liga.
            const recentMatches = leagueMatches.slice(-RECENT_MATCH_COUNT);
            
            // 3. Calcular √çndices para Largo Plazo
            const localIndicesHist = calculateTeamIndices(localTeam, visitorTeam, historicalMatches, avgLeagueGoals);
            const visitorIndicesHist = calculateTeamIndices(visitorTeam, localTeam, historicalMatches, avgLeagueGoals);
            
            // 4. Calcular √çndices para Corto Plazo (Reciente)
            const localIndicesRec = calculateTeamIndices(localTeam, visitorTeam, recentMatches, avgLeagueGoals);
            const visitorIndicesRec = calculateTeamIndices(visitorTeam, localTeam, recentMatches, avgLeagueGoals);
            
            // 5. Aplicar Ponderaci√≥n para obtener los √çndices Finales (Mediano Plazo)
            const localAttackFinal = (localIndicesHist.attackIndex * WEIGHT_HISTORICAL) + (localIndicesRec.attackIndex * WEIGHT_RECENT);
            const localDefenseFinal = (localIndicesHist.defenseIndex * WEIGHT_HISTORICAL) + (localIndicesRec.defenseIndex * WEIGHT_RECENT);
            
            const visitorAttackFinal = (visitorIndicesHist.attackIndex * WEIGHT_HISTORICAL) + (visitorIndicesRec.attackIndex * WEIGHT_RECENT);
            const visitorDefenseFinal = (visitorIndicesHist.defenseIndex * WEIGHT_HISTORICAL) + (visitorIndicesRec.defenseIndex * WEIGHT_RECENT);
            
            // 6. Calcular Goles Esperados (Lambda)
            
            // Goles esperados del Local (lambda_L) = Local_Ataque * Visitante_Defensa * Liga_Goles
            const lambdaLocal = localAttackFinal * visitorDefenseFinal * avgLeagueGoals;
            
            // Goles esperados del Visitante (lambda_V) = Visitante_Ataque * Local_Defensa * Liga_Goles
            const lambdaVisitor = visitorAttackFinal * localDefenseFinal * avgLeagueGoals;
            
            const totalXGoals = lambdaLocal + lambdaVisitor;

            // 7. Calcular Probabilidades (Poisson)
            
            // Simulaci√≥n hasta 5 goles (normalmente cubre > 99% de los casos)
            let probOver25 = 0;
            let probBTTS = 0;

            for (let G_local = 0; G_local <= 5; G_local++) {
                for (let G_visitor = 0; G_visitor <= 5; G_visitor++) {
                    
                    const P_local = poissonProbability(G_local, lambdaLocal);
                    const P_visitor = poissonProbability(G_visitor, lambdaVisitor);
                    const P_match = P_local * P_visitor;

                    // Probabilidad de M√°s de 2.5 Goles (P(Goles > 2))
                    if (G_local + G_visitor > 2) {
                        probOver25 += P_match;
                    }

                    // Probabilidad de Ambos Anotan (P(G_L > 0 AND G_V > 0))
                    if (G_local > 0 && G_visitor > 0) {
                        probBTTS += P_match;
                    }
                }
            }

            // --- 8. Mostrar Resultados ---
            document.getElementById('xGoals').textContent = `${localTeam}: ${lambdaLocal.toFixed(2)} | ${visitorTeam}: ${lambdaVisitor.toFixed(2)} (Total Esperado: ${totalXGoals.toFixed(2)})`;
            document.getElementById('prob25').textContent = `${(probOver25 * 100).toFixed(2)}%`;
            document.getElementById('probBTTS').textContent = `${(probBTTS * 100).toFixed(2)}%`;
            document.getElementById('results').style.display = 'block';

            // --- 9. An√°lisis Personalizado (Deducci√≥n) ---
            const analysisText = generatePlazosAnalysis(localTeam, visitorTeam, localIndicesHist, visitorIndicesHist, localIndicesRec, visitorIndicesRec, totalXGoals, avgLeagueGoals);
            document.getElementById('personalAnalysis').innerHTML = analysisText;
        }

        function generatePlazosAnalysis(localT, visitorT, lH, vH, lR, vR, xG, avgLG) {
            let analysis = `**Media Goles de la Liga (Largo Plazo Base):** ${avgLG.toFixed(2)} Goles. <br><br>`;
            
            analysis += `**An√°lisis de Plazos (${localT}):**<br>`;
            analysis += `* **Hist√≥rico (Largo Plazo):** Ataque: ${lH.attackIndex.toFixed(2)} | Defensa: ${lH.defenseIndex.toFixed(2)}<br>`;
            analysis += `* **Reciente (Corto Plazo, √öltimos ${RECENT_MATCH_COUNT}):** Ataque: ${lR.attackIndex.toFixed(2)} | Defensa: ${lR.defenseIndex.toFixed(2)}<br>`;

            if (lR.attackIndex > lH.attackIndex) {
                analysis += `  - üìà **Ataque en Forma:** El ataque de ${localT} ha **mejorado** recientemente.<br>`;
            } else if (lR.attackIndex < lH.attackIndex) {
                analysis += `  - üìâ **Ataque en Baja:** El ataque de ${localT} se ha **debilitado** recientemente.<br>`;
            }
            if (lR.defenseIndex < lH.defenseIndex) {
                analysis += `  - üõ°Ô∏è **Defensa S√≥lida:** La defensa de ${localT} ha **mejorado** (√≠ndice m√°s bajo).<br>`;
            } else if (lR.defenseIndex > lH.defenseIndex) {
                analysis += `  - üö® **Defensa D√©bil:** La defensa de ${localT} se ha **debilitado** (√≠ndice m√°s alto).<br>`;
            }
            
            analysis += `<br>**An√°lisis de Plazos (${visitorT}):**<br>`;
            analysis += `* **Hist√≥rico (Largo Plazo):** Ataque: ${vH.attackIndex.toFixed(2)} | Defensa: ${vH.defenseIndex.toFixed(2)}<br>`;
            analysis += `* **Reciente (Corto Plazo, √öltimos ${RECENT_MATCH_COUNT}):** Ataque: ${vR.attackIndex.toFixed(2)} | Defensa: ${vR.defenseIndex.toFixed(2)}<br>`;

            if (vR.attackIndex > vH.attackIndex) {
                analysis += `  - üìà **Ataque en Forma:** El ataque de ${visitorT} ha **mejorado** recientemente.<br>`;
            } else if (vR.attackIndex < vH.attackIndex) {
                analysis += `  - üìâ **Ataque en Baja:** El ataque de ${visitorT} se ha **debilitado** recientemente.<br>`;
            }
            if (vR.defenseIndex < vH.defenseIndex) {
                analysis += `  - üõ°Ô∏è **Defensa S√≥lida:** La defensa de ${visitorT} ha **mejorado** (√≠ndice m√°s bajo).<br>`;
            } else if (vR.defenseIndex > vH.defenseIndex) {
                analysis += `  - üö® **Defensa D√©bil:** La defensa de ${visitorT} se ha **debilitado** (√≠ndice m√°s alto).<br>`;
            }
            
            analysis += `<br>---<br>`;

            if (xG > 3.0) {
                 analysis += `**üî• Predicci√≥n Fuerte:** Los Goles Esperados (${xG.toFixed(2)}) son muy altos. Las tendencias recientes y el historial apuntan a un partido **muy abierto y de muchos goles**.`
            } else if (xG > 2.5) {
                 analysis += `**üü° Predicci√≥n Media:** Los Goles Esperados (${xG.toFixed(2)}) est√°n justo por encima de la l√≠nea. La combinaci√≥n de buen ataque y defensa d√©bil reciente podr√≠a forzar el **M√°s de 2.5 Goles**.`
            } else {
                 analysis += `**üßä Predicci√≥n Baja:** Los Goles Esperados (${xG.toFixed(2)}) est√°n por debajo de la l√≠nea. Los √≠ndices sugieren un partido **m√°s cerrado y con menos goles**.`
            }

            return analysis;
        }

    </script>
</body>
</html>
