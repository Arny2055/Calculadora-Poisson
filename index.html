<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Backtester Poisson — Soporta formato custom JSON</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; background:#f6f7fb; color:#111; }
    header { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
    h1 { margin:0; font-size:20px; }
    .card { background:white; padding:14px; border-radius:10px; box-shadow:0 6px 18px rgba(20,30,60,0.06); margin-bottom:12px; }
    label { display:block; margin:8px 0 6px; font-weight:600; font-size:13px; }
    select,input[type=file],button { padding:8px 10px; border-radius:8px; border:1px solid #d7dbe7; background:white; font-size:14px; }
    button { cursor:pointer; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    table { width:100%; border-collapse:collapse; margin-top:10px; font-size:13px; }
    th,td { padding:8px 6px; border-bottom:1px solid #eee; text-align:left; }
    th { background:#fafbff; font-weight:700; }
    .muted { color:#666; font-size:13px; }
    .stats { display:flex; gap:12px; margin-top:10px; flex-wrap:wrap; }
    .stat { background:#0f172a; color:white; padding:10px;border-radius:8px; min-width:140px; }
    .good { color: #0b6b3a; font-weight:700; }
    .bad { color: #b02a2a; font-weight:700; }
    pre { background:#0b1220; color:#dbeafe; padding:10px; border-radius:8px; overflow:auto; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Backtester Poisson — Over 2.5 &amp; BTTS (acepta JSON personalizado)</h1>
      <div class="muted">Carga tu JSON (formato clásico o el formato con "Match" y "Result FT") → Selecciona liga y equipos → Analizar</div>
    </div>
  </header>

  <div class="card">
    <label>Archivo JSON (acepta tu ejemplo con campos: Match, Date, Result FT, etc.)</label>
    <input id="fileInput" type="file" accept=".json" />
    <div style="margin-top:10px;" class="muted">
      Ejemplo de entrada soportada (tu modelo): <br>
      {"Match":"Flamengo - Bragantino","Date":"jue., 23 nov. 2023 18:30","League":"Brazil Serie A","Result FT":"1-0", ...}
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div style="flex:1">
        <label>Liga</label>
        <select id="leagueSelect"><option value="">-- carga un JSON primero --</option></select>
      </div>
      <div style="flex:1">
        <label>Local</label>
        <select id="homeSelect"><option value="">-- liga --</option></select>
      </div>
      <div style="flex:1">
        <label>Visitante</label>
        <select id="awaySelect"><option value="">-- liga --</option></select>
      </div>
      <div style="align-self:flex-end">
        <button id="analyzeBtn">Analizar Backtesting</button>
      </div>
    </div>
  </div>

  <div id="results" style="display:none;">
    <div class="card">
      <h3>Resumen</h3>
      <div class="stats" id="summaryStats"></div>
      <div style="margin-top:10px;">
        <button id="exportCsv">Exportar resultados a CSV</button>
      </div>
    </div>

    <div class="card">
      <h3>Resultados — Local (partidos en casa)</h3>
      <div id="homeResultsTable"></div>
    </div>

    <div class="card">
      <h3>Resultados — Visitante (partidos como visitante)</h3>
      <div id="awayResultsTable"></div>
    </div>

    <div class="card">
      <h3>Predicción para el partido seleccionado</h3>
      <div id="finalPrediction"></div>
    </div>

    <div class="card">
      <h3>Nota / metodología</h3>
      <div class="muted">
        - Se buscan 10 partidos previos del mismo equipo en la misma condición (home/away) antes de la fecha objetivo.<br>
        - Lambda = promedio de goles marcados en esas 10 partidas (según condicion).<br>
        - Modelo Poisson independiente; Over 2.5 y BTTS calculados desde las lambdas.<br>
        - Umbral por defecto: p ≥ 0.5 → predecir "Yes". Puedes cambiarlo en el código.
      </div>
    </div>
  </div>

<script>
/* backtester_v2.js — reconoce JSON custom (Match, Result FT, Date en español) o formato clásico */
let matches = [];
const fileInput = document.getElementById('fileInput');
const leagueSelect = document.getElementById('leagueSelect');
const homeSelect = document.getElementById('homeSelect');
const awaySelect = document.getElementById('awaySelect');
const analyzeBtn = document.getElementById('analyzeBtn');

// mapping meses español (abreviados con o sin punto)
const MONTHS_ES = {
  'ene':0,'ene.':0,
  'feb':1,'feb.':1,
  'mar':2,'mar.':2,
  'abr':3,'abr.':3,
  'may':4,'may.':4,
  'jun':5,'jun.':5,
  'jul':6,'jul.':6,
  'ago':7,'ago.':7,
  'sep':8,'sep.':8,'sept':8,'sept.':8,
  'oct':9,'oct.':9,
  'nov':10,'nov.':10,
  'dic':11,'dic.':11
};

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const text = await f.text();
  try {
    const raw = JSON.parse(text);
    if (!Array.isArray(raw)) throw new Error('JSON debe ser un array de partidos');
    // normalize each entry -> into the internal schema:
    // { date: Date, league: string, home_team, away_team, home_goals, away_goals }
    matches = raw.map(normalizeMatch).filter(m => m && m.date && m.date.toString() !== 'Invalid Date');
    matches.sort((a,b) => a.date - b.date);
    populateLeagueAndTeams();
    alert('Archivo cargado. Partidos reconocidos: ' + matches.length);
  } catch(err){
    alert('Error parseando JSON: ' + err.message);
    console.error(err);
  }
});

// normalizeMatch: accepts either classical fields or your custom example keys
function normalizeMatch(entry) {
  try {
    const e = {};
    // league detection (some JSON use "League" capitalized)
    e.league = entry.league || entry.League || entry.league_name || entry.LeagueName || '';
    // parse Match -> home / away
    const matchRaw = entry.Match || entry.match || entry['Match '] || '';
    if (matchRaw && typeof matchRaw === 'string' && matchRaw.includes('-')) {
      // split "Team A - Team B" (some spaces around dash)
      const parts = matchRaw.split('-').map(s => s.trim());
      e.home_team = parts[0] || (entry.home_team || entry.home || '');
      e.away_team = parts[1] || (entry.away_team || entry.away || '');
    } else {
      // fallback to explicit fields if present
      e.home_team = entry.home_team || entry.home || entry['Home'] || '';
      e.away_team = entry.away_team || entry.away || entry['Away'] || '';
    }
    // parse Result FT (e.g., "1-0") or explicit home_goals/away_goals
    const resFT = (entry['Result FT'] || entry['ResultFT'] || entry.result_ft || entry.result || entry['Result'] || '').toString().trim();
    if (resFT && resFT.includes('-')) {
      const parts = resFT.split('-').map(s => s.trim());
      e.home_goals = Number(parts[0]) || 0;
      e.away_goals = Number(parts[1]) || 0;
    } else {
      e.home_goals = Number(entry.home_goals ?? entry.homeGoals ?? entry['Home Goals'] ?? NaN);
      e.away_goals = Number(entry.away_goals ?? entry.awayGoals ?? entry['Away Goals'] ?? NaN);
      if (isNaN(e.home_goals)) e.home_goals = typeof entry.HomeTotal === 'number' ? entry.HomeTotal : 0;
      if (isNaN(e.away_goals)) e.away_goals = typeof entry.AwayTotal === 'number' ? entry.AwayTotal : 0;
    }

    // parse date: try direct Date parse, else try Spanish compact format "jue., 23 nov. 2023 18:30"
    const dateRaw = entry.Date || entry.date || entry.MatchDate || entry['Date '] || '';
    e.date = parseFlexibleDate(dateRaw);

    // final safety: if league/home/away missing try other keys
    if (!e.home_team) e.home_team = entry['Home Team'] || entry['HomeTeam'] || '';
    if (!e.away_team) e.away_team = entry['Away Team'] || entry['AwayTeam'] || '';

    // If still missing essential info, skip
    if (!e.league || !e.home_team || !e.away_team || !e.date) {
      // but we still include partial if home_goals/away_goals present and date present
      // console.debug('Skipping entry (incomplete):', entry);
      return null;
    }
    return e;
  } catch (err) {
    console.error('normalize error', err, entry);
    return null;
  }
}

// Robust date parser supporting e.g. "jue., 23 nov. 2023 18:30" and ISO
function parseFlexibleDate(s) {
  if (!s) return null;
  if (s instanceof Date) return s;
  s = s.toString().trim();
  // try native parse first
  const d1 = new Date(s);
  if (!isNaN(d1.getTime())) return d1;
  // remove day-of-week prefix if present "jue., " or "Thu, "
  let cleaned = s.replace(/^[^0-9]*,\s*/,'').replace(/^[A-Za-záéíóúñüÁÉÍÓÚÑÜ]+\.?,\s*/,'');
  // try pattern "23 nov. 2023 18:30" or "23 nov 2023 18:30"
  const re = /(\d{1,2})\s+([a-zA-ZñÑ\.]+)\s+(\d{4})\s+(\d{1,2}):(\d{2})/i;
  const m = cleaned.match(re);
  if (m) {
    const day = Number(m[1]);
    const monRaw = m[2].toLowerCase();
    const month = MONTHS_ES[monRaw] ?? MONTHS_ES[monRaw.replace(/\./,'')] ?? null;
    const year = Number(m[3]);
    const hour = Number(m[4]);
    const minute = Number(m[5]);
    if (month !== null && !isNaN(day)) {
      return new Date(year, month, day, hour, minute);
    }
  }
  // try pattern "23/11/2023 18:30" or "23-11-2023 18:30"
  const re2 = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})/;
  const m2 = cleaned.match(re2);
  if (m2) {
    const day = Number(m2[1]);
    const month = Number(m2[2]) - 1;
    let year = Number(m2[3]);
    if (year < 100) year += 2000;
    const hour = Number(m2[4]);
    const minute = Number(m2[5]);
    return new Date(year, month, day, hour, minute);
  }
  return null;
}

function populateLeagueAndTeams(){
  const leagues = Array.from(new Set(matches.map(m=>m.league))).sort();
  leagueSelect.innerHTML = '<option value="">-- seleccionar liga --</option>';
  for(const l of leagues){
    const opt = document.createElement('option'); opt.value = l; opt.textContent = l;
    leagueSelect.appendChild(opt);
  }
  homeSelect.innerHTML = '<option value="">-- liga --</option>';
  awaySelect.innerHTML = '<option value="">-- liga --</option>';
}

leagueSelect.addEventListener('change', () => {
  const league = leagueSelect.value;
  if(!league) {
    homeSelect.innerHTML = '<option value="">-- liga --</option>';
    awaySelect.innerHTML = '<option value="">-- liga --</option>';
    return;
  }
  const teams = Array.from(new Set(matches.filter(m=>m.league===league).flatMap(m=>[m.home_team,m.away_team]))).sort();
  homeSelect.innerHTML = '<option value="">-- seleccionar local --</option>';
  awaySelect.innerHTML = '<option value="">-- seleccionar visitante --</option>';
  for(const t of teams){
    const o1 = document.createElement('option'); o1.value=t; o1.textContent=t;
    const o2 = o1.cloneNode(true);
    homeSelect.appendChild(o1); awaySelect.appendChild(o2);
  }
});

analyzeBtn.addEventListener('click', () => {
  const league = leagueSelect.value;
  const homeTeam = homeSelect.value;
  const awayTeam = awaySelect.value;
  if(!league || !homeTeam || !awayTeam) { alert('Selecciona liga, local y visitante'); return; }
  runBacktest(league, homeTeam, awayTeam);
});

// Poisson helpers (same que antes)
function poissonP(k, lambda) {
  if (lambda <= 0) return k===0 ? 1 : 0;
  let p = Math.exp(-lambda);
  let num = 1;
  for(let i=0;i<k;i++) num *= lambda;
  let denom = 1;
  for(let i=1;i<=k;i++) denom *= i;
  return p * (num/denom);
}
function probTotalGreaterThanOrEqual3(lambdaH, lambdaA, maxG=10) {
  const probsH = [];
  for(let h=0; h<=maxG; h++) probsH[h] = poissonP(h, lambdaH);
  const probsA = [];
  for(let a=0; a<=maxG; a++) probsA[a] = poissonP(a, lambdaA);
  let prob = 0;
  for(let th=0; th<=maxG; th++){
    for(let ta=0; ta<=maxG; ta++){
      if(th + ta >= 3) prob += probsH[th] * probsA[ta];
    }
  }
  return prob;
}
function probBTTSYes(lambdaH, lambdaA) {
  const pHome0 = poissonP(0, lambdaH);
  const pAway0 = poissonP(0, lambdaA);
  return 1 - pHome0 - pAway0 + pHome0 * pAway0;
}
function round(x,d=3) {
  return Math.round(x * Math.pow(10,d)) / Math.pow(10,d);
}

// prior matches getter (same as antes pero usa matches normalizados)
function getPriorMatches(team, league, beforeDate, side /* 'home' or 'away' */, n=10) {
  const filtered = matches.filter(m => m.league===league && m.date < beforeDate && ((side==='home' && m.home_team===team) || (side==='away' && m.away_team===team)));
  filtered.sort((a,b)=> b.date - a.date);
  return filtered.slice(0,n);
}

function backtestForTeam(team, league, side) {
  const teamMatches = matches.filter(m => m.league===league && ((side==='home' && m.home_team===team) || (side==='away' && m.away_team===team)));
  teamMatches.sort((a,b)=> a.date - b.date);
  const results = [];
  for(let idx=0; idx<teamMatches.length; idx++){
    const target = teamMatches[idx];
    const prior = getPriorMatches(team, league, target.date, side, 10);
    if (prior.length < 10) continue;
    const opponent = side==='home' ? target.away_team : target.home_team;
    const opponentSide = side==='home' ? 'away' : 'home';
    const priorOpp = getPriorMatches(opponent, league, target.date, opponentSide, 10);
    if (priorOpp.length < 10) continue;
    const lambdaTeam = prior.reduce((s,m)=> s + (side==='home' ? m.home_goals : m.away_goals), 0) / prior.length;
    const lambdaOpp = priorOpp.reduce((s,m)=> s + (opponentSide==='home' ? m.home_goals : m.away_goals), 0) / priorOpp.length;
    const lambdaHome = side==='home' ? lambdaTeam : lambdaOpp;
    const lambdaAway = side==='home' ? lambdaOpp : lambdaTeam;
    const pOver = probTotalGreaterThanOrEqual3(lambdaHome, lambdaAway);
    const pBTTS = probBTTSYes(lambdaHome, lambdaAway);
    const predOver = pOver >= 0.5;
    const predBTTS = pBTTS >= 0.5;
    const actualOver = (target.home_goals + target.away_goals) > 2.5;
    const actualBTTS = (target.home_goals > 0) && (target.away_goals > 0);
    results.push({
      date: target.date.toISOString().slice(0,10),
      home_team: target.home_team,
      away_team: target.away_team,
      lambdaHome: round(lambdaHome,3),
      lambdaAway: round(lambdaAway,3),
      pOver: round(pOver,3),
      pBTTS: round(pBTTS,3),
      predOver,
      predBTTS,
      actualOver,
      actualBTTS
    });
  }
  const summary = {
    totalOver: results.length,
    correctOver: results.filter(r=>r.predOver === r.actualOver).length,
    totalBTTS: results.length,
    correctBTTS: results.filter(r=>r.predBTTS === r.actualBTTS).length
  };
  return {results, summary};
}

function runBacktest(league, homeTeam, awayTeam) {
  const homeAnalysis = backtestForTeam(homeTeam, league, 'home');
  const awayAnalysis = backtestForTeam(awayTeam, league, 'away');
  const lastDate = matches.reduce((mx,m)=>(m.date>mx?m.date:mx), new Date(0));
  const pseudoDate = new Date(lastDate.getTime() + 1000*60*60*24);
  const priorsHome = getPriorMatches(homeTeam, league, pseudoDate, 'home', 10);
  const priorsAway = getPriorMatches(awayTeam, league, pseudoDate, 'away', 10);
  let finalPrediction = {ok:false, reason:'Sin suficientes datos para predecir'};
  if (priorsHome.length >= 10 && priorsAway.length >= 10) {
    const lambdaH = priorsHome.reduce((s,m)=> s + m.home_goals,0) / priorsHome.length;
    const lambdaA = priorsAway.reduce((s,m)=> s + m.away_goals,0) / priorsAway.length;
    const pOver = probTotalGreaterThanOrEqual3(lambdaH, lambdaA);
    const pBTTS = probBTTSYes(lambdaH, lambdaA);
    finalPrediction = {
      ok:true,
      lambdaHome: round(lambdaH,3),
      lambdaAway: round(lambdaA,3),
      pOver: round(pOver,3),
      pBTTS: round(pBTTS,3),
      predOver: pOver >= 0.5 ? 'Over 2.5' : 'Under 2.5',
      predBTTS: pBTTS >= 0.5 ? 'BTTS Yes' : 'BTTS No'
    };
  }
  document.getElementById('results').style.display = 'block';
  renderSummary(homeTeam, awayTeam, homeAnalysis, awayAnalysis);
  renderResultsTable('homeResultsTable', homeAnalysis.results);
  renderResultsTable('awayResultsTable', awayAnalysis.results);
  renderFinalPrediction(finalPrediction, homeTeam, awayTeam);
  window._lastBacktest = {homeTeam, awayTeam, league, homeResults:homeAnalysis.results, awayResults:awayAnalysis.results, finalPrediction};
}

function renderSummary(homeTeam, awayTeam, homeAnalysis, awayAnalysis) {
  const s = document.getElementById('summaryStats');
  s.innerHTML = '';
  const make = (title, value) => {
    const d = document.createElement('div'); d.className='stat';
    d.innerHTML = `<div style="font-size:12px;color:#cbd5e1">${title}</div><div style="font-size:18px;margin-top:6px">${value}</div>`;
    return d;
  };
  const homeAccOver = homeAnalysis.summary.totalOver ? Math.round(100 * homeAnalysis.summary.correctOver / homeAnalysis.summary.totalOver) + '%' : 'N/A';
  const homeAccBTTS = homeAnalysis.summary.totalBTTS ? Math.round(100 * homeAnalysis.summary.correctBTTS / homeAnalysis.summary.totalBTTS) + '%' : 'N/A';
  const awayAccOver = awayAnalysis.summary.totalOver ? Math.round(100 * awayAnalysis.summary.correctOver / awayAnalysis.summary.totalOver) + '%' : 'N/A';
  const awayAccBTTS = awayAnalysis.summary.totalBTTS ? Math.round(100 * awayAnalysis.summary.correctBTTS / awayAnalysis.summary.totalBTTS) + '%' : 'N/A';
  s.appendChild(make(`Local: ${homeTeam} — acierto Over`, `${homeAccOver} (${homeAnalysis.summary.correctOver}/${homeAnalysis.summary.totalOver})`));
  s.appendChild(make(`Local: ${homeTeam} — acierto BTTS`, `${homeAccBTTS} (${homeAnalysis.summary.correctBTTS}/${homeAnalysis.summary.totalBTTS})`));
  s.appendChild(make(`Visitante: ${awayTeam} — acierto Over`, `${awayAccOver} (${awayAnalysis.summary.correctOver}/${awayAnalysis.summary.totalOver})`));
  s.appendChild(make(`Visitante: ${awayTeam} — acierto BTTS`, `${awayAccBTTS} (${awayAnalysis.summary.correctBTTS}/${awayAnalysis.summary.totalBTTS})`));
}

function renderResultsTable(containerId, results){
  const container = document.getElementById(containerId);
  if(!results || results.length===0) {
    container.innerHTML = '<div class="muted">Sin resultados (no hubo suficientes series de 10 precedentes en la muestra)</div>';
    return;
  }
  let html = `<table><thead><tr>
    <th>Fecha</th><th>Home</th><th>Away</th><th>&lambda;Home</th><th>&lambda;Away</th>
    <th>p(Over)</th><th>Pred Over</th><th>Real Over</th>
    <th>p(BTTS)</th><th>Pred BTTS</th><th>Real BTTS</th>
  </tr></thead><tbody>`;
  for(const r of results){
    html += `<tr>
      <td>${r.date}</td>
      <td>${r.home_team}</td>
      <td>${r.away_team}</td>
      <td>${r.lambdaHome}</td>
      <td>${r.lambdaAway}</td>
      <td>${r.pOver}</td>
      <td>${r.predOver ? 'Over' : 'Under'}</td>
      <td>${r.actualOver ? 'Over' : 'Under'}</td>
      <td>${r.pBTTS}</td>
      <td>${r.predBTTS ? 'Yes' : 'No'}</td>
      <td>${r.actualBTTS ? 'Yes' : 'No'}</td>
    </tr>`;
  }
  html += '</tbody></table>';
  container.innerHTML = html;
}

function renderFinalPrediction(pred, homeTeam, awayTeam){
  const el = document.getElementById('finalPrediction');
  if(!pred.ok) {
    el.innerHTML = `<div class="muted">No hay suficientes datos para predecir el partido ${homeTeam} vs ${awayTeam}. ${pred.reason || ''}</div>`;
    return;
  }
  el.innerHTML = `<div>
    <strong>${homeTeam} vs ${awayTeam}</strong>
    <div style="margin-top:8px;">
      &lambda; ${homeTeam} (home) = ${pred.lambdaHome} — &lambda; ${awayTeam} (away) = ${pred.lambdaAway}
    </div>
    <div style="margin-top:8px;">
      Probabilidad Over 2.5: <strong>${pred.pOver}</strong> → <span class="good">${pred.predOver}</span>
    </div>
    <div style="margin-top:6px;">
      Probabilidad BTTS Yes: <strong>${pred.pBTTS}</strong> → <span class="good">${pred.predBTTS}</span>
    </div>
  </div>`;
}

// CSV export
document.getElementById('exportCsv').addEventListener('click', ()=>{
  const data = window._lastBacktest;
  if(!data) { alert('No hay resultados para exportar'); return; }
  let rows = [];
  rows.push(['type','date','home','away','lambdaHome','lambdaAway','pOver','predOver','actualOver','pBTTS','predBTTS','actualBTTS'].join(','));
  for(const r of data.homeResults){
    rows.push(['homeAnalysis', r.date, r.home_team, r.away_team, r.lambdaHome, r.lambdaAway, r.pOver, r.predOver ? 'Over' : 'Under', r.actualOver ? 'Over' : 'Under', r.pBTTS, r.predBTTS ? 'Yes' : 'No', r.actualBTTS ? 'Yes' : 'No'].join(','));
  }
  for(const r of data.awayResults){
    rows.push(['awayAnalysis', r.date, r.home_team, r.away_team, r.lambdaHome, r.lambdaAway, r.pOver, r.predOver ? 'Over' : 'Under', r.actualOver ? 'Over' : 'Under', r.pBTTS, r.predBTTS ? 'Yes' : 'No', r.actualBTTS ? 'Yes' : 'No'].join(','));
  }
  const blob = new Blob([rows.join('\\n')], {type:'text/csv'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'backtest_results.csv'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

</script>
</body>
</html>