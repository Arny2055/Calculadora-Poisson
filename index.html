<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Backtester Poisson — Revisión y Corrección</title>
  <style>
    body { font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; background:#f6f7fb; color:#111; }
    header { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
    h1 { margin:0; font-size:20px; }
    .card { background:white; padding:14px; border-radius:10px; box-shadow:0 6px 18px rgba(20,30,60,0.06); margin-bottom:12px; }
    label { display:block; margin:8px 0 6px; font-weight:600; font-size:13px; }
    select,input[type=file],button { padding:8px 10px; border-radius:8px; border:1px solid #d7dbe7; background:white; font-size:14px; }
    button { cursor:pointer; }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    table { width:100%; border-collapse:collapse; margin-top:10px; font-size:13px; }
    th,td { padding:8px 6px; border-bottom:1px solid #eee; text-align:left; }
    th { background:#fafbff; font-weight:700; }
    .muted { color:#666; font-size:13px; }
    .stats { display:flex; gap:12px; margin-top:10px; flex-wrap:wrap; }
    .stat { background:#0f172a; color:white; padding:10px;border-radius:8px; min-width:140px; }
    .good { color: #0b6b3a; font-weight:700; }
    .bad { color: #b02a2a; font-weight:700; }
    pre { background:#0b1220; color:#dbeafe; padding:10px; border-radius:8px; overflow:auto; }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Backtester Poisson — Versión Corregida (Flash 2.5)</h1>
      <div class="muted">Carga tu JSON (formato clásico o el formato con "Match" y "Result FT") → Selecciona liga y equipos → Analizar</div>
    </div>
  </header>

  <div class="card">
    <label>Archivo JSON</label>
    <input id="fileInput" type="file" accept=".json" />
    <div style="margin-top:10px;" class="muted">
      Ejemplo de entrada soportada (tu modelo): <br>
      {"Match":"Flamengo - Bragantino","Date":"jue., 23 nov. 2023 18:30","League":"Brazil Serie A","Result FT":"1-0", ...}
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div style="flex:1">
        <label>Liga</label>
        <select id="leagueSelect"><option value="">-- carga un JSON primero --</option></select>
      </div>
      <div style="flex:1">
        <label>Local</label>
        <select id="homeSelect"><option value="">-- liga --</option></select>
      </div>
      <div style="flex:1">
        <label>Visitante</label>
        <select id="awaySelect"><option value="">-- liga --</option></select>
      </div>
      <div style="align-self:flex-end">
        <button id="analyzeBtn">Analizar Backtesting</button>
      </div>
    </div>
  </div>

  <div id="results" style="display:none;">
    <div class="card">
      <h3>Resumen de Aciertos del Backtest</h3>
      <div class="stats" id="summaryStats"></div>
      <div style="margin-top:10px;">
        <button id="exportCsv">Exportar resultados a CSV</button>
      </div>
    </div>

    <div class="card">
      <h3>Resultados — Local (partidos en casa)</h3>
      <div id="homeResultsTable"></div>
    </div>

    <div class="card">
      <h3>Resultados — Visitante (partidos como visitante)</h3>
      <div id="awayResultsTable"></div>
    </div>

    <div class="card">
      <h3>Predicción para el partido seleccionado</h3>
      <div id="finalPrediction"></div>
    </div>

    <div class="card">
      <h3>Nota / Metodología (Verificada)</h3>
      <div class="muted">
        - **Metodología:** Modelo de Poisson Básico (Goles Home y Away son variables independientes).<br>
        - **Cálculo &lambda;:** Se buscan 10 partidos previos del mismo equipo en la misma condición (home/away) antes de la fecha objetivo. Lambda = promedio de goles **marcados** en esas 10 partidas.<br>
        - **Predicción:** Se combina $\lambda_{\text{Home Marcados}}$ vs $\lambda_{\text{Away Marcados}}$ para el partido objetivo.<br>
        - **Umbral:** p ≥ 0.5 → predecir "Yes/Over".
      </div>
    </div>
  </div>

<script>
let matches = [];
const fileInput = document.getElementById('fileInput');
const leagueSelect = document.getElementById('leagueSelect');
const homeSelect = document.getElementById('homeSelect');
const awaySelect = document.getElementById('awaySelect');
const analyzeBtn = document.getElementById('analyzeBtn');

const MONTHS_ES = {
  'ene':0,'ene.':0, 'feb':1,'feb.':1, 'mar':2,'mar.':2, 'abr':3,'abr.':3, 
  'may':4,'may.':4, 'jun':5,'jun.':5, 'jul':6,'jul.':6, 'ago':7,'ago.':7, 
  'sep':8,'sep.':8,'sept':8,'sept.':8, 'oct':9,'oct.':9, 'nov':10,'nov.':10, 'dic':11,'dic.':11
};

fileInput.addEventListener('change', async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const text = await f.text();
  try {
    const raw = JSON.parse(text);
    if (!Array.isArray(raw)) throw new Error('JSON debe ser un array de partidos');
    matches = raw.map(normalizeMatch).filter(m => m && m.date && m.date.toString() !== 'Invalid Date');
    matches.sort((a,b) => a.date - b.date);
    populateLeagueAndTeams();
    alert('Archivo cargado. Partidos reconocidos: ' + matches.length);
  } catch(err){
    alert('Error parseando JSON: ' + err.message);
    console.error(err);
  }
});

// Normalized Match function (unchanged, robust for data)
function normalizeMatch(entry) {
  try {
    const e = {};
    e.league = entry.league || entry.League || entry.league_name || entry.LeagueName || '';
    const matchRaw = entry.Match || entry.match || entry['Match '] || '';
    if (matchRaw && typeof matchRaw === 'string' && matchRaw.includes('-')) {
      const parts = matchRaw.split('-').map(s => s.trim());
      e.home_team = parts[0] || (entry.home_team || entry.home || '');
      e.away_team = parts[1] || (entry.away_team || entry.away || '');
    } else {
      e.home_team = entry.home_team || entry.home || entry['Home'] || '';
      e.away_team = entry.away_team || entry.away || entry['Away'] || '';
    }
    const resFT = (entry['Result FT'] || entry['ResultFT'] || entry.result_ft || entry.result || entry['Result'] || '').toString().trim();
    if (resFT && resFT.includes('-')) {
      const parts = resFT.split('-').map(s => s.trim());
      e.home_goals = Number(parts[0]) || 0;
      e.away_goals = Number(parts[1]) || 0;
    } else {
      e.home_goals = Number(entry.home_goals ?? entry.homeGoals ?? entry['Home Goals'] ?? NaN);
      e.away_goals = Number(entry.away_goals ?? entry.awayGoals ?? entry['Away Goals'] ?? NaN);
      if (isNaN(e.home_goals)) e.home_goals = typeof entry.HomeTotal === 'number' ? entry.HomeTotal : 0;
      if (isNaN(e.away_goals)) e.away_goals = typeof entry.AwayTotal === 'number' ? entry.AwayTotal : 0;
    }
    const dateRaw = entry.Date || entry.date || entry.MatchDate || entry['Date '] || '';
    e.date = parseFlexibleDate(dateRaw);

    if (!e.home_team) e.home_team = entry['Home Team'] || entry['HomeTeam'] || '';
    if (!e.away_team) e.away_team = entry['Away Team'] || entry['AwayTeam'] || '';

    if (!e.league || !e.home_team || !e.away_team || !e.date) {
      return null;
    }
    return e;
  } catch (err) {
    console.error('normalize error', err, entry);
    return null;
  }
}

// Flexible Date Parser (unchanged, robust for data)
function parseFlexibleDate(s) {
  if (!s) return null;
  if (s instanceof Date) return s;
  s = s.toString().trim();
  const d1 = new Date(s);
  if (!isNaN(d1.getTime())) return d1;
  let cleaned = s.replace(/^[^0-9]*,\s*/,'').replace(/^[A-Za-záéíóúñüÁÉÍÓÚÑÜ]+\.?,\s*/,'');
  const re = /(\d{1,2})\s+([a-zA-ZñÑ\.]+)\s+(\d{4})\s+(\d{1,2}):(\d{2})/i;
  const m = cleaned.match(re);
  if (m) {
    const day = Number(m[1]);
    const monRaw = m[2].toLowerCase();
    const month = MONTHS_ES[monRaw] ?? MONTHS_ES[monRaw.replace(/\./,'')] ?? null;
    const year = Number(m[3]);
    const hour = Number(m[4]);
    const minute = Number(m[5]);
    if (month !== null && !isNaN(day)) {
      return new Date(year, month, day, hour, minute);
    }
  }
  const re2 = /(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2,4})\s+(\d{1,2}):(\d{2})/;
  const m2 = cleaned.match(re2);
  if (m2) {
    const day = Number(m2[1]);
    const month = Number(m2[2]) - 1;
    let year = Number(m2[3]);
    if (year < 100) year += 2000;
    const hour = Number(m2[4]);
    const minute = Number(m2[5]);
    return new Date(year, month, day, hour, minute);
  }
  return null;
}

// Select population functions (unchanged)
function populateLeagueAndTeams(){
  const leagues = Array.from(new Set(matches.map(m=>m.league))).sort();
  leagueSelect.innerHTML = '<option value="">-- seleccionar liga --</option>';
  for(const l of leagues){
    const opt = document.createElement('option'); opt.value = l; opt.textContent = l;
    leagueSelect.appendChild(opt);
  }
  homeSelect.innerHTML = '<option value="">-- liga --</option>';
  awaySelect.innerHTML = '<option value="">-- liga --</option>';
}

leagueSelect.addEventListener('change', () => {
  const league = leagueSelect.value;
  if(!league) {
    homeSelect.innerHTML = '<option value="">-- liga --</option>';
    awaySelect.innerHTML = '<option value="">-- liga --</option>';
    return;
  }
  const teams = Array.from(new Set(matches.filter(m=>m.league===league).flatMap(m=>[m.home_team,m.away_team]))).sort();
  homeSelect.innerHTML = '<option value="">-- seleccionar local --</option>';
  awaySelect.innerHTML = '<option value="">-- seleccionar visitante --</option>';
  for(const t of teams){
    const o1 = document.createElement('option'); o1.value=t; o1.textContent=t;
    const o2 = o1.cloneNode(true);
    homeSelect.appendChild(o1); awaySelect.appendChild(o2);
  }
});

analyzeBtn.addEventListener('click', () => {
  const league = leagueSelect.value;
  const homeTeam = homeSelect.value;
  const awayTeam = awaySelect.value;
  if(!league || !homeTeam || !awayTeam) { alert('Selecciona liga, local y visitante'); return; }
  if (homeTeam === awayTeam) { alert('Los equipos Local y Visitante deben ser diferentes.'); return; }
  runBacktest(league, homeTeam, awayTeam);
});

// --- FUNCIONES DE POISSON VERIFICADAS Y CORREGIDAS ---

// Poisson P(k; lambda) - VERIFICADO: Correcto.
function poissonP(k, lambda) {
  if (lambda <= 0 && k === 0) return 1;
  if (lambda <= 0 && k > 0) return 0;
  // Usamos el logaritmo para evitar desbordamiento en k! y luego Math.exp
  let logP = -lambda + k * Math.log(lambda);
  for(let i=1; i<=k; i++) logP -= Math.log(i);
  return Math.exp(logP);
}

// Probabilidad total de goles >= 3 - CORREGIDA: Usando 1 - P(Total <= 2) para mayor precisión.
function probTotalGreaterThanOrEqual3(lambdaH, lambdaA, maxG=2) {
  if (lambdaH <= 0 && lambdaA <= 0) return 0; 
  let probGolesMenorOIgual2 = 0;
  // P(Total = 0) = P(H=0) * P(A=0)
  probGolesMenorOIgual2 += poissonP(0, lambdaH) * poissonP(0, lambdaA);
  // P(Total = 1) = P(H=1)P(A=0) + P(H=0)P(A=1)
  probGolesMenorOIgual2 += poissonP(1, lambdaH) * poissonP(0, lambdaA);
  probGolesMenorOIgual2 += poissonP(0, lambdaH) * poissonP(1, lambdaA);
  // P(Total = 2) = P(H=2)P(A=0) + P(H=1)P(A=1) + P(H=0)P(A=2)
  probGolesMenorOIgual2 += poissonP(2, lambdaH) * poissonP(0, lambdaA);
  probGolesMenorOIgual2 += poissonP(1, lambdaH) * poissonP(1, lambdaA);
  probGolesMenorOIgual2 += poissonP(0, lambdaH) * poissonP(2, lambdaA);
  
  return 1 - probGolesMenorOIgual2;
}

// Probabilidad BTTS Yes - VERIFICADO: Correcto.
function probBTTSYes(lambdaH, lambdaA) {
  if (lambdaH <= 0 || lambdaA <= 0) return 0;
  const pHome0 = poissonP(0, lambdaH);
  const pAway0 = poissonP(0, lambdaA);
  // 1 - P(Home=0) - P(Away=0) + P(Home=0 AND Away=0)
  return 1 - pHome0 - pAway0 + pHome0 * pAway0;
}

function round(x,d=3) {
  return Math.round(x * Math.pow(10,d)) / Math.pow(10,d);
}

// Prior matches getter (unchanged, correct logic)
function getPriorMatches(team, league, beforeDate, side /* 'home' or 'away' */, n=10) {
  const filtered = matches.filter(m => 
    m.league===league && 
    m.date < beforeDate && 
    ((side==='home' && m.home_team===team) || (side==='away' && m.away_team===team))
  );
  filtered.sort((a,b)=> b.date - a.date);
  return filtered.slice(0,n);
}

// Backtesting function - VERIFICADA Y CORREGIDA para asegurar lambda
function backtestForTeam(team, league, side) {
  const teamMatches = matches.filter(m => m.league===league && ((side==='home' && m.home_team===team) || (side==='away' && m.away_team===team)));
  teamMatches.sort((a,b)=> a.date - b.date);
  const results = [];

  for(let idx=0; idx<teamMatches.length; idx++){
    const target = teamMatches[idx];
    const prior = getPriorMatches(team, league, target.date, side, 10);
    
    // Necesitamos 10 partidos previos del equipo objetivo (lambdaTeam)
    if (prior.length < 10) continue; 

    const opponent = side==='home' ? target.away_team : target.home_team;
    const opponentSide = side==='home' ? 'away' : 'home';
    const priorOpp = getPriorMatches(opponent, league, target.date, opponentSide, 10);
    
    // Necesitamos 10 partidos previos del oponente (lambdaOpp)
    if (priorOpp.length < 10) continue; 

    // CALCULAMOS LAMBDAS BASADAS EN GOLES MARCADOS
    // lambdaTeam: promedio de goles que marcó el equipo objetivo en sus 10 partidos como 'side'
    const lambdaTeam = prior.reduce((s,m)=> s + (side==='home' ? m.home_goals : m.away_goals), 0) / prior.length;

    // lambdaOpp: promedio de goles que marcó el oponente en sus 10 partidos como 'opponentSide'
    const lambdaOpp = priorOpp.reduce((s,m)=> s + (opponentSide==='home' ? m.home_goals : m.away_goals), 0) / priorOpp.length;
    
    // Asignamos las lambdas al lado Home y Away para la fórmula del partido
    const lambdaHome = side==='home' ? lambdaTeam : lambdaOpp;
    const lambdaAway = side==='home' ? lambdaOpp : lambdaTeam;

    if (isNaN(lambdaHome) || isNaN(lambdaAway)) continue; // Safety check

    const pOver = probTotalGreaterThanOrEqual3(lambdaHome, lambdaAway);
    const pBTTS = probBTTSYes(lambdaHome, lambdaAway);

    const predOver = pOver >= 0.5;
    const predBTTS = pBTTS >= 0.5;
    const actualOver = (target.home_goals + target.away_goals) > 2.5;
    const actualBTTS = (target.home_goals > 0) && (target.away_goals > 0);

    results.push({
      date: target.date.toISOString().slice(0,10),
      home_team: target.home_team,
      away_team: target.away_team,
      lambdaHome: round(lambdaHome,3),
      lambdaAway: round(lambdaAway,3),
      pOver: round(pOver,3),
      pBTTS: round(pBTTS,3),
      predOver,
      predBTTS,
      actualOver,
      actualBTTS
    });
  }
  
  const summary = {
    totalOver: results.length,
    correctOver: results.filter(r=>r.predOver === r.actualOver).length,
    totalBTTS: results.length,
    correctBTTS: results.filter(r=>r.predBTTS === r.actualBTTS).length
  };
  return {results, summary};
}

function runBacktest(league, homeTeam, awayTeam) {
  const homeAnalysis = backtestForTeam(homeTeam, league, 'home');
  const awayAnalysis = backtestForTeam(awayTeam, league, 'away');
  
  // Para la predicción final, buscamos la fecha más reciente en todo el dataset
  const lastDate = matches.reduce((mx,m)=>(m.date>mx?m.date:mx), new Date(0));
  const pseudoDate = new Date(lastDate.getTime() + 1000*60*60*24);

  // Obtenemos los 10 partidos más recientes de cada equipo en su condición
  const priorsHome = getPriorMatches(homeTeam, league, pseudoDate, 'home', 10);
  const priorsAway = getPriorMatches(awayTeam, league, pseudoDate, 'away', 10);
  
  let finalPrediction = {ok:false, reason:'Sin suficientes datos (se necesitan 10 partidos previos como Local para Home, y 10 partidos previos como Visitante para Away).'};
  
  if (priorsHome.length >= 10 && priorsAway.length >= 10) {
    // Lambda Home: Promedio de goles marcados por Home en sus últimos 10 como Home
    const lambdaH = priorsHome.reduce((s,m)=> s + m.home_goals,0) / priorsHome.length;
    // Lambda Away: Promedio de goles marcados por Away en sus últimos 10 como Away
    const lambdaA = priorsAway.reduce((s,m)=> s + m.away_goals,0) / priorsAway.length;
    
    if (!isNaN(lambdaH) && !isNaN(lambdaA)) {
      const pOver = probTotalGreaterThanOrEqual3(lambdaH, lambdaA);
      const pBTTS = probBTTSYes(lambdaH, lambdaA);
      finalPrediction = {
        ok:true,
        lambdaHome: round(lambdaH,3),
        lambdaAway: round(lambdaA,3),
        pOver: round(pOver,3),
        pBTTS: round(pBTTS,3),
        predOver: pOver >= 0.5 ? 'Over 2.5' : 'Under 2.5',
        predBTTS: pBTTS >= 0.5 ? 'BTTS Yes' : 'BTTS No'
      };
    }
  }

  document.getElementById('results').style.display = 'block';
  renderSummary(homeTeam, awayTeam, homeAnalysis, awayAnalysis);
  renderResultsTable('homeResultsTable', homeAnalysis.results);
  renderResultsTable('awayResultsTable', awayAnalysis.results);
  renderFinalPrediction(finalPrediction, homeTeam, awayTeam);
  window._lastBacktest = {homeTeam, awayTeam, league, homeResults:homeAnalysis.results, awayResults:awayAnalysis.results, finalPrediction};
}

// Render functions (unchanged)
function renderSummary(homeTeam, awayTeam, homeAnalysis, awayAnalysis) {
  const s = document.getElementById('summaryStats');
  s.innerHTML = '';
  const make = (title, value) => {
    const d = document.createElement('div'); d.className='stat';
    d.innerHTML = `<div style="font-size:12px;color:#cbd5e1">${title}</div><div style="font-size:18px;margin-top:6px">${value}</div>`;
    return d;
  };
  const homeAccOver = homeAnalysis.summary.totalOver ? Math.round(100 * homeAnalysis.summary.correctOver / homeAnalysis.summary.totalOver) + '%' : 'N/A';
  const homeAccBTTS = homeAnalysis.summary.totalBTTS ? Math.round(100 * homeAnalysis.summary.correctBTTS / homeAnalysis.summary.totalBTTS) + '%' : 'N/A';
  const awayAccOver = awayAnalysis.summary.totalOver ? Math.round(100 * awayAnalysis.summary.correctOver / awayAnalysis.summary.totalOver) + '%' : 'N/A';
  const awayAccBTTS = awayAnalysis.summary.totalBTTS ? Math.round(100 * awayAnalysis.summary.correctBTTS / awayAnalysis.summary.totalBTTS) + '%' : 'N/A';
  s.appendChild(make(`Local: ${homeTeam} — acierto Over`, `${homeAccOver} (${homeAnalysis.summary.correctOver}/${homeAnalysis.summary.totalOver})`));
  s.appendChild(make(`Local: ${homeTeam} — acierto BTTS`, `${homeAccBTTS} (${homeAnalysis.summary.correctBTTS}/${homeAnalysis.summary.totalBTTS})`));
  s.appendChild(make(`Visitante: ${awayTeam} — acierto Over`, `${awayAccOver} (${awayAnalysis.summary.correctOver}/${awayAnalysis.summary.totalOver})`));
  s.appendChild(make(`Visitante: ${awayTeam} — acierto BTTS`, `${awayAccBTTS} (${awayAnalysis.summary.correctBTTS}/${awayAnalysis.summary.totalBTTS})`));
}

function renderResultsTable(containerId, results){
  const container = document.getElementById(containerId);
  if(!results || results.length===0) {
    container.innerHTML = '<div class="muted">Sin resultados (no hubo suficientes series de 10 precedentes en la muestra para backtesting)</div>';
    return;
  }
  let html = `<table><thead><tr>
    <th>Fecha</th><th>Home</th><th>Away</th><th>&lambda;Home</th><th>&lambda;Away</th>
    <th>p(Over)</th><th>Pred Over</th><th>Real Over</th>
    <th>p(BTTS)</th><th>Pred BTTS</th><th>Real BTTS</th>
  </tr></thead><tbody>`;
  for(const r of results){
    html += `<tr>
      <td>${r.date}</td>
      <td>${r.home_team}</td>
      <td>${r.away_team}</td>
      <td>${r.lambdaHome}</td>
      <td>${r.lambdaAway}</td>
      <td>${r.pOver}</td>
      <td><span class="${r.predOver === r.actualOver ? 'good' : 'bad'}">${r.predOver ? 'Over' : 'Under'}</span></td>
      <td>${r.actualOver ? 'Over' : 'Under'}</td>
      <td>${r.pBTTS}</td>
      <td><span class="${r.predBTTS === r.actualBTTS ? 'good' : 'bad'}">${r.predBTTS ? 'Yes' : 'No'}</span></td>
      <td>${r.actualBTTS ? 'Yes' : 'No'}</td>
    </tr>`;
  }
  html += '</tbody></table>';
  container.innerHTML = html;
}

function renderFinalPrediction(pred, homeTeam, awayTeam){
  const el = document.getElementById('finalPrediction');
  if(!pred.ok) {
    el.innerHTML = `<div class="muted">No hay suficientes datos para predecir el partido ${homeTeam} vs ${awayTeam}. ${pred.reason || ''}</div>`;
    return;
  }
  el.innerHTML = `<div>
    <strong>${homeTeam} vs ${awayTeam}</strong>
    <div style="margin-top:8px;">
      &lambda; ${homeTeam} (local) = ${pred.lambdaHome} — &lambda; ${awayTeam} (visitante) = ${pred.lambdaAway}
    </div>
    <div style="margin-top:8px;">
      Probabilidad Over 2.5: <strong>${pred.pOver}</strong> → <span class="good">${pred.predOver}</span>
    </div>
    <div style="margin-top:6px;">
      Probabilidad BTTS Yes: <strong>${pred.pBTTS}</strong> → <span class="good">${pred.predBTTS}</span>
    </div>
  </div>`;
}

// CSV export (added good/bad coloring to prediction outcome)
document.getElementById('exportCsv').addEventListener('click', ()=>{
  const data = window._lastBacktest;
  if(!data) { alert('No hay resultados para exportar'); return; }
  // Headers with prediction outcome included
  let rows = [];
  rows.push(['type','date','home','away','lambdaHome','lambdaAway','pOver','predOver','actualOver','CorrectOver','pBTTS','predBTTS','actualBTTS','CorrectBTTS'].join(','));
  const toCsv = (r) => [
    r.date, r.home_team, r.away_team, r.lambdaHome, r.lambdaAway, 
    r.pOver, r.predOver ? 'Over' : 'Under', r.actualOver ? 'Over' : 'Under', r.predOver === r.actualOver ? 'TRUE' : 'FALSE',
    r.pBTTS, r.predBTTS ? 'Yes' : 'No', r.actualBTTS ? 'Yes' : 'No', r.predBTTS === r.actualBTTS ? 'TRUE' : 'FALSE'
  ];

  for(const r of data.homeResults){
    rows.push(['homeAnalysis', ...toCsv(r)].join(','));
  }
  for(const r of data.awayResults){
    rows.push(['awayAnalysis', ...toCsv(r)].join(','));
  }
  
  const blob = new Blob([rows.join('\n')], {type:'text/csv'}); // Changed \n for compatibility
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'backtest_results_corrected.csv'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
});

</script>
</body>
</html>
