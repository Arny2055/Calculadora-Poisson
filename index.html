<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PredicciÃ³n FÃºtbol â€” Probabilidades (Over, BTTS, 1X2) + Elo + Priors</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel2:#1f2430; --text:#e6eaf2; --muted:#9aa3b2;
    --accent:#7aa2ff; --accent2:#5dd4a4; --warn:#ffb84d; --danger:#ff6b6b; --ok:#79e2a6;
    --border:#2a3140;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 "Inter",system-ui,-apple-system,Segoe UI,Roboto}
  main{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;font-weight:800;letter-spacing:.2px;margin:0 0 12px}
  h2{font-size:16px;font-weight:700;margin:18px 0 10px;color:var(--accent)}
  .sub{color:var(--muted);font-size:13px;margin-top:2px}
  .grid{display:grid;gap:16px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:0 4px 16px #0005}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);border:none;color:#0b1020;font-weight:700;padding:10px 14px;border-radius:12px;cursor:pointer}
  .btn.alt{background:var(--accent2)}
  .btn.ghost{background:transparent;border:1px solid var(--border);color:#e6eaf2}
  .btn.warn{background:var(--warn);color:#000}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#111521;color:#fff}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left}
  th{font-size:12px;color:#9aa3b2;font-weight:600}
  tr:hover td{background:#0f1422}
  .badge{display:inline-block;padding:3px 8px;border-radius:999px;font-size:11px;font-weight:700}
  .good{background:#0a3823;color:#94f3c1;border:1px solid #1a7b50}
  .bad{background:#3a1c1c;color:#ffb3b3;border:1px solid #7b1f1f}
  .mid{background:#2c2a11;color:#ffe9a1;border:1px solid #685c1c}
  .knum{font-variant-numeric:tabular-nums}
  .footer{color:var(--muted);font-size:12px;margin:24px 0 16px}
  .pill{background:#121a2a;border:1px solid var(--border);color:#9aa3b2;padding:6px 10px;border-radius:999px;font-size:12px}
  .split{display:flex;gap:16px;flex-wrap:wrap}
  .nowrap{white-space:nowrap}

  .charts{display:grid;gap:12px}
  .charts.g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .charts.g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .chart-wrap{position:relative;width:100%;max-width:100%}
  canvas{display:block;width:100% !important;height:auto !important;max-height:260px}

  .calib{margin-top:10px}
  .calib table{font-size:12px}
  .calib td.knum,.calib th.knum{font-variant-numeric:tabular-nums}
  .delta-pos{color:#79e2a6}
  .delta-neg{color:#ff6b6b}
  .best{background:#0a3823;color:#94f3c1;border:1px solid #1a7b50;border-radius:8px;padding:2px 6px}

  /* â€”â€”â€” Historial estilos â€”â€”â€” */
  .hist-head{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:6px}
  .hist-head input{width:auto}
  .tbl-small th, .tbl-small td{font-size:13px}
  .tag{display:inline-block;background:#1a2336;border:1px solid #273149;color:#9fb3ff;padding:4px 8px;border-radius:999px;font-size:12px}
  .status.ganado{color:#79e2a6}
  .status.perdido{color:#ff6b6b}
  .status.push{color:#7aa2ff}
  .status.medio_ganado{color:#a7f3d0}
  .status.medio_perdido{color:#ffb3b3}
  .btn-xs{padding:6px 10px;border-radius:10px;font-size:12px}
  .btn-mini{padding:6px 8px;border-radius:10px;font-size:12px;background:#273149;color:#cfe1ff;border:1px solid #2f3b59}
  .right{justify-content:flex-end}
  .sticky-head{position:sticky;top:0;background:linear-gradient(180deg,var(--panel),var(--panel2));z-index:2}

  @media (max-width: 900px){
    .g-3{grid-template-columns:1fr}
    .g-2{grid-template-columns:1fr}
    .charts.g-3,.charts.g-2{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<main>
  <h1>BET MEXICO ðŸ‡²ðŸ‡½</h1>
  <div class="sub">Carga <b>CSV o JSON</b> (puedes seleccionar <b>2 JSON</b> a la vez), entrena (80%/20% temporal), agrega partidos manuales y obtÃ©n <b>probabilidades calibradas</b> y <b>cuotas justas</b> (1/p). Sin cuotas de mercado.</div>

  <!-- CONTROLES PRINCIPALES -->
  <section class="grid g-3" style="margin-top:16px">
    <div class="card">
      <h2>1) Datos</h2>
      <div class="row">
        <input id="files" type="file" multiple accept=".csv,.txt,.json,application/json" />
        <button class="btn ghost" id="btnDemoCSV">Demo CSV</button>
        <button class="btn ghost" id="btnDemoJSON">Demo JSON</button>
      </div>
      <p class="sub" style="margin-top:8px">
        Puedes seleccionar <b>uno o varios</b> archivos. Los unimos y <b>deduplicamos</b> por (fecha, liga, local, visitante).
        <br><span id="loadInfo" class="pill" style="display:inline-block;margin-top:6px">Sin datos cargados</span>
      </p>
    </div>

    <div class="card">
      <h2>2) Entrenamiento</h2>
      <div class="grid g-2">
        <div>
          <label>Rolling ventana corta</label>
          <input id="rollShort" type="number" value="6" min="3" max="12"/>
        </div>
        <div>
          <label>Rolling ventana larga</label>
          <input id="rollLong" type="number" value="18" min="5" max="30"/>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnEntrenar" class="btn">Entrenar modelos</button>
        <button id="btnPicks" class="btn alt" disabled>Calcular probabilidades</button>
        <button id="btnExport" class="btn ghost" disabled>Exportar predicciones (CSV)</button>
      </div>
      <p class="sub">Usamos: Elo con decaimiento, pesos por recencia y clase, priors por liga y calibraciÃ³n isotÃ³nica por liga.</p>
    </div>

    <div class="card">
      <h2>3) Filtro de vista</h2>
      <div>
        <label>Liga (para ver predicciones)</label>
        <select id="fLeague"><option value="">(Todas)</option></select>
      </div>
    </div>
  </section>

  <!-- 4) PARTIDOS MANUALES -->
  <section class="card" style="margin-top:8px">
    <h2>4) Partidos a analizar (manual)</h2>
    <div class="grid g-3">
      <div>
        <label>Fecha (YYYY-MM-DD)</label>
        <input id="fiDate" type="date" />
      </div>
      <div>
        <label>Liga</label>
        <select id="fiLeague"><option value="">(elige una liga)</option></select>
      </div>
      <div class="grid g-2" style="gap:8px">
        <div>
          <label>Local</label>
          <select id="fiHome" disabled><option value="">â€”</option></select>
        </div>
        <div>
          <label>Visitante</label>
          <select id="fiAway" disabled><option value="">â€”</option></select>
        </div>
      </div>
      <div style="display:flex;align-items:flex-end">
        <button id="btnAddFixture" class="btn" disabled>Agregar partido</button>
      </div>
    </div>
    <div class="sub" style="margin-top:8px">Solo equipos que existan en tu histÃ³rico para esa liga.</div>

    <table id="tblFixtures" class="tbl-small" style="margin-top:10px">
      <thead class="sticky-head"><tr>
        <th>Fecha</th><th>Liga</th><th>Partido</th><th></th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- MÃ‰TRICAS Y GRÃFICOS (Over/BTTS) -->
  <section class="grid g-2" style="margin-top:16px">
    <div class="card">
      <h2>MÃ©tricas â€” Over 2.5</h2>
      <div class="split">
        <div>
          <div class="sub">Brier: <b id="brierO" class="knum">â€”</b> Â· LogLoss: <b id="loglossO" class="knum">â€”</b></div>
          <div class="sub">CalibraciÃ³n: <span id="calibO" class="badge mid">â€”</span></div>
        </div>
      </div>
      <div class="chart-wrap"><canvas id="chartReliabO"></canvas></div>
      <div class="calib" id="calibTableO"></div>
    </div>
    <div class="card">
      <h2>MÃ©tricas â€” BTTS</h2>
      <div class="split">
        <div>
          <div class="sub">Brier: <b id="brierB" class="knum">â€”</b> Â· LogLoss: <b id="loglossB" class="knum">â€”</b></div>
          <div class="sub">CalibraciÃ³n: <span id="calibB" class="badge mid">â€”</span></div>
        </div>
      </div>
      <div class="chart-wrap"><canvas id="chartReliabB"></canvas></div>
      <div class="calib" id="calibTableB"></div>
    </div>
  </section>

  <!-- MÃ‰TRICAS Y GRÃFICOS (1X2) -->
  <section class="card" style="margin-top:16px">
    <h2>MÃ©tricas â€” 1X2</h2>
    <div class="sub">CalibraciÃ³n por clase (Home, Draw, Away) en validaciÃ³n temporal con isotÃ³nica por liga.</div>
    <div class="split">
      <div class="sub">Brier (prom): <b id="brier1x2" class="knum">â€”</b> Â· LogLoss (prom): <b id="logloss1x2" class="knum">â€”</b> Â· CalibraciÃ³n: <span id="calib1x2" class="badge mid">â€”</span></div>
    </div>
    <div class="charts g-3" style="margin-top:10px">
      <div>
        <div class="chart-wrap"><canvas id="chartReliabH"></canvas></div>
        <div class="calib" id="calibTableH"></div>
      </div>
      <div>
        <div class="chart-wrap"><canvas id="chartReliabD"></canvas></div>
        <div class="calib" id="calibTableD"></div>
      </div>
      <div>
        <div class="chart-wrap"><canvas id="chartReliabA"></canvas></div>
        <div class="calib" id="calibTableA"></div>
      </div>
    </div>
  </section>

  <!-- HISTORIAL POR EQUIPO -->
  <section class="card" style="margin-top:16px">
    <h2>5) Historial por equipo</h2>
    <div class="row">
      <div style="min-width:220px">
        <label>Liga</label>
        <select id="histLeague"><option value="">(Todas)</option></select>
      </div>
      <div>
        <label>Ventana (N partidos recientes)</label>
        <input id="histN" type="number" value="5" min="3" max="30" />
      </div>
      <button class="btn" id="btnRebuildHist">Recalcular</button>
    </div>
    <table id="tblTeams" class="tbl-small" style="margin-top:10px">
      <thead class="sticky-head">
        <tr>
          <th>Equipo</th><th>Liga</th><th class="nowrap">PJ</th>
          <th class="nowrap">GFÃ˜(N)</th><th class="nowrap">GCÃ˜(N)</th>
          <th class="nowrap">SoT ForÃ˜(N)</th><th class="nowrap">SoT AgÃ˜(N)</th>
          <th class="nowrap">DifÃ˜(N)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- TABLAS DE PREDICCIONES -->
  <section class="grid g-2" style="margin-top:16px">
    <div class="card">
      <h2>Predicciones â€” Over 2.5</h2>
      <table id="tblOver">
        <thead class="sticky-head"><tr>
          <th>Fecha</th><th>Liga</th><th>Partido</th>
          <th>p_model (%)</th><th>Cuota justa</th><th></th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="card">
      <h2>Predicciones â€” BTTS</h2>
      <table id="tblBTTS">
        <thead class="sticky-head"><tr>
          <th>Fecha</th><th>Liga</th><th>Partido</th>
          <th>p_model (%)</th><th>Cuota justa</th><th></th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section class="card" style="margin-top:16px">
    <h2>Predicciones â€” 1X2</h2>
    <table id="tbl1x2">
      <thead class="sticky-head"><tr>
        <th>Fecha</th><th>Liga</th><th>Partido</th>
        <th>Home %</th><th>Cuota H</th>
        <th>Draw %</th><th>Cuota X</th>
        <th>Away %</th><th>Cuota A</th>
        <th></th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- 6) HISTORIAL DE APUESTAS (integrado) -->
  <section class="card" style="margin-top:16px">
    <h2>6) Historial de Apuestas</h2>
    <div class="hist-head">
      <span class="tag">Banco</span>
      <label>Inicial $<input type="number" id="bankrollInicialInput" min="0" step="0.01" value="1000"></label>
      <label>FracciÃ³n Kelly <input type="number" id="kellyFracInput" min="0" max="1" step="0.05" value="0.5" /></label>
      <button class="btn btn-xs" id="btnActualizarBankroll">Actualizar</button>
      <div class="row" style="margin-left:auto">
        <button class="btn ghost btn-xs" id="btnExportarHist">Exportar CSV</button>
        <button class="btn warn btn-xs" id="btnBorrarTodo">Borrar todo</button>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <span class="tag">Filtros</span>
      <input type="text" id="filtroGrupo" placeholder="Grupo" />
      <input type="text" id="filtroLocal" placeholder="Local" />
      <input type="text" id="filtroVisita" placeholder="Visitante" />
      <input type="number" id="filtroProb" placeholder="Prob. mÃ­nima (%)" step="0.01" min="0" />
      <input type="number" id="filtroEvMin" placeholder="EV mÃ­nimo" step="0.01" />
      <input type="number" id="filtroEvMax" placeholder="EV mÃ¡ximo" step="0.01" />
      <button class="btn-mini" id="btnLimpiarFiltros">Limpiar</button>
    </div>

    <div style="max-height:420px;overflow:auto;margin-top:10px">
      <table id="tablaHistorial" class="tbl-small">
        <thead class="sticky-head">
          <tr>
            <th>Grupo</th>
            <th>OpciÃ³n</th>
            <th>Prob (%)</th>
            <th>Cuota</th>
            <th>EV</th>
            <th>Kelly (%)</th>
            <th>Apostar ($)</th>
            <th>Local</th>
            <th>Visitante</th>
            <th>Resultado</th>
            <th>Acciones</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <div id="resumenROI" class="sub" style="margin-top:12px"></div>

    <div style="margin-top:14px">
      <canvas id="unidadesChart" height="120"></canvas>
    </div>
  </section>

  <div class="footer">Modelado: logÃ­stica binaria (Over, BTTS) + softmax (1X2) con SGD, L2, pesos por recencia y clase; features de forma (rolling), Elo con decaimiento, priors por liga; calibraciÃ³n isotÃ³nica <b>por liga</b> con respaldo global. Probabilidades calibradas en porcentaje y cuotas justas.</div>
</main>

<script>
/* =================== UTILIDADES BÃSICAS =================== */
const parseCSV = (text) => {
  const lines = text.replace(/\\r/g,'').split('\\n').filter(l=>l.trim().length>0)
  const head = lines[0].split(',').map(h=>h.trim())
  const rows = []
  for(let i=1;i<lines.length;i++){
    const raw = lines[i]
    const vals = []
    let cur='', inQ=false
    for(let j=0;j<raw.length;j++){
      const c = raw[j]
      if(c==='"') { inQ=!inQ; continue }
      if(c===',' && !inQ){ vals.push(cur); cur=''; }
      else cur+=c
    }
    vals.push(cur)
    const obj = {}
    head.forEach((h,idx)=> obj[h]= (vals[idx]??'').trim() )
    rows.push(obj)
  }
  return {columns: head, data: rows}
}
const toNum = (v)=> v===''||v==null? null : Number(v)
const clamp=(x,a,b)=> Math.max(a, Math.min(b, x))
const safeDate = (s)=>{ const d=new Date(s); return isNaN(d)? null : d }
const daysBetween = (a,b)=> Math.max(0, Math.round((b-a)/86400000))
function normalizeObjects(arr){
  const normKey = (k)=> k.toLowerCase().trim().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'')
  return arr.map(r=>{ const o={}; for(const k of Object.keys(r)){ o[normKey(k)] = (''+r[k]).trim() } return o })
}
function parseSpanishDate(s){
  if(!s) return null;
  const months={ene:1,feb:2,mar:3,abr:4,may:5,jun:6,jul:7,ago:8,sep:9,oct:10,nov:11,dic:12};
  const m = String(s).toLowerCase().match(/(\\d{1,2})\\s+([a-zÃ¡Ã©Ã­Ã³Ãº\\.]{3,})\\.?\\s+(\\d{4})/i);
  if(!m){ const d=new Date(s); return isNaN(d)? null : d.toISOString().slice(0,10) }
  const day = String(m[1]).padStart(2,'0');
  const monKey = m[2].slice(0,3).normalize('NFD').replace(/[\\u0300-\\u036f\\.]/g,'');
  const mon = months[monKey]; const year=m[3];
  if(!mon) return null;
  return \`\${year}-\${String(mon).padStart(2,'0')}-\${day}\`;
}
function splitMatch(s){ if(!s) return {home:null,away:null}; const p=String(s).split('-'); return {home:(p[0]||'').trim(), away:(p[1]||'').trim()} }
function numSafe(v){ const n=Number(String(v).replace(/[^0-9\\.-]/g,'')); return isNaN(n)? null : n }

/* =================== ADAPTADOR ESQUEMA (sin cuotas) =================== */
function adaptFromCustomSchema(arr){
  return arr.map(r=>{
    if(r.date && r.home && r.away) return r;
    const out = {};
    out.date = parseSpanishDate(r.date) || parseSpanishDate(r._date) || parseSpanishDate(r.league) || parseSpanishDate(r.name) || r.date || null;
    out.league = r.league || r.name || r.argentina_liga_profesional_de_futbol || r.argentina_liga_profesional || '';
    const m = splitMatch(r.match);
    out.home = m.home || r.home;
    out.away = m.away || r.away;
    if(r.result_ft){
      const mm = String(r.result_ft).match(/(\\d+)\\s*-\\s*(\\d+)/);
      if(mm){ out.home_goals=numSafe(mm[1]); out.away_goals=numSafe(mm[2]); }
    }
    out.home_shotsOT = numSafe(r.home_ongoal_shots_at_ft);
    out.away_shotsOT = numSafe(r.away_ongoal_shots_at_ft);
    out.home_total_shots = numSafe(r.home_total_shots_at_ft);
    out.away_total_shots = numSafe(r.away_total_shots_at_ft);
    out.home_poss = numSafe(r.home_ball_possession_at_ft);
    out.away_poss = numSafe(r.away_ball_possession_at_ft);
    out.home_corners = numSafe(r.home_corners_at_ft);
    out.away_corners = numSafe(r.away_corners_at_ft);
    out.home_yellowcards_at_ft = numSafe(r.home_yellowcards_at_ft);
    out.away_yellowcards_at_ft = numSafe(r.away_yellowcards_at_ft);
    out.home_redcards_at_ft = numSafe(r.home_redcards_at_ft);
    out.away_redcards_at_ft = numSafe(r.away_redcards_at_ft);
    out.home_xg = numSafe(out.home_xg);
    out.away_xg = numSafe(out.away_xg);
    out.home_ppda = numSafe(out.home_ppda);
    out.away_ppda = numSafe(out.away_ppda);
    out.home_rest = numSafe(out.home_rest);
    out.away_rest = numSafe(out.away_rest);
    out.referee_fouls_pg = numSafe(out.referee_fouls_pg);
    out.humidity = numSafe(out.humidity);
    out.temp = numSafe(out.temp);
    return out;
  });
}

/* =================== FEATURE + ELO (igual que antes) =================== */
let TEAM_ELO = new Map()
function getElo(team){ return TEAM_ELO.get(team) ?? 1500 }
function setElo(team, val){ TEAM_ELO.set(team, val) }
function expectedFromElo(eA, eB, hAdv=60){
  const qa = Math.pow(10, (eA + hAdv - eB)/400)
  const qb = 1
  const pHome = qa/(qa+qb)
  return [pHome, 1-pHome]
}
function updateEloRow(row, K=16, hAdv=60){
  if(row.home_goals==null || row.away_goals==null) return
  const h = row.home, a = row.away
  const Eh = getElo(h), Ea = getElo(a)
  const [pH] = expectedFromElo(Eh, Ea, hAdv)
  const y = (row.home_goals>row.away_goals)?1 : (row.home_goals===row.away_goals?0.5:0)
  const halfLife = 240
  const ageDays = row._ageDays ?? 0
  const decay = Math.pow(0.5, ageDays/halfLife)
  const Kd = K*decay
  const newH = Eh + Kd * (y - pH)
  const newA = Ea + Kd * ((1-y) - (1-pH))
  setElo(h, newH); setElo(a, newA)
}
function addEloFeature(rows){
  if(!rows.length) return
  const lastDate = safeDate(rows[rows.length-1].date) || new Date()
  for(const r of rows){ const d = safeDate(r.date)||lastDate; r._ageDays = daysBetween(d, lastDate) }
  TEAM_ELO = new Map()
  for(const r of rows){
    const Eh = getElo(r.home), Ea = getElo(r.away)
    r.f_eloDiff = (Eh - Ea)
    updateEloRow(r)
  }
}
function engineerFeatures(rows, opts){
  const rS = Number(opts.rollShort||5), rL = Number(opts.rollLong||10)
  rows.sort((a,b)=> (a.date||'').localeCompare(b.date||''))
  for(const r of rows){
    r.home_goals = toNum(r.home_goals); r.away_goals = toNum(r.away_goals)
    ;['home_xg','away_xg','home_shotsOT','away_shotsOT','home_ppda','away_ppda','home_rest','away_rest','referee_fouls_pg','humidity','temp']
      .forEach(k=> r[k] = toNum(r[k]))
  }
  const hist = new Map()
  function pushTeam(team, isHome, m){
    const key = team||'__NA__'
    if(!hist.has(key)) hist.set(key, [])
    const entry = {
      date: m.date||'',
      league: m.league||'',
      for_xg: isHome? (m.home_xg??null): (m.away_xg??null),
      ag_xg:  isHome? (m.away_xg??null): (m.home_xg??null),
      for_soT:isHome? (m.home_shotsOT??null): (m.away_shotsOT??null),
      ag_soT: isHome? (m.away_shotsOT??null): (m.home_shotsOT??null),
      ppda:   isHome? (m.home_ppda??null): (m.away_ppda??null),
      rest:   isHome? (m.home_rest??null): (m.away_rest??null),
      goals_for: isHome? (m.home_goals??null): (m.away_goals??null),
      goals_ag:  isHome? (m.away_goals??null): (m.home_goals??null),
      team: team
    }
    hist.get(key).push(entry)
  }
  for(const m of rows){ pushTeam(m.home,true,m); pushTeam(m.away,false,m) }
  function rollingStats(team, date){
    const h = (hist.get(team||'__NA__')||[]).filter(x=> (x.date||'') < (date||''))
    const take = (arr,n)=> arr.slice(-n)
    const s5 = take(h,rS), sL = take(h,rL)
    const avg=(arr,key)=>{ if(arr.length===0) return null; let s=0,c=0; for(const x of arr){ if(x[key]!=null){ s+=x[key]; c++ } } return c? s/c : null }
    return {
      s_for_xg: avg(s5,'for_xg'), s_ag_xg: avg(s5,'ag_xg'),
      l_for_xg: avg(sL,'for_xg'), l_ag_xg: avg(sL,'ag_xg'),
      s_for_soT: avg(s5,'for_soT'), s_ag_soT: avg(s5,'ag_soT'),
      s_ppda: avg(s5,'ppda'), l_ppda: avg(sL,'ppda'),
      s_rest: avg(s5,'rest'), l_rest: avg(sL,'rest'),
      s_goal_diff: (avg(s5,'goals_for')??0) - (avg(s5,'goals_ag')??0),
      l_goal_diff: (avg(sL,'goals_for')??0) - (avg(sL,'goals_ag')??0),
    }
  }
  for(const m of rows){
    const fH = rollingStats(m.home, m.date)
    const fA = rollingStats(m.away, m.date)
    m.f_for_xg = (fH.s_for_xg??0) - (fA.s_for_xg??0)
    m.f_ag_xg  = (fH.s_ag_xg??0)  - (fA.s_ag_xg??0)
    m.f_soT    = (fH.s_for_soT??0) - (fA.s_for_soT??0)
    m.f_ppda   = (fA.s_ppda??0) - (fH.s_ppda??0)
    m.f_rest   = (fH.s_rest??0) - (fA.s_rest??0)
    m.f_goalD  = (fH.s_goal_diff??0) - (fA.s_goal_diff??0)
    m.clima_hum = m.humidity ?? 50
    m.clima_temp = m.temp ?? 18
    m.ref_fouls = m.referee_fouls_pg ?? 22
    if(m.home_goals!=null && m.away_goals!=null){
      const tot = m.home_goals + m.away_goals
      m.y_over25 = (tot>2)?1:0
      m.y_btts = (m.home_goals>0 && m.away_goals>0)?1:0
      m.y_wdl = (m.home_goals>m.away_goals)?0 : ((m.home_goals===m.away_goals)?1:2)
    } else { m.y_over25 = null; m.y_btts = null; m.y_wdl = null }
  }
  addEloFeature(rows)
  return rows
}

/* =================== PRIORS / DISEÃ‘OS / MODELOS (igual) =================== */
let PRIORS=null
function computeLeaguePriors(rows){
  const byL = new Map()
  for(const r of rows){
    if(r.y_over25==null || r.y_btts==null || r.y_wdl==null) continue
    const L = r.league||'__'
    if(!byL.has(L)) byL.set(L,{o:0,b:0,d:0,n:0})
    const s = byL.get(L)
    s.o += r.y_over25; s.b += r.y_btts; s.d += (r.y_wdl===1?1:0); s.n += 1
  }
  const pri = new Map()
  byL.forEach((v,k)=> pri.set(k,{ pOver: v.n? v.o/v.n : 0.55, pBTTS: v.n? v.b/v.n : 0.52, pDraw: v.n? v.d/v.n : 0.26 }))
  return pri
}
function addPriorsToRows(rows, priMap){
  for(const r of rows){
    const p = priMap?.get(r.league) || {pOver:0.55,pBTTS:0.52,pDraw:0.26}
    r.f_priorOver = p.pOver
    r.f_priorBTTS = p.pBTTS
    r.f_priorDraw = p.pDraw
  }
}
function makeDesignBinary(rows, target){
  const colsBase = ['f_for_xg','f_ag_xg','f_soT','f_ppda','f_rest','f_goalD','clima_hum','clima_temp','ref_fouls','f_eloDiff']
  const priorCol = (target==='over'?'f_priorOver':'f_priorBTTS')
  const cols = colsBase.concat([priorCol])
  const freq = new Map()
  rows.forEach(r=>{ const y=(target==='over'? r.y_over25:r.y_btts); if(y!=null) freq.set(y,(freq.get(y)||0)+1) })
  const total = Array.from(freq.values()).reduce((a,b)=>a+b,0) || 1
  const invFreq = new Map(); freq.forEach((c,k)=> invFreq.set(k, total/(c||1)))
  const lastDate = safeDate(rows[rows.length-1]?.date)||new Date()
  const X=[], y=[], w=[], leagues=[]
  for(const r of rows){
    const yi = (target==='over'? r.y_over25 : r.y_btts)
    if(yi==null) continue
    const row = cols.map(c=> (r[c]==null? 0 : Number(r[c])))
    X.push(row); y.push(yi); leagues.push(r.league||'__')
    const ageDays = daysBetween(safeDate(r.date)||lastDate, lastDate)
    const wRec = Math.pow(0.5, ageDays/240)
    const wCls = invFreq.get(yi)||1
    w.push(wRec * wCls)
  }
  const mu = Array(X[0]?.length||0).fill(0), sd = Array(X[0]?.length||0).fill(0)
  if(X.length){
    for(let j=0;j<mu.length;j++){
      let s=0; for(let i=0;i<X.length;i++) s+=X[i][j]; mu[j]=s/X.length
      let v=0; for(let i=0;i<X.length;i++){ const d=X[i][j]-mu[j]; v+=d*d } sd[j]=Math.sqrt(v/Math.max(1,X.length-1))||1
      for(let i=0;i<X.length;i++) X[i][j]=(X[i][j]-mu[j])/sd[j]
    }
  }
  return {X,y,w,cols,mu,sd, leagues}
}
function makeDesignMulticlass(rows){
  const cols = ['f_for_xg','f_ag_xg','f_soT','f_ppda','f_rest','f_goalD','clima_hum','clima_temp','ref_fouls','f_eloDiff','f_priorDraw']
  const freq = new Map()
  rows.forEach(r=>{ const y=r.y_wdl; if(y!=null) freq.set(y,(freq.get(y)||0)+1) })
  const total = Array.from(freq.values()).reduce((a,b)=>a+b,0) || 1
  const invFreq = new Map(); [0,1,2].forEach(k=> invFreq.set(k, total/((freq.get(k)||1))))
  const lastDate = safeDate(rows[rows.length-1]?.date)||new Date()
  const X=[], y=[], w=[], leagues=[]
  for(const r of rows){
    if(r.y_wdl==null) continue
    const row = cols.map(c=> (r[c]==null? 0 : Number(r[c])))
    X.push(row); y.push(r.y_wdl); leagues.push(r.league||'__')
    const ageDays = daysBetween(safeDate(r.date)||lastDate, lastDate)
    const wRec = Math.pow(0.5, ageDays/240)
    const wCls = invFreq.get(r.y_wdl)||1
    w.push(wRec * wCls)
  }
  const mu = Array(X[0]?.length||0).fill(0), sd = Array(X[0]?.length||0).fill(0)
  if(X.length){
    for(let j=0;j<mu.length;j++){
      let s=0; for(let i=0;i<X.length;i++) s+=X[i][j]; mu[j]=s/X.length
      let v=0; for(let i=0;i<X.length;i++){ const d=X[i][j]-mu[j]; v+=d*d } sd[j]=Math.sqrt(v/Math.max(1,X.length-1))||1
      for(let i=0;i<X.length;i++) X[i][j]=(X[i][j]-mu[j])/sd[j]
    }
  }
  return {X,y,w,cols,mu,sd,K:3, leagues}
}
function trainLogReg(design, epochs=400, lr=0.05, l2=0.001){
  const {X,y,w} = design; const d = X[0]?.length||0
  let W = Array(d).fill(0), b=0
  for(let ep=0; ep<epochs; ep++){
    for(let i=0;i<X.length;i++){
      const xi = X[i], yi=y[i], wi=w[i]||1
      let z=b; for(let j=0;j<d;j++) z+= W[j]*xi[j]
      const p = 1/(1+Math.exp(-z))
      const err = (p-yi)*wi
      for(let j=0;j<d;j++){ W[j] -= lr*(err*xi[j] + l2*W[j]) }
      b -= lr*err
    }
  }
  return {w:W,b}
}
function predictLogReg(design, model, rowObj){
  const x = design.cols.map(c=> rowObj[c]==null?0:Number(rowObj[c]))
  for(let j=0;j<x.length;j++) x[j]=(x[j]-design.mu[j])/design.sd[j]
  let z=model.b; for(let j=0;j<x.length;j++) z+= model.w[j]*x[j]
  return 1/(1+Math.exp(-z))
}
function softmax(arr){
  const m = Math.max(...arr)
  const exps = arr.map(v=> Math.exp(v-m))
  const s = exps.reduce((a,b)=>a+b,0)
  return exps.map(v=> v/s)
}
function trainSoftmax(design, epochs=400, lr=0.05, l2=0.001){
  const {X,y,w,K} = design; const d = X[0]?.length||0
  let W = Array.from({length:K}, ()=> Array(d).fill(0))
  let b = Array(K).fill(0)
  for(let ep=0; ep<epochs; ep++){
    for(let i=0;i<X.length;i++){
      const xi = X[i], yi = y[i], wi = w[i]||1
      const z = b.map((bk,k)=> bk + W[k].reduce((s,wj,j)=> s + wj*xi[j], 0))
      const m = Math.max(...z); const exps = z.map(v=> Math.exp(v-m))
      const s = exps.reduce((a,b)=>a+b,0); const p = exps.map(v=> v/s)
      for(let k=0;k<K;k++){
        const yk = (yi===k)?1:0
        const err = (p[k]-yk)*wi
        for(let j=0;j<d;j++){ W[k][j] -= lr*(err*xi[j] + l2*W[k][j]) }
        b[k] -= lr*err
      }
    }
  }
  return {W,b,K}
}
function predictSoftmax(design, model, rowObj){
  const x = design.cols.map(c=> rowObj[c]==null?0:Number(rowObj[c]))
  for(let j=0;j<x.length;j++) x[j]=(x[j]-design.mu[j])/design.sd[j]
  const z = model.b.map((bk,k)=> bk + model.W[k].reduce((s,wj,j)=> s + wj*x[j], 0))
  return softmax(z)
}

/* =================== ISOTÃ“NICA =================== */
function isotonicFit(probs, labels){
  const n = probs.length; if(!n) return []
  let xy = []
  for(let i=0;i<n;i++) xy.push({x:probs[i], n:1, y:labels[i]})
  xy.sort((a,b)=> a.x-b.x)
  for(let i=0;i<xy.length;){
    let j=i
    while(j<xy.length-1 && xy[j].y/xy[j].n > xy[j+1].y/xy[j+1].n){
      xy[j+1] = {x: xy[j].x+xy[j+1].x, n: xy[j].n+xy[j+1].n, y: xy[j].y+xy[j+1].y}
      xy.splice(j,1); j=Math.max(0,j-1); if(j===0) break
    }
    i++
  }
  let out=[], accx=0, accn=0, accy=0
  for(const b of xy){ accx+=b.x; accn+=b.n; accy+=b.y; out.push({x:clamp(accx/accn,0,1), y:clamp(accy/accn,0,1)}) }
  return out
}
function isotonicPredict(fit, p){
  if(!fit || fit.length===0) return p
  for(let i=0;i<fit.length-1;i++){
    if(p>=fit[i].x && p<=fit[i+1].x){
      const t=(p-fit[i].x)/(fit[i+1].x-fit[i].x+1e-9)
      return fit[i].y + t*(fit[i+1].y - fit[i].y)
    }
  }
  if(p<fit[0].x) return fit[0].y
  return fit[fit.length-1].y
}
function fitIsoByLeague(preds, labels, leagues){
  const byL = new Map()
  for(let i=0;i<preds.length;i++){
    const L = leagues[i]||'__'
    if(!byL.has(L)) byL.set(L, {p:[],y:[]})
    byL.get(L).p.push(preds[i]); byL.get(L).y.push(labels[i])
  }
  const out = new Map()
  byL.forEach((v,k)=>{
    const fit = v.p.length>=20 ? isotonicFit(v.p, v.y) : []
    out.set(k, fit)
  })
  const globalFit = isotonicFit(preds, labels)
  return {byLeague: out, globalFit}
}
function isoPredictByLeague(isoObj, league, p){
  const fitL = isoObj.byLeague.get(league||'__')
  const fit = (fitL && fitL.length)? fitL : isoObj.globalFit
  return isotonicPredict(fit, p)
}

/* =================== MÃ‰TRICAS =================== */
const brier = (p,y)=> { if(!p.length) return NaN; let s=0; for(let i=0;i<p.length;i++){ const d=(p[i]-y[i]); s+=d*d } return s/p.length }
const logloss = (p,y)=>{ if(!p.length) return NaN; let s=0; for(let i=0;i<p.length;i++){ const pi=clamp(p[i],1e-7,1-1e-7); s += -(y[i]*Math.log(pi)+(1-y[i])*Math.log(1-pi)) } return s/p.length }
function brierMulti(P, Y){
  if(!P.length) return NaN
  let s=0
  for(let i=0;i<P.length;i++){
    const yH = (Y[i]===0)?1:0, yD=(Y[i]===1)?1:0, yA=(Y[i]===2)?1:0
    const e = (P[i][0]-yH)**2 + (P[i][1]-yD)**2 + (P[i][2]-yA)**2
    s += e/3
  }
  return s/P.length
}
function loglossMulti(P,Y){
  if(!P.length) return NaN
  let s=0
  for(let i=0;i<P.length;i++){
    const pi = clamp(P[i][Y[i]],1e-7,1-1e-7)
    s += -Math.log(pi)
  }
  return s/P.length
}
function binReliability(p,y, nb=10){
  if(!p.length) return []
  const idx = p.map((v,i)=>[v,i]).sort((a,b)=> a[0]-b[0]).map(x=>x[1])
  const n = p.length, size = Math.max(1, Math.floor(n/nb))
  const out=[]
  for(let b=0;b<nb;b++){
    const start = b*size, end = (b===nb-1? n: (b+1)*size)
    if(start>=n) break
    let sP=0,sY=0,c=0
    for(let i=start;i<end;i++){ const k=idx[i]; sP+=p[k]; sY+=y[k]; c++ }
    if(c>0) out.push({conf:sP/c, acc:sY/c, n:c})
  }
  return out
}
function renderReliability(canvasId, p, y){
  const bins = binReliability(p,y)
  const ctx = document.getElementById(canvasId).getContext('2d')
  if(ctx._chart){ ctx._chart.destroy() }
  if(!bins.length){ ctx.canvas.replaceWith(ctx.canvas.cloneNode(true)); return }
  const labels = bins.map((_,i)=> \`\${(i/bins.length*100).toFixed(0)}â€“\${((i+1)/bins.length*100).toFixed(0)}%\`)
  const data1 = bins.map(b=> b.acc)
  const data2 = bins.map(b=> b.conf)
  ctx._chart = new Chart(ctx, { type:'line', data:{ labels, datasets:[ {label:'Exactitud', data:data1}, {label:'Confianza', data:data2} ]}, options:{ responsive:true, interaction:{mode:'index',intersect:false}, maintainAspectRatio:true, scales:{ y:{min:0,max:1} } } })
}
function avgAbsBinDiff(p,y){
  const bins = binReliability(p,y)
  if(!bins.length) return 1
  let s=0; for(const b of bins){ s += Math.abs(b.acc - b.conf) }
  return s/bins.length
}
function renderCalibrationTable(targetId, p, y){
  const bins = binReliability(p,y)
  if(!bins.length){ document.getElementById(targetId).innerHTML = '<div class="sub">Sin datos suficientes para tabla de calibraciÃ³n.</div>'; return }
  let html = '<table class="tbl-small"><thead><tr><th>Bin</th><th class="knum">Conf. media</th><th class="knum">Exactitud</th><th class="knum">Î”</th><th class="knum">n</th></tr></thead><tbody>'
  const nb = bins.length
  for(let i=0;i<nb;i++){
    const b = bins[i]
    const lo = (i/nb*100).toFixed(0), hi = ((i+1)/nb*100).toFixed(0)
    const diff = (b.acc - b.conf)
    html += \`<tr>
      <td>\${lo}â€“\${hi}%</td>
      <td class="knum">\${(b.conf*100).toFixed(1)}%</td>
      <td class="knum">\${(b.acc*100).toFixed(1)}%</td>
      <td class="knum \${diff>=0?'delta-pos':'delta-neg'}">\${(diff*100).toFixed(1)}%</td>
      <td class="knum">\${b.n}</td>
    </tr>\`
  }
  html += '</tbody></table>'
  document.getElementById(targetId).innerHTML = html
}

/* =================== ENTRENAMIENTO / INFERENCIA =================== */
let RAW=[], FEAT=[]
let designO, modelO, isoO
let designB, modelB, isoB
let designWDL, modelWDL, isoH, isoD, isoA
let PREDS=[]
let MANUAL_FIXTURES=[]
let LEAGUE_TEAMS = new Map()

function dedupRows(rows){
  const seen = new Set(), out=[]
  for(const r of rows){
    const key = \`\${r.date||''}|||\${(r.league||'').toLowerCase()}|||\${(r.home||'').toLowerCase()}|||\${(r.away||'').toLowerCase()}\`
    if(seen.has(key)) continue
    seen.add(key); out.push(r)
  }
  return out
}
function buildLeagueTeamsMap(data){
  LEAGUE_TEAMS = new Map()
  for(const r of data){
    if(r.__manualFixture) continue
    const league = r.league||'', home=r.home||'', away=r.away||''
    if(!league || !(home||away)) continue
    if(!LEAGUE_TEAMS.has(league)) LEAGUE_TEAMS.set(league, new Set())
    const s = LEAGUE_TEAMS.get(league); if(home) s.add(home); if(away) s.add(away)
  }
}
function setFiLeagueOptions(){
  const sel = document.getElementById('fiLeague')
  const leagues = Array.from(LEAGUE_TEAMS.keys()).sort()
  sel.innerHTML = '<option value="">(elige una liga)</option>' + leagues.map(l=> \`<option>\${l}</option>\`).join('')
  setTeamOptions([], 'fiHome'); setTeamOptions([], 'fiAway')
  document.getElementById('fiHome').disabled = true
  document.getElementById('fiAway').disabled = true
  maybeToggleAddButton()
}
function setTeamOptions(teams, idSel){
  const sel = document.getElementById(idSel)
  const opts = teams.map(t=> \`<option>\${t}</option>\`).join('')
  sel.innerHTML = '<option value="">(elige)</option>' + opts
}
function onLeagueChange(){
  const league = document.getElementById('fiLeague').value
  const homeSel = document.getElementById('fiHome')
  const awaySel = document.getElementById('fiAway')
  if(!league){
    setTeamOptions([], 'fiHome'); setTeamOptions([], 'fiAway')
    homeSel.disabled = true; awaySel.disabled = true
    maybeToggleAddButton(); return
  }
  const teams = Array.from(LEAGUE_TEAMS.get(league)||[]).sort()
  setTeamOptions(teams, 'fiHome'); setTeamOptions(teams, 'fiAway')
  homeSel.disabled = false; awaySel.disabled = false
  homeSel.value=''; awaySel.value=''
  maybeToggleAddButton()
}
function maybeToggleAddButton(){
  const d = (document.getElementById('fiDate').value||'').trim()
  const league = document.getElementById('fiLeague').value
  const h = document.getElementById('fiHome').value
  const a = document.getElementById('fiAway').value
  document.getElementById('btnAddFixture').disabled = !(d && league && h && a && h!==a)
}

/* ----- Entrenar y mÃ©tricas ----- */
function trainAll(){
  if(!FEAT.length){ alert('Primero carga datos histÃ³ricos.'); return }
  let pool = FEAT.filter(r=> r.y_over25!=null && r.y_btts!=null && r.y_wdl!=null)
  if(pool.length < 60){ alert('Pocas filas con resultado para entrenar (min. recomendado: 60). Carga mÃ¡s histÃ³rico.'); }
  const cut = Math.floor(pool.length*0.8)
  const trainSet = pool.slice(0,cut)
  const validSet = pool.slice(cut)
  PRIORS = computeLeaguePriors(trainSet)
  addPriorsToRows(FEAT, PRIORS)
  designO = makeDesignBinary(trainSet, 'over'); modelO = trainLogReg(designO)
  designB = makeDesignBinary(trainSet, 'btts'); modelB = trainLogReg(designB)
  designWDL = makeDesignMulticlass(trainSet); modelWDL = trainSoftmax(designWDL)

  // ValidaciÃ³n -> calibraciÃ³n
  const pO=[], yO=[], lO=[], pB=[], yB=[], lB=[], P1x2=[], Y1x2=[], L1x2=[]
  for(const r of validSet){
    const p1 = predictLogReg(designO, modelO, r)
    const p2 = predictLogReg(designB, modelB, r)
    pO.push(p1); yO.push(r.y_over25); lO.push(r.league||'__')
    pB.push(p2); yB.push(r.y_btts);   lB.push(r.league||'__')
    const q = predictSoftmax(designWDL, modelWDL, r)
    P1x2.push(q); Y1x2.push(r.y_wdl); L1x2.push(r.league||'__')
  }
  isoO = fitIsoByLeague(pO,yO,lO)
  isoB = fitIsoByLeague(pB,yB,lB)
  const pH = P1x2.map(q=>q[0]), yH = Y1x2.map(v=> v===0?1:0)
  const pD = P1x2.map(q=>q[1]), yD = Y1x2.map(v=> v===1?1:0)
  const pA = P1x2.map(q=>q[2]), yA = Y1x2.map(v=> v===2?1:0)
  isoH = fitIsoByLeague(pH,yH,L1x2)
  isoD = fitIsoByLeague(pD,yD,L1x2)
  isoA = fitIsoByLeague(pA,yA,L1x2)

  // MÃ©tricas post-calibraciÃ³n
  const pOc = pO.map((p,i)=> isoPredictByLeague(isoO, lO[i], p))
  const pBc = pB.map((p,i)=> isoPredictByLeague(isoB, lB[i], p))
  document.getElementById('brierO').textContent = (pOc.length? brier(pOc,yO).toFixed(4): 'â€”')
  document.getElementById('loglossO').textContent = (pOc.length? logloss(pOc,yO).toFixed(4): 'â€”')
  document.getElementById('brierB').textContent = (pBc.length? brier(pBc,yB).toFixed(4): 'â€”')
  document.getElementById('loglossB').textContent = (pBc.length? logloss(pBc,yB).toFixed(4): 'â€”')
  setBadge('calibO', calibScore(pOc,yO))
  setBadge('calibB', calibScore(pBc,yB))
  renderReliability('chartReliabO', pOc, yO)
  renderReliability('chartReliabB', pBc, yB)
  renderCalibrationTable('calibTableO', pOc, yO)
  renderCalibrationTable('calibTableB', pBc, yB)

  const Pc = P1x2.map((q,i)=>[
    isoPredictByLeague(isoH, L1x2[i], q[0]),
    isoPredictByLeague(isoD, L1x2[i], q[1]),
    isoPredictByLeague(isoA, L1x2[i], q[2]),
  ])
  for(const q of Pc){ const s=q[0]+q[1]+q[2]; if(s>0){ q[0]/=s; q[1]/=s; q[2]/=s } }
  const b1 = brierMulti(Pc,Y1x2), l1 = loglossMulti(Pc,Y1x2)
  document.getElementById('brier1x2').textContent = isFinite(b1)? b1.toFixed(4) : 'â€”'
  document.getElementById('logloss1x2').textContent = isFinite(l1)? l1.toFixed(4) : 'â€”'
  setBadge('calib1x2', calibScoreMulti(Pc,Y1x2))
  renderReliability('chartReliabH', Pc.map(q=>q[0]), Y1x2.map(v=> v===0?1:0))
  renderReliability('chartReliabD', Pc.map(q=>q[1]), Y1x2.map(v=> v===1?1:0))
  renderReliability('chartReliabA', Pc.map(q=>q[2]), Y1x2.map(v=> v===2?1:0))
  renderCalibrationTable('calibTableH', Pc.map(q=>q[0]), Y1x2.map(v=> v===0?1:0))
  renderCalibrationTable('calibTableD', Pc.map(q=>q[1]), Y1x2.map(v=> v===1?1:0))
  renderCalibrationTable('calibTableA', Pc.map(q=>q[2]), Y1x2.map(v=> v===2?1:0))

  document.getElementById('btnPicks').disabled = false
  populateHistLeagueOptions()
  rebuildTeamHistory()
}
function setBadge(id, score){
  const el = document.getElementById(id)
  el.textContent = score.txt
  el.className = 'badge ' + score.cls
}
function calibScore(p,y){
  if(!p.length) return {txt:'â€”', cls:'mid'}
  const bins = binReliability(p,y)
  let s=0; for(const b of bins){ s += Math.abs(b.acc - b.conf) }
  const d = s/bins.length
  if(d<0.02) return {txt:'Excelente', cls:'good'}
  if(d<0.05) return {txt:'Buena', cls:'mid'}
  return {txt:'Mejorable', cls:'bad'}
}
function calibScoreMulti(Pc, Y){
  const pH = Pc.map(q=>q[0]), yH = Y.map(v=> v===0?1:0)
  const pD = Pc.map(q=>q[1]), yD = Y.map(v=> v===1?1:0)
  const pA = Pc.map(q=>q[2]), yA = Y.map(v=> v===2?1:0)
  const d = (avgAbsBinDiff(pH,yH)+avgAbsBinDiff(pD,yD)+avgAbsBinDiff(pA,yA))/3
  if(d<0.02) return {txt:'Excelente', cls:'good'}
  if(d<0.05) return {txt:'Buena', cls:'mid'}
  return {txt:'Mejorable', cls:'bad'}
}

/* ===== CALCULAR PROBABILIDADES ===== */
function generateProbabilities(){
  if(!designO || !designB || !designWDL){ alert('Primero entrena los modelos.'); return }
  const league = document.getElementById('fLeague').value
  addPriorsToRows(FEAT, PRIORS||new Map())

  const future = FEAT.filter(r=> r.__manualFixture === true).filter(r=> !league || r.league===league)
  if(future.length===0){ alert('No hay partidos manuales agregados. Usa la secciÃ³n 4) para aÃ±adir Local vs Visitante.'); return }

  const outO=[], outB=[], out1x2=[]
  PREDS = []

  for(const r of future){
    const pOver = isoPredictByLeague(isoO, r.league, predictLogReg(designO, modelO, r))
    const pBTTS = isoPredictByLeague(isoB, r.league, predictLogReg(designB, modelB, r))
    const fairOver = pOver>0 ? (1/pOver) : null
    const fairBTTS = pBTTS>0 ? (1/pBTTS) : null

    outO.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, p_model:pOver, fair:fairOver, home:r.home, away:r.away, market:'Over 2.5'})
    PREDS.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, market:'Over 2.5', p_model:pOver, p_model_percent:(pOver*100).toFixed(1), fair_odds: fairOver? fairOver.toFixed(2):''})

    outB.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, p_model:pBTTS, fair:fairBTTS, home:r.home, away:r.away, market:'BTTS Yes'})
    PREDS.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, market:'BTTS Yes', p_model:pBTTS, p_model_percent:(pBTTS*100).toFixed(1), fair_odds: fairBTTS? fairBTTS.toFixed(2):''})

    let q = predictSoftmax(designWDL, modelWDL, r)
    q = [
      isoPredictByLeague(isoH, r.league, q[0]),
      isoPredictByLeague(isoD, r.league, q[1]),
      isoPredictByLeague(isoA, r.league, q[2]),
    ]
    const s=q[0]+q[1]+q[2]; if(s>0){ q[0]/=s; q[1]/=s; q[2]/=s }
    const fairH = q[0]>0? 1/q[0] : null
    const fairD = q[1]>0? 1/q[1] : null
    const fairA = q[2]>0? 1/q[2] : null

    out1x2.push({ date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, pH:q[0], pD:q[1], pA:q[2], fH:fairH, fD:fairD, fA:fairA, home:r.home, away:r.away })
    PREDS.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, market:'1 (Home)', p_model:q[0], p_model_percent:(q[0]*100).toFixed(1), fair_odds: fairH? fairH.toFixed(2):''})
    PREDS.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, market:'X (Draw)', p_model:q[1], p_model_percent:(q[1]*100).toFixed(1), fair_odds: fairD? fairD.toFixed(2):''})
    PREDS.push({date:r.date, league:r.league, match:\`\${r.home} vs \${r.away}\`, market:'2 (Away)', p_model:q[2], p_model_percent:(q[2]*100).toFixed(1), fair_odds: fairA? fairA.toFixed(2):''})
  }

  outO.sort((a,b)=> b.p_model-a.p_model)
  outB.sort((a,b)=> b.p_model-a.p_model)
  out1x2.sort((a,b)=> (b.pH - a.pH))

  fillPredTable('tblOver', outO)
  fillPredTable('tblBTTS', outB)
  fill1x2Table('tbl1x2', out1x2)

  document.getElementById('btnExport').disabled = PREDS.length===0
}
function fmtPercent(x){ return (x*100).toFixed(1) + '%' }
function fmtFair(x){ return x? x.toFixed(2) : 'â€”' }
function addPickFromPrediction({grupo, opcion, prob, home, away}){
  const cuotaStr = prompt('Cuota (decimal) ofrecida por la casa para "'+opcion+'":', '1.80')
  if(cuotaStr===null) return
  const cuota = Number(cuotaStr)
  if(!(cuota>1)) { alert('Cuota invÃ¡lida.'); return }
  const kellyFrac = Number(document.getElementById('kellyFracInput').value)||0
  const p = clamp(prob,0,1)
  const b = cuota - 1
  const q = 1 - p
  const kelly = Math.max(0, (b*p - q)/b) * 100 // %
  const stakeSug = (bankrollInicial * (kelly/100) * clamp(kellyFrac,0,1))
  const stakeStr = prompt(\`Stake sugerido $ \${stakeSug.toFixed(2)} â€” ingresa $ a apostar:\`, stakeSug.toFixed(2))
  if(stakeStr===null) return
  const stake = Math.max(0, Number(stakeStr)||0)
  const ev = p*cuota - 1
  const row = {
    id: genId(), grupo: grupo || '', opcion, prob: (p*100).toFixed(2),
    cuota: cuota.toFixed(2), ev: ev.toFixed(3), kelly: kelly.toFixed(1),
    stake: stake.toFixed(2), local: home||'', visitante: away||'', resultado: ''
  }
  historial.push(row); guardarHistorial(); filtrarHistorial()
}
function fillPredTable(id, rows){
  const tb = document.querySelector('#'+id+' tbody')
  tb.innerHTML = rows.map(r=> \`<tr>
    <td>\${r.date||''}</td>
    <td>\${r.league||''}</td>
    <td>\${r.match||''}</td>
    <td class="knum">\${fmtPercent(r.p_model??0)}</td>
    <td class="knum">\${fmtFair(r.fair)}</td>
    <td><button class="btn btn-xs" data-add="1" data-market="\${r.market}" data-prob="\${r.p_model}" data-home="\${r.home}" data-away="\${r.away}" data-league="\${r.league}">Agregar</button></td>
  </tr>\`).join('')
}
function fill1x2Table(id, rows){
  const tb = document.querySelector('#'+id+' tbody')
  tb.innerHTML = rows.map(r=>{
    const arr=[r.pH||0,r.pD||0,r.pA||0]
    const m = Math.max(...arr)
    const ph = fmtPercent(r.pH||0), pd = fmtPercent(r.pD||0), pa = fmtPercent(r.pA||0)
    const wrap = (val, p)=> (p===m? \`<span class="best">\${val}</span>\` : val)
    return \`<tr>
      <td>\${r.date||''}</td>
      <td>\${r.league||''}</td>
      <td>\${r.match||''}</td>
      <td class="knum">\${wrap(ph, r.pH||0)}</td>
      <td class="knum">\${fmtFair(r.fH)}</td>
      <td class="knum">\${wrap(pd, r.pD||0)}</td>
      <td class="knum">\${fmtFair(r.fD)}</td>
      <td class="knum">\${wrap(pa, r.pA||0)}</td>
      <td class="knum">\${fmtFair(r.fA)}</td>
      <td>
        <div class="row">
          <button class="btn btn-xs" data-add1x2="H" data-prob="\${r.pH}" data-home="\${r.home}" data-away="\${r.away}" data-league="\${r.league}">Agregar 1</button>
          <button class="btn btn-xs" data-add1x2="D" data-prob="\${r.pD}" data-home="\${r.home}" data-away="\${r.away}" data-league="\${r.league}">Agregar X</button>
          <button class="btn btn-xs" data-add1x2="A" data-prob="\${r.pA}" data-home="\${r.home}" data-away="\${r.away}" data-league="\${r.league}">Agregar 2</button>
        </div>
      </td>
    </tr>\`
  }).join('')
}

/* Export predicciones CSV (igual) */
function exportCSV(){
  const head=['date','league','match','market','p_model','p_model_percent','fair_odds']
  const rows = PREDS.map(r=> head.map(k=> r[k]??''))
  let csv = head.join(',')+'\\n'
  for(const r of rows){ csv += r.join(',')+'\\n' }
  const blob = new Blob([csv], {type:'text/csv'})
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='predicciones.csv'; a.click()
}

/* =================== HISTORIAL POR EQUIPO =================== */
function populateHistLeagueOptions(){
  const sel = document.getElementById('histLeague')
  const leagues = Array.from(LEAGUE_TEAMS.keys()).sort()
  sel.innerHTML = '<option value="">(Todas)</option>' + leagues.map(l=> \`<option>\${l}</option>\`).join('')
}
function rebuildTeamHistory(){
  const N = Math.max(3, Math.min(30, Number(document.getElementById('histN').value||5)))
  const leagueFilter = document.getElementById('histLeague').value || null
  const rows = RAW.filter(r=> !r.__manualFixture && r.date && r.home && r.away).slice()
  rows.sort((a,b)=> (a.date||'').localeCompare(b.date||''))
  const perTeam = new Map()
  function push(team, league, date, gf, ga, sotf, sota){
    const key = \`\${league}|||\${team}\`
    if(!perTeam.has(key)) perTeam.set(key, [])
    perTeam.get(key).push({date, league, team, gf, ga, sotf, sota})
  }
  for(const m of rows){
    const gfH = toNum(m.home_goals), gaH = toNum(m.away_goals)
    const gfA = toNum(m.away_goals), gaA = toNum(m.home_goals)
    const soth = toNum(m.home_shotsOT), sota = toNum(m.away_shotsOT)
    const sotah = toNum(m.away_shotsOT), sotaa = toNum(m.home_shotsOT)
    push(m.home, m.league, m.date, gfH, gaH, soth, sota)
    push(m.away, m.league, m.date, gfA, gaA, sotah, sotaa)
  }
  const out=[]
  perTeam.forEach((arr)=>{
    if(!arr.length) return
    const lg = arr[0].league
    if(leagueFilter && lg!==leagueFilter) return
    const pj = arr.length
    const last = arr.slice(-N)
    const avg = (list, k)=> list.length? (list.reduce((s,x)=> s + (toNum(x[k])||0), 0) / list.length) : 0
    const gf = avg(last,'gf'), gc = avg(last,'ga')
    const sotf = avg(last,'sotf'), sota = avg(last,'sota')
    const dif = gf - gc
    out.push({ team:arr[0].team, league:lg, pj, gf, gc, sotf, sota, dif })
  })
  out.sort((a,b)=> b.dif - a.dif)
  const tb = document.querySelector('#tblTeams tbody')
  tb.innerHTML = out.map(r=> \`<tr>
    <td>\${r.team}</td>
    <td>\${r.league}</td>
    <td class="knum">\${r.pj}</td>
    <td class="knum">\${r.gf.toFixed(2)}</td>
    <td class="knum">\${r.gc.toFixed(2)}</td>
    <td class="knum">\${r.sotf.toFixed(2)}</td>
    <td class="knum">\${r.sota.toFixed(2)}</td>
    <td class="knum">\${r.dif.toFixed(2)}</td>
  </tr>\`).join('')
}

/* =================== CARGA MULTIARCHIVO =================== */
function refreshLeagueFilter(data){
  const sel = document.getElementById('fLeague')
  const leagues = Array.from(new Set(data.map(r=> r.league))).filter(Boolean).sort()
  sel.innerHTML = '<option value="">(Todas)</option>' + leagues.map(l=> \`<option>\${l}</option>\`).join('')
}
function afterDataLoaded(){
  buildLeagueTeamsMap(RAW)
  setFiLeagueOptions()
  refreshLeagueFilter(FEAT)
  populateHistLeagueOptions()
  rebuildTeamHistory()
  const inf = document.getElementById('loadInfo')
  inf.textContent = \`Cargados \${FEAT.length} partidos (\${RAW.length} crudos, tras merge & dedupe)\`
}
function parseCSVToRows(text){
  const {data} = parseCSV(text)
  let norm = normalizeObjects(data)
  norm = adaptFromCustomSchema(norm)
  return norm
}
function parseJSONToRows(text){
  let obj
  try{ obj = JSON.parse(text) }catch(e){ throw new Error('JSON invÃ¡lido') }
  let arr = Array.isArray(obj)? obj : (obj && Array.isArray(obj.data)? obj.data : null)
  if(!arr) throw new Error('El JSON debe ser un array de partidos o {data:[...]}.')
  let norm = normalizeObjects(arr)
  norm = adaptFromCustomSchema(norm)
  return norm
}
async function loadMultiFiles(fileList){
  if(!fileList || !fileList.length) return
  const files = Array.from(fileList)
  let allRows = []
  for(const f of files){
    const text = await f.text()
    const name = (f.name||'').toLowerCase()
    try{
      if(name.endsWith('.json')){
        allRows = allRows.concat(parseJSONToRows(text))
      } else {
        try{ allRows = allRows.concat(parseJSONToRows(text)) }
        catch{ allRows = allRows.concat(parseCSVToRows(text)) }
      }
    }catch(err){
      alert(\`Error en \${f.name}: \${err.message||err}\`)
    }
  }
  if(allRows.length===0){ alert('No se pudieron extraer partidos de los archivos seleccionados.'); return }
  allRows = dedupRows(allRows)
  RAW = allRows
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  afterDataLoaded()
  alert(\`Archivos leÃ­dos: \${files.length}\\nPartidos importados (Ãºnicos): \${FEAT.length}\`)
}
function handleCSV(text){ const rows = parseCSVToRows(text); RAW = dedupRows(rows); FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value}); afterDataLoaded(); alert('Datos CSV cargados: '+FEAT.length+' filas.') }
function handleJSON(text){ const rows = parseJSONToRows(text); RAW = dedupRows(rows); FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value}); afterDataLoaded(); alert('Datos JSON cargados: '+FEAT.length+' filas.') }

const DEMO_CSV = `Name,Date,League,Match,Home OnGoal Shots at FT,Away OnGoal Shots at FT,Result FT
Argentina Liga Profesional,vie., 28 jul. 2023 18:30,Argentina Liga Profesional de FÃºtbol,River Plate - Racing Club,6,4,2-1
B,dom., 06 ago. 2023 15:00,Argentina Liga Profesional de FÃºtbol,Boca Juniors - San Lorenzo,7,3,2-0
C,sÃ¡b., 12 ago. 2023 19:00,Argentina Liga Profesional de FÃºtbol,Racing Club - Independiente,5,6,1-1
D,sÃ¡b., 19 ago. 2023 19:00,Argentina Liga Profesional de FÃºtbol,San Lorenzo - River Plate,3,7,1-3
`
const DEMO_JSON = [
  {"Name":"Argentina Liga Profesional","Date":"vie., 28 jul. 2023 18:30","League":"Argentina Liga Profesional de FÃºtbol","Match":"River Plate - Racing Club","Home OnGoal Shots at FT":"6","Away OnGoal Shots at FT":"4","Result FT":"2-1"},
  {"Name":"B","Date":"dom., 06 ago. 2023 15:00","League":"Argentina Liga Profesional de FÃºtbol","Match":"Boca Juniors - San Lorenzo","Home OnGoal Shots at FT":"7","Away OnGoal Shots at FT":"3","Result FT":"2-0"},
  {"Name":"C","Date":"sÃ¡b., 12 ago. 2023 19:00","League":"Argentina Liga Profesional de FÃºtbol","Match":"Racing Club - Independiente","Home OnGoal Shots at FT":"5","Away OnGoal Shots at FT":"6","Result FT":"1-1"},
  {"Name":"D","Date":"sÃ¡b., 19 ago. 2023 19:00","League":"Argentina Liga Profesional de FÃºtbol","Match":"San Lorenzo - River Plate","Home OnGoal Shots at FT":"3","Away OnGoal Shots at FT":"7","Result FT":"1-3"}
]

/* =================== PARTIDOS MANUALES =================== */
function renderFixtures(){
  const tb = document.querySelector('#tblFixtures tbody')
  tb.innerHTML = MANUAL_FIXTURES.map((r,idx)=> \`<tr>
    <td>\${r.date||''}</td>
    <td>\${r.league||''}</td>
    <td>\${r.home||''} vs \${r.away||''}</td>
    <td><button class="btn warn btn-xs" onclick="removeFixture(\${idx})">Quitar</button></td>
  </tr>\`).join('')
}
function removeFixture(idx){
  MANUAL_FIXTURES.splice(idx,1)
  RAW = RAW.filter(r=> !r.__manualFixture).concat(MANUAL_FIXTURES)
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  renderFixtures()
}
function addFixture(){
  const d = (document.getElementById('fiDate').value||'').trim()
  const l = document.getElementById('fiLeague').value
  const h = document.getElementById('fiHome').value
  const a = document.getElementById('fiAway').value
  if(!d || !l || !h || !a){ alert('Fecha, Liga, Local y Visitante son obligatorios.'); return }
  if(h===a){ alert('Local y Visitante deben ser distintos.'); return }
  const row = { date: d, league: l, home: h, away: a, y_over25: null, y_btts: null, y_wdl: null, __manualFixture: true }
  MANUAL_FIXTURES.push(row)
  RAW = RAW.filter(r=> !r.__manualFixture).concat(MANUAL_FIXTURES)
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  renderFixtures(); maybeToggleAddButton()
}

/* =================== HISTORIAL DE APUESTAS (integrado) =================== */
let historial = []
let unidadesChart = null
let bankrollInicial = parseFloat(localStorage.getItem("bankrollInicial")) || 1000

const LS_KEY = "poissonHistorial" // usamos tu misma clave
function genId(){ return Date.now() + Math.random().toString(36).slice(2,7) }
function guardarHistorial(){ localStorage.setItem(LS_KEY, JSON.stringify(historial)) }

/* Cargar historial (compat arrays) */
function cargarHistorial(){
  document.getElementById("bankrollInicialInput").value = bankrollInicial
  try{
    const data = JSON.parse(localStorage.getItem(LS_KEY)) || []
    historial = data.map(row=>{
      if(Array.isArray(row)){
        return {
          id: genId(),
          grupo: row[0] || "",
          opcion: row[1] || "",
          prob: parseFloat(row[2]) || 0,
          cuota: parseFloat(row[3]) || 0,
          ev: parseFloat(row[4]) || 0,
          kelly: row[5] || "",
          stake: parseFloat(row[6]) || 0,
          local: row[7] || "",
          visitante: row[8] || "",
          resultado: row[9] || ""
        }
      }
      return row
    })
  }catch{ historial=[] }
  renderizarTabla(historial)
  actualizarResumen(historial)
  actualizarGrafica(historial)
}

/* Render / filtros / ROI */
function renderizarTabla(datos){
  const tbody = document.querySelector("#tablaHistorial tbody")
  tbody.innerHTML = ""
  const frag = document.createDocumentFragment()
  datos.forEach(row=>{
    const tr = document.createElement("tr")
    if (row.resultado==="ganado") tr.classList.add("ganado")
    if (row.resultado==="perdido") tr.classList.add("perdido")
    if (row.resultado==="push") tr.classList.add("push")

    function tdTxt(v){ const td=document.createElement('td'); td.textContent=v; return td }
    tr.appendChild(tdTxt(row.grupo||'')); tr.appendChild(tdTxt(row.opcion||''))
    tr.appendChild(tdTxt(row.prob)); tr.appendChild(tdTxt(row.cuota))
    tr.appendChild(tdTxt(row.ev)); tr.appendChild(tdTxt(row.kelly))
    tr.appendChild(tdTxt(row.stake)); tr.appendChild(tdTxt(row.local||'')); tr.appendChild(tdTxt(row.visitante||''))

    const tdSel = document.createElement('td')
    const sel = document.createElement('select')
    sel.dataset.id = row.id
    sel.innerHTML = \`
      <option value="">--</option>
      <option value="ganado">Ganado</option>
      <option value="medio_ganado">Medio Ganado</option>
      <option value="push">Push / Nulo</option>
      <option value="medio_perdido">Medio Perdido</option>
      <option value="perdido">Perdido</option>\`
    sel.value = row.resultado || ""
    tdSel.appendChild(sel); tr.appendChild(tdSel)

    const tdAct = document.createElement('td')
    tdAct.innerHTML = \`
      <button class="btn-mini" data-edit="\${row.id}">Editar</button>
      <button class="btn-mini" data-del="\${row.id}" style="border-color:#6b1f1f;color:#ffb3b3">Borrar</button>\`
    tr.appendChild(tdAct)
    frag.appendChild(tr)
  })
  tbody.appendChild(frag)
}
function calcularResumen(datos){
  let gananciaNeta=0, totalInvertido=0, ganadas=0, perdidas=0
  datos.forEach(row=>{
    const {resultado, stake, cuota} = {resultado: row.resultado, stake: parseFloat(row.stake)||0, cuota: parseFloat(row.cuota)||0}
    if (!resultado || stake<=0) return
    switch(resultado){
      case "ganado": gananciaNeta += stake*(cuota-1); ganadas++; break;
      case "medio_ganado": gananciaNeta += stake*(cuota-1)/2; ganadas+=0.5; break;
      case "medio_perdido": gananciaNeta -= stake/2; perdidas+=0.5; break;
      case "perdido": gananciaNeta -= stake; perdidas++; break;
      case "push": default: break;
    }
    totalInvertido += stake
  })
  return {gananciaNeta,totalInvertido,ganadas,perdidas}
}
function actualizarResumen(datos){
  const {gananciaNeta,totalInvertido,ganadas,perdidas} = calcularResumen(datos)
  const roi = totalInvertido>0 ? gananciaNeta/totalInvertido*100 : 0
  const bankrollFinal = bankrollInicial + gananciaNeta
  const color = roi>=0 ? "#79e2a6" : "#ff6b6b"
  document.getElementById("resumenROI").innerHTML =
    \`<b>Bankroll Inicial:</b> $\${bankrollInicial.toFixed(2)} Â· <b>Actual:</b> $\${bankrollFinal.toFixed(2)} Â·
     <b>ROI:</b> <span style="color:\${color}">\${roi.toFixed(2)}%</span> Â·
     <b>Ganancia Neta:</b> $\${gananciaNeta.toFixed(2)} Â·
     <b>W-L:</b> \${ganadas} - \${perdidas} Â·
     <b>Total Apostado:</b> $\${totalInvertido.toFixed(2)}\`
}
function actualizarGrafica(datos){
  let acumulado = bankrollInicial
  const labels = ["Inicio"], unidades = [acumulado.toFixed(2)]
  datos.forEach((row,i)=>{
    const stake = parseFloat(row.stake)||0, cuota=parseFloat(row.cuota)||0
    let cambio = 0
    if (stake>0 && row.resultado){
      if (row.resultado==="ganado") cambio = stake*(cuota-1)
      if (row.resultado==="medio_ganado") cambio = stake*(cuota-1)/2
      if (row.resultado==="medio_perdido") cambio = -stake/2
      if (row.resultado==="perdido") cambio = -stake
      acumulado += cambio
      unidades.push(acumulado.toFixed(2))
      labels.push(\`Bet \${i+1}\`)
    }
  })
  const ctx = document.getElementById('unidadesChart').getContext('2d')
  if (!unidadesChart){
    unidadesChart = new Chart(ctx, {
      type:'line',
      data:{ labels, datasets:[
        {label:'Bankroll', data:unidades, tension:0.2, borderColor:'#7aa2ff', fill:false},
        {label:'Inicial', data:Array(unidades.length).fill(bankrollInicial), borderColor:'#5dd4a4', borderDash:[5,5], pointRadius:0}
      ]},
      options:{ responsive:true, plugins:{legend:{labels:{color:'#e6eaf2'}}}, scales:{ x:{ticks:{color:'#e6eaf2'}}, y:{ticks:{color:'#e6eaf2'}} } }
    })
  } else {
    unidadesChart.data.labels = labels
    unidadesChart.data.datasets[0].data = unidades
    unidadesChart.data.datasets[1].data = Array(unidades.length).fill(bankrollInicial)
    unidadesChart.update()
  }
}

/* Filtros */
function filtrarHistorial(){
  const grupo = document.getElementById("filtroGrupo").value.toLowerCase()
  const local = document.getElementById("filtroLocal").value.toLowerCase()
  const visita = document.getElementById("filtroVisita").value.toLowerCase()
  const probMin = parseFloat(document.getElementById("filtroProb").value)||0
  const evMin = document.getElementById("filtroEvMin").value ? parseFloat(document.getElementById("filtroEvMin").value) : -Infinity
  const evMax = document.getElementById("filtroEvMax").value ? parseFloat(document.getElementById("filtroEvMax").value) : Infinity
  const filtrado = historial.filter(row=>{
    return (row.grupo||'').toLowerCase().includes(grupo) &&
           (row.local||'').toLowerCase().includes(local) &&
           (row.visitante||'').toLowerCase().includes(visita) &&
           (parseFloat(row.prob)||0) >= probMin &&
           (parseFloat(row.ev)||-999) >= evMin &&
           (parseFloat(row.ev)||999) <= evMax
  })
  renderizarTabla(filtrado); actualizarResumen(filtrado); actualizarGrafica(filtrado)
}

/* =================== EVENTOS UI =================== */
document.getElementById('btnDemoCSV').addEventListener('click', ()=> handleCSV(DEMO_CSV))
document.getElementById('btnDemoJSON').addEventListener('click', ()=> handleJSON(JSON.stringify(DEMO_JSON)))
document.getElementById('files').addEventListener('change', (e)=>{ loadMultiFiles(e.target.files) })
document.getElementById('btnEntrenar').addEventListener('click', trainAll)
document.getElementById('btnPicks').addEventListener('click', generateProbabilities)
document.getElementById('btnExport').addEventListener('click', exportCSV)
document.getElementById('btnAddFixture').addEventListener('click', addFixture)
document.getElementById('fiLeague').addEventListener('change', onLeagueChange)
document.getElementById('fiDate').addEventListener('input', maybeToggleAddButton)
document.getElementById('fiHome').addEventListener('change', maybeToggleAddButton)
document.getElementById('fiAway').addEventListener('change', maybeToggleAddButton)
document.getElementById('btnRebuildHist').addEventListener('click', rebuildTeamHistory)
document.getElementById('histLeague').addEventListener('change', rebuildTeamHistory)
document.getElementById('histN').addEventListener('input', rebuildTeamHistory)

/* Eventos Historial */
document.getElementById("btnLimpiarFiltros").addEventListener("click", ()=>{
  ["filtroGrupo","filtroLocal","filtroVisita","filtroProb","filtroEvMin","filtroEvMax"].forEach(id=> document.getElementById(id).value="")
  filtrarHistorial()
})
document.getElementById("btnActualizarBankroll").addEventListener("click", ()=>{
  bankrollInicial = parseFloat(document.getElementById("bankrollInicialInput").value)||0
  localStorage.setItem("bankrollInicial", bankrollInicial)
  filtrarHistorial()
})
document.getElementById("btnExportarHist").addEventListener("click", ()=>{
  const head = ["grupo","opcion","prob","cuota","ev","kelly","stake","local","visitante","resultado"]
  let csv = head.join(",") + "\\n"
  historial.forEach(r=>{
    csv += head.map(k=> r[k]??"").join(",") + "\\n"
  })
  const blob = new Blob([csv], {type:'text/csv'})
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='historial_apuestas.csv'; a.click()
})
document.getElementById("btnBorrarTodo").addEventListener("click", ()=>{
  if(!confirm("Â¿Seguro de borrar todo el historial?")) return
  historial=[]; guardarHistorial(); filtrarHistorial()
})
document.querySelector("#tablaHistorial tbody").addEventListener("change", e=>{
  if(e.target.tagName==="SELECT"){
    const id = e.target.dataset.id
    const row = historial.find(r=>r.id===id)
    if(row){ row.resultado = e.target.value; guardarHistorial(); filtrarHistorial() }
  }
})
document.querySelector("#tablaHistorial tbody").addEventListener("click", e=>{
  const btn = e.target.closest("button")
  if(!btn) return
  const id = btn.dataset.del || btn.dataset.edit
  if(btn.dataset.del){
    historial = historial.filter(r=> r.id!==id); guardarHistorial(); filtrarHistorial()
  } else if(btn.dataset.edit){
    const row = historial.find(r=> r.id===id); if(!row) return
    const cuota = prompt("Nueva cuota (decimal):", row.cuota); if(cuota===null) return
    const stake = prompt("Nuevo stake ($):", row.stake); if(stake===null) return
    const p = clamp((parseFloat(row.prob)||0)/100,0,1)
    const c = Math.max(1, parseFloat(cuota)||1)
    const ev = p*c - 1
    const b = c-1, q=1-p
    const kelly = Math.max(0,(b*p - q)/b)*100
    row.cuota = c.toFixed(2); row.stake = (parseFloat(stake)||0).toFixed(2)
    row.ev = ev.toFixed(3); row.kelly = kelly.toFixed(1)
    guardarHistorial(); filtrarHistorial()
  }
})
document.querySelectorAll(".hist-head input, .hist-head select").forEach(inp=>{
  inp.addEventListener("input", ()=>{})
})
document.querySelectorAll(".row input, .row select, .row textarea").forEach(el=>{
  // noop: placeholder to keep consistent style listeners
})
;["filtroGrupo","filtroLocal","filtroVisita","filtroProb","filtroEvMin","filtroEvMax"].forEach(id=>{
  document.getElementById(id).addEventListener("input", filtrarHistorial)
})

/* Botones "Agregar" en tablas de predicciones */
document.addEventListener('click', (e)=>{
  const btn = e.target.closest('button')
  if(!btn) return
  if(btn.dataset.add==="1"){
    const market = btn.dataset.market
    const prob = Number(btn.dataset.prob)||0
    const home = btn.dataset.home||''
    const away = btn.dataset.away||''
    const league = btn.dataset.league||''
    addPickFromPrediction({grupo: \`\${league} â€” \${market}\`, opcion: market, prob, home, away})
  }
  if(btn.dataset.add1x2){
    const side = btn.dataset.add1x2
    const prob = Number(btn.dataset.prob)||0
    const home = btn.dataset.home||''
    const away = btn.dataset.away||''
    const league = btn.dataset.league||''
    const label = side==="H" ? "1 (Home)" : (side==="D" ? "X (Draw)" : "2 (Away)")
    addPickFromPrediction({grupo: \`\${league} â€” 1X2\`, opcion: label, prob, home, away})
  }
})

/* Init */
document.addEventListener('DOMContentLoaded', ()=>{
  cargarHistorial()
})

</script>
</body>
</html>
