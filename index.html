<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">
<title>Backtesting + Entrenar + Próximos (con equipos por liga)</title>
<style>
  body{margin:0;background:#0f1115;color:#e6eaf2;font:14px/1.45 system-ui,Inter,Segoe UI,Roboto,Arial}
  header{padding:14px 16px;border-bottom:1px solid #2a3140}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  .grid{display:grid;gap:16px}
  @media(min-width:1080px){.grid{grid-template-columns:440px 1fr}}
  .card{background:#171a21;border:1px solid #2a3140;border-radius:12px;padding:14px}
  h1{font-size:18px;margin:0 0 6px} h2{font-size:15px;margin:0 0 10px}
  input,select,button,textarea{width:100%;background:#1f2430;color:#e6eaf2;border:1px solid #2a3140;border-radius:8px;padding:8px}
  .row{display:grid;grid-template-columns:1fr 220px;gap:8px;align-items:center;margin:8px 0}
  .row2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  .btn{background:#7aa2ff;color:#0a1020;font-weight:700;cursor:pointer}
  .pill{display:inline-block;border:1px solid #2a3140;background:#1f2430;border-radius:999px;padding:4px 8px;margin:4px 6px 0 0}
  table{width:100%;border-collapse:collapse;margin-top:10px}
  th,td{border-bottom:1px solid #2a3140;padding:6px;text-align:right}
  th:first-child,td:first-child{text-align:left}
  .muted{color:#9aa3b2;font-size:12px}
  .small{font-size:12px}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
</style>
</head>
<body>
<header class="wrap">
  <h1>Backtesting + Auto-Entrenamiento + Próximos — Equipos por liga</h1>
  <div class="muted">Importa histórico → entrena → backtest → elige próximos con <b>equipos de esa liga</b> y decide con la política.</div>
</header>

<div class="wrap grid">
  <!-- Panel izquierdo -->
  <section class="card">
    <h2>Histórico</h2>
    <div class="row"><label>Archivo JSON</label><input id="file" type="file" accept=".json"></div>
    <div class="row"><label>o Pegar JSON</label><button id="btnPaste" class="btn">Cargar portapapeles</button></div>
    <div class="row"><label>Liga</label><select id="league"><option value="">—</option></select></div>

    <h2>Mercado & Política</h2>
    <div class="row">
      <label>Mercado</label>
      <select id="market">
        <option value="OU">Over/Under</option>
        <option value="BTTS">BTTS (GG)</option>
        <option value="1X2">1X2 (mejor EV)</option>
      </select>
    </div>
    <div class="row" id="ouRow"><label>Línea O/U</label><input id="ou" type="number" step="0.5" value="2.5"></div>
    <div class="row"><label>α (EWMA)</label><input id="alpha" type="number" min="0" max="0.99" step="0.01" value="0.15"></div>
    <div class="row"><label>Discretización</label>
      <select id="disc"><option value="round">Round</option><option value="floor">Floor</option></select>
    </div>
    <div class="row"><label>EV mínimo</label><input id="evThr" type="number" step="0.01" value="0.02"></div>

    <div class="row"><label>Simulaciones</label><input id="nsims" type="number" min="4000" step="1000" value="12000"></div>
    <div class="row"><label>Mín. historial</label><input id="minHist" type="number" min="3" value="8"></div>
    <div class="row"><label>Stake</label><input id="stake" type="number" step="0.1" value="1"></div>

    <div class="row2">
      <button id="train" class="btn">Entrenar y fijar política (AUTO)</button>
      <button id="run" class="btn">Correr Backtest</button>
    </div>

    <h2>Mapeo de cuotas (opcional)</h2>
    <div class="muted">Si tus campos difieren, indícalos (se prueban primero).</div>
    <div class="row"><label>Odd Over 2.5</label><input id="fOddOver" placeholder="Odd Over25 / OddOver25"></div>
    <div class="row"><label>Odd Under 2.5</label><input id="fOddUnder" placeholder="Odd Under25 / OddUnder25"></div>
    <div class="row"><label>Odd BTTS (Sí)</label><input id="fOddBTTS" placeholder="Odd BTTS / Odd GG / Odd"></div>
    <div class="row"><label>Odd 1</label><input id="fOdd1" placeholder="Odd 1 PreMatch"></div>
    <div class="row"><label>Odd X</label><input id="fOddX" placeholder="Odd X PreMatch"></div>
    <div class="row"><label>Odd 2</label><input id="fOdd2" placeholder="Odd 2 PreMatch"></div>

    <p class="muted" id="info">—</p>
  </section>

  <!-- Panel derecho -->
  <section class="card">
    <h2>Resultados (Backtest)</h2>
    <div id="badges" class="muted">—</div>
    <div class="actions" style="margin-top:8px">
      <span class="pill">Bets: <b id="bets">—</b></span>
      <span class="pill">Aciertos: <b id="hits">—</b></span>
      <span class="pill">Hit Rate: <b id="hr">—</b></span>
      <span class="pill">Unidades: <b id="units">—</b></span>
      <span class="pill">ROI: <b id="roi">—</b></span>
    </div>
    <table id="tbl"><thead><tr>
      <th>Fecha</th><th>Partido</th><th>Mercado</th><th>Odd</th><th>p̂</th><th>EV</th><th>Res</th><th>Win</th>
    </tr></thead><tbody></tbody></table>
    <div style="margin-top:10px"><button id="btnCsv" class="btn">Descargar CSV</button></div>
  </section>
</div>

<div class="wrap">
  <section class="card">
    <h2>Próximos partidos (elige equipos de la liga)</h2>
    <div class="small muted" style="margin-bottom:6px">
      Importa JSON (array) con <code>Date</code>, <code>Match</code> (“Local - Visitante”) y cuotas. Se intentará pre-seleccionar los equipos si existen en el catálogo de la liga.
    </div>
    <div class="row"><label>Archivo JSON próximos</label><input id="fileNext" type="file" accept=".json"></div>
    <div class="row"><label>o Pegar JSON</label><button id="btnPasteNext" class="btn">Cargar próximos</button></div>

    <div class="actions" style="margin:8px 0">
      <button id="addRow" class="btn">Agregar fila</button>
      <button id="clearRows" class="btn">Limpiar</button>
      <button id="predict" class="btn">Predecir Próximos</button>
    </div>

    <table id="tblNext">
      <thead>
        <tr>
          <th style="width:120px">Fecha</th>
          <th>Local</th>
          <th>Visitante</th>
          <th id="colOU" style="display:none">Línea OU / Over / Under</th>
          <th id="colBTTS" style="display:none">Odd BTTS Sí</th>
          <th id="col1X2" style="display:none">Odd 1 / X / 2</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <h3 style="margin-top:12px;font-size:14px">Decisiones</h3>
    <table id="tblOutNext"><thead><tr>
      <th>Fecha</th><th>Partido</th><th>Mercado</th><th>Odd</th><th>p̂</th><th>EV</th><th>Decisión</th>
    </tr></thead><tbody></tbody></table>
  </section>
</div>

<script>
// ===== Utilidades =====
const el=id=>document.getElementById(id);
const pct=x=>(x*100).toFixed(2)+'%';
const fmt=x=>(isFinite(x)?x.toFixed(3):'—');
function parseFT(s){const m=String(s||'').match(/(-?\d+)\s*[-:]\s*(-?\d+)/);return m?[+m[1],+m[2]]:[null,null];}
function parseDateAny(s){const d=new Date(s); if(!isNaN(d)) return d; return new Date(NaN);}
function splitTeams(match){
  if(!match) return ['',''];
  const parts = String(match).split(/[-–]/);
  return [ (parts[0]||'').trim(), (parts[1]||'').trim() ];
}
function mean(a){return a.reduce((s,x)=>s+x,0)/a.length;}
function variance(a,mu){let s=0;for(const x of a)s+=(x-mu)*(x-mu);return s/Math.max(1,a.length-1);}
function covariance(X,Y,mx,my){let s=0;for(let i=0;i<X.length;i++)s+=(X[i]-mx)*(Y[i]-my);return s/Math.max(1,X.length-1);}
function ewmaWeights(n,a){if(a<=0)return null;const w=[];for(let i=0;i<n;i++)w.push(Math.pow(1-a,i));w.reverse();return w;}
function meanW(a,w){const sw=w.reduce((s,x)=>s+x,0);let t=0;for(let i=0;i<a.length;i++)t+=a[i]*w[i];return t/(sw||1);}
function varW(a,mu,w){const sw=w.reduce((s,x)=>s+x,0),sw2=w.reduce((s,x)=>s+x*x,0);let s=0;for(let i=0;i<a.length;i++)s+=w[i]*(a[i]-mu)*(a[i]-mu);const c=sw-(sw2/sw);return s/Math.max(1e-9,c);}
function covW(X,Y,mx,my,w){const sw=w.reduce((s,a)=>s+a,0),sw2=w.reduce((s,a)=>s+a*a,0);let s=0;for(let i=0;i<X.length;i++)s+=w[i]*(X[i]-mx)*(Y[i]-my);const c=sw-(sw2/sw);return s/Math.max(1e-9,c);}
function randn(){let u=0,v=0;while(u===0)u=Math.random();while(v===0)v=Math.random();return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);}
function simulateQuick(muH,muA,sdH,sdA,rho,ns,disc,ou){
  const s=Math.sqrt(1-Math.min(0.999,Math.max(-0.999,rho))**2);
  let pOver=0,pUnder=0,pBTTS=0,p1=0,pX=0,p2=0; let nEff=0;
  const nPairs=Math.max(1,Math.floor(ns/2));
  for(let j=0;j<nPairs;j++){
    const z1=randn(), z2=randn();
    for(const a of [1,-1]){
      const X=muH+sdH*(a*z1), Y=muA+sdA*(rho*(a*z1)+s*(a*z2));
      const H=Math.max(0,disc==='round'?Math.round(X):Math.floor(X));
      const A=Math.max(0,disc==='round'?Math.round(Y):Math.floor(Y));
      if(H+A>ou)pOver++; else pUnder++;
      if(H>0&&A>0)pBTTS++;
      if(H>A)p1++; else if(H===A)pX++; else p2++;
      nEff++;
    }
  }
  return {pOver:pOver/nEff,pUnder:pUnder/nEff,pBTTS:pBTTS/nEff,p1:p1/nEff,pX:pX/nEff,p2:p2/nEff};
}

// ===== Estado =====
let RAW=[], BY_LEAGUE=new Map(), TEAMS_BY_LEAGUE=new Map();

el('file').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f)return;
  try{ingest(JSON.parse(await f.text()));}catch(err){alert('Error JSON: '+err);}
});
el('btnPaste').addEventListener('click', async ()=>{
  try{ingest(JSON.parse(await navigator.clipboard.readText()));}catch(err){alert('Portapapeles: '+err);}
});
el('market').addEventListener('change', ()=>{
  const m=el('market').value;
  el('ouRow').style.display=(m==='OU')?'':'none';
  document.getElementById('colOU').style.display   = (m==='OU')?'':'none';
  document.getElementById('colBTTS').style.display = (m==='BTTS')?'':'none';
  document.getElementById('col1X2').style.display  = (m==='1X2')?'':'none';
});
el('league').addEventListener('change', ()=>{
  // Cuando cambie la liga, refrescamos selects de próximos
  refreshNextTeamSelects();
});

function ingest(arr){
  RAW=[]; BY_LEAGUE.clear(); TEAMS_BY_LEAGUE.clear();
  for(const r of arr){
    const league=String(r.League||'').trim(); if(!league) continue;
    const [h,a]=parseFT(r["Result FT"]||r.Result);
    const date=parseDateAny(r.Date||r.date||'');
    const match=String(r.Match||'').trim();
    if(!Number.isFinite(h)||!Number.isFinite(a)||isNaN(date)) continue;
    const [homeName, awayName] = splitTeams(match);
    const row={league,date,match,h,a,homeName,awayName,raw:r};
    RAW.push(row);
    if(!BY_LEAGUE.has(league)) BY_LEAGUE.set(league,[]);
    BY_LEAGUE.get(league).push(row);
    if(!TEAMS_BY_LEAGUE.has(league)) TEAMS_BY_LEAGUE.set(league,new Set());
    const set=TEAMS_BY_LEAGUE.get(league);
    if(homeName) set.add(homeName);
    if(awayName) set.add(awayName);
  }
  for(const rows of BY_LEAGUE.values()) rows.sort((x,y)=>x.date-y.date);
  el('league').innerHTML='<option value="">—</option>'+Array.from(BY_LEAGUE.keys()).sort().map(l=>`<option>${l}</option>`).join('');
  el('info').textContent=`Cargados ${RAW.length} partidos en ${BY_LEAGUE.size} ligas.`;
}

// ===== Odds helpers (histórico) =====
function getOdds_OU(r, fOver, fUnder, line){
  const o=r.raw;
  const cO=[fOver,'Odd Over25','OddOver25','Over25','Over 2.5','OddOver2_5','OddOver2.5'].filter(Boolean);
  const cU=[fUnder,'Odd Under25','OddUnder25','Under25','Under 2.5','OddUnder2_5','OddUnder2.5'].filter(Boolean);
  const over=cO.map(k=>+o[k]).find(x=>x>1.01)||null, under=cU.map(k=>+o[k]).find(x=>x>1.01)||null;
  return {over,under,line};
}
function getOdds_BTTS(r, fBTTS){const o=r.raw;const c=[fBTTS,'Odd BTTS','OddBTTS','Odd GG','OddGG','Odd'].filter(Boolean);
  const yes=c.map(k=>+o[k]).find(x=>x>1.01)||null; return {yes};}
function getOdds_1X2(r, f1,fX,f2){const o=r.raw;
  const o1=+o[f1]||+o['Odd 1 PreMatch']||null;
  const ox=+o[fX]||+o['Odd X PreMatch']||null;
  const o2=+o[f2]||+o['Odd 2 PreMatch']||null;
  return {o1:o1>1.01?o1:null, ox:ox>1.01?ox:null, o2:o2>1.01?o2:null};
}

// ===== Entrenamiento (rejilla) =====
function statsROI(trades, stake=1){
  if(trades.length===0) return {roi:0, units:0, sharpe:0};
  const pnl = trades.map(t=> t.win ? stake*(t.odd-1) : -stake);
  const units = pnl.reduce((s,x)=>s+x,0);
  const roi = units/(trades.length*stake);
  const mu = pnl.reduce((s,x)=>s+x,0)/pnl.length;
  const sd = Math.sqrt(pnl.reduce((s,x)=>s+(x-mu)**2,0)/Math.max(1,pnl.length-1));
  return {roi, units, sharpe: sd>0 ? mu/sd : 0};
}
async function backtestConfig(rows, market, ouLine, alpha, disc, evThr, ns, minHist, oddsMap){
  const trades=[]; const H=[],A=[];
  for(let i=0;i<rows.length;i++){
    const r=rows[i];
    if(H.length<minHist){ H.push(r.h); A.push(r.a); continue; }
    let muH,muA,sdH,sdA,cov,rho;
    if(alpha>0){
      const w=ewmaWeights(H.length,alpha), sw=w.reduce((s,x)=>s+x,0), sw2=w.reduce((s,x)=>s+x*x,0);
      muH=meanW(H,w); muA=meanW(A,w);
      const vH=varW(H,muH,w), vA=varW(A,muA,w), c=covW(H,A,muH,muA,w);
      sdH=Math.sqrt(Math.max(1e-9,vH)); sdA=Math.sqrt(Math.max(1e-9,vA));
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }else{
      muH=mean(H); muA=mean(A);
      sdH=Math.sqrt(Math.max(1e-9,variance(H,muH)));
      sdA=Math.sqrt(Math.max(1e-9,variance(A,muA)));
      const c=covariance(H,A,muH,muA);
      rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }
    const sim = simulateQuick(muH,muA,sdH,sdA,rho,Math.min(ns,8000),disc,ouLine);
    let bet=null, odd=null, p=null, win=0;
    if(market==='OU'){
      const {over,under}=getOdds_OU(r,oddsMap.fOver,oddsMap.fUnder,ouLine);
      const cand=[]; if(over)  cand.push({lab:'Over '+ouLine, p:sim.pOver,  odd:over,  win:(r.h+r.a>ouLine)?1:0});
                      if(under) cand.push({lab:'Under '+ouLine,p:sim.pUnder, odd:under, win:(r.h+r.a<=ouLine)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick && pick.ev>=evThr){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;}
    }else if(market==='BTTS'){
      const {yes}=getOdds_BTTS(r,oddsMap.fBTTS);
      if(yes){const pBTTS=sim.pBTTS, ev=pBTTS*(yes-1)-(1-pBTTS); if(ev>=evThr){bet='BTTS Sí';p=pBTTS;odd=yes;win=(r.h>0&&r.a>0)?1:0;}}
    }else{
      const {o1,ox,o2}=getOdds_1X2(r,oddsMap.f1,oddsMap.fX,oddsMap.f2);
      const cand=[]; if(o1)cand.push({lab:'1',p:sim.p1,odd:o1,win:(r.h>r.a)?1:0});
                     if(ox)cand.push({lab:'X',p:sim.pX,odd:ox,win:(r.h===r.a)?1:0});
                     if(o2)cand.push({lab:'2',p:sim.p2,odd:o2,win:(r.h<r.a)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick && pick.ev>=evThr){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;}
    }
    if(bet) trades.push({odd,win});
    H.push(r.h); A.push(r.a);
  }
  return statsROI(trades, 1);
}
async function entrenarYSeleccionar(rows, market, ouLine, ns, minHist, oddsMap){
  const ALPHAS=[0.05,0.10,0.15,0.20], DISCS=['round','floor'], EVS=[0.00,0.02,0.04];
  let best=null;
  for(const alpha of ALPHAS)for(const disc of DISCS)for(const evThr of EVS){
    const r=await backtestConfig(rows,market,ouLine,alpha,disc,evThr,ns,minHist,oddsMap);
    const score=0.7*r.roi+0.3*r.sharpe;
    if(!best||score>best.score) best={alpha,disc,evThr,roi:r.roi,sharpe:r.sharpe,score};
  }
  return best;
}

// ===== Botones: Entrenar & Backtest =====
el('train').addEventListener('click', async ()=>{
  const L=el('league').value; if(!L){alert('Elige una liga.');return;}
  const rows=(BY_LEAGUE.get(L)||[]).slice(); if(rows.length< +el('minHist').value + 5){alert('Muy pocos partidos para entrenar.');return;}
  const market=el('market').value, ou=+el('ou').value||2.5, ns=+el('nsims').value||12000, minHist=Math.max(3,+el('minHist').value||8);
  const oddsMap={fOver:el('fOddOver').value.trim(),fUnder:el('fOddUnder').value.trim(),fBTTS:el('fOddBTTS').value.trim(),f1:el('fOdd1').value.trim(),fX:el('fOddX').value.trim(),f2:el('fOdd2').value.trim()};
  el('info').textContent='Entrenando (rejilla)…';
  const best=await entrenarYSeleccionar(rows,market,ou,ns,minHist,oddsMap);
  el('alpha').value=best.alpha.toFixed(2); el('disc').value=best.disc; el('evThr').value=best.evThr.toFixed(2);
  el('info').textContent=`Política: α=${best.alpha.toFixed(2)}, ${best.disc}, EV≥${best.evThr.toFixed(2)} | ROI=${pct(best.roi)} Sharpe=${fmt(best.sharpe)}`;
});
el('run').addEventListener('click', ()=>{
  const L=el('league').value; if(!L){alert('Elige una liga.');return;}
  const rows=(BY_LEAGUE.get(L)||[]).slice();
  const ns=Math.max(4000,Math.floor(+el('nsims').value||12000));
  const alpha=Math.max(0,Math.min(0.99,+el('alpha').value||0.15));
  const disc=el('disc').value; const ou=+el('ou').value||2.5; const minHist=Math.max(3,Math.floor(+el('minHist').value||8));
  const stake=+el('stake').value||1; const market=el('market').value; const evMin=+el('evThr').value||0;
  const fOver=el('fOddOver').value.trim(), fUnder=el('fOddUnder').value.trim(), fBTTS=el('fOddBTTS').value.trim(), f1=el('fOdd1').value.trim(), fX=el('fOddX').value.trim(), f2=el('fOdd2').value.trim();

  let bets=0,hits=0,units=0; const outRows=[]; const H=[],A=[];
  for(const r of rows){
    if(H.length<minHist){ H.push(r.h); A.push(r.a); continue; }
    let muH,muA,sdH,sdA,cov,rho;
    if(alpha>0){ const w=ewmaWeights(H.length,alpha); muH=meanW(H,w); muA=meanW(A,w);
      const vH=varW(H,muH,w), vA=varW(A,muA,w), c=covW(H,A,muH,muA,w);
      sdH=Math.sqrt(Math.max(1e-9,vH)); sdA=Math.sqrt(Math.max(1e-9,vA)); rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }else{ muH=mean(H); muA=mean(A);
      sdH=Math.sqrt(Math.max(1e-9,variance(H,muH))); sdA=Math.sqrt(Math.max(1e-9,variance(A,muA)));
      const c=covariance(H,A,muH,muA); rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
    }
    const sim=simulateQuick(muH,muA,sdH,sdA,rho,ns,disc,ou);
    let bet=null,odd=null,p=null,win=0,res='';
    if(market==='OU'){ const {over,under,line}=getOdds_OU(r,fOver,fUnder,ou);
      const cand=[]; if(over)cand.push({lab:'Over '+line,p:sim.pOver,odd:over,win:(r.h+r.a>line)?1:0});
                     if(under)cand.push({lab:'Under '+line,p:sim.pUnder,odd:under,win:(r.h+r.a<=line)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick && pick.ev>=evMin){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;} res=(r.h+r.a)+'g';
    }else if(market==='BTTS'){ const {yes}=getOdds_BTTS(r,fBTTS);
      if(yes){const pBTTS=sim.pBTTS, ev=pBTTS*(yes-1)-(1-pBTTS); if(ev>=evMin){bet='BTTS Sí';p=pBTTS;odd=yes;win=(r.h>0&&r.a>0)?1:0;}} res=r.h+'-'+r.a;
    }else{ const {o1,ox,o2}=getOdds_1X2(r,f1,fX,f2);
      const cand=[]; if(o1)cand.push({lab:'1',p:sim.p1,odd:o1,win:(r.h>r.a)?1:0});
                     if(ox)cand.push({lab:'X',p:sim.pX,odd:ox,win:(r.h===r.a)?1:0});
                     if(o2)cand.push({lab:'2',p:sim.p2,odd:o2,win:(r.h<r.a)?1:0});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick && pick.ev>=evMin){bet=pick.lab;p=pick.p;odd=pick.odd;win=pick.win;} res=r.h+'-'+r.a;
    }
    if(bet){ bets++; hits+=win; units += win? stake*(odd-1) : -stake;
      outRows.push({date:r.date.toISOString().slice(0,10),match:r.match,market:bet,odd:odd?.toFixed(2),p_hat:p?.toFixed(3),EV:(p*(odd-1)-(1-p)).toFixed(3),result:res,win:win?'✔':'✖'});}
    H.push(r.h); A.push(r.a);
  }
  const roi=bets? (units/(bets*stake)) : 0;
  el('bets').textContent=bets; el('hits').textContent=hits; el('hr').textContent=bets?pct(hits/bets):'—';
  el('units').textContent=fmt(units); el('roi').textContent=bets?pct(roi):'—';
  el('badges').innerHTML=`<span class="pill">Liga: <b>${L}</b></span><span class="pill">Mercado: <b>${market}</b></span><span class="pill">α: <b>${alpha}</b></span><span class="pill">Disc: <b>${disc}</b></span><span class="pill">EV≥ <b>${evMin}</b></span><span class="pill">#Sims: <b>${ns}</b></span><span class="pill">MinHist: <b>${minHist}</b></span>`;
  const tb=document.querySelector('#tbl tbody');
  tb.innerHTML = outRows.slice(0,200).map(r=>`<tr><td>${r.date}</td><td>${r.match}</td><td>${r.market}</td><td>${r.odd}</td><td>${r.p_hat}</td><td>${r.EV}</td><td>${r.result}</td><td>${r.win}</td></tr>`).join('')
    || `<tr><td colspan="8" class="muted">No hubo apuestas con EV ≥ umbral.</td></tr>`;
  el('btnCsv').onclick=()=>{
    const rowsCsv=[['date','match','market','odd','p_hat','EV','result','win']]
      .concat(outRows.map(r=>[r.date,r.match,r.market,r.odd,r.p_hat,r.EV,r.result,r.win]));
    const csv=rowsCsv.map(r=>r.join(',')).join('\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`backtest_${L}_${market}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };
});

// ===== Próximos: UI con equipos por liga =====
const tbNext = document.querySelector('#tblNext tbody');

function getLeagueTeams(league){
  const set = TEAMS_BY_LEAGUE.get(league);
  if(!set) return [];
  return Array.from(set).sort((a,b)=>a.localeCompare(b,'es',{sensitivity:'base'}));
}

function teamSelectHTML(options, selected=''){
  const opts = ['<option value="">—</option>'].concat(options.map(t=>{
    const sel = (t===selected)?' selected':'';
    return `<option${sel}>${t}</option>`;
  }));
  return `<select>${opts.join('')}</select>`;
}

function renderRow(next={date:'',home:'',away:'',over:'',under:'',line:'2.5',btts:'',o1:'',ox:'',o2:''}){
  const m=el('market').value;
  const L=el('league').value;
  const teams=getLeagueTeams(L);
  const tr=document.createElement('tr');
  tr.innerHTML = `
    <td><input type="date" value="${next.date||''}"></td>
    <td>${teamSelectHTML(teams, next.home)}</td>
    <td>${teamSelectHTML(teams, next.away)}</td>
    <td ${m==='OU'?'':'style="display:none"'}><div class="row2" style="grid-template-columns:80px 1fr 1fr">
      <input placeholder="Línea" value="${next.line||'2.5'}">
      <input placeholder="Over"  value="${next.over||''}">
      <input placeholder="Under" value="${next.under||''}">
    </div></td>
    <td ${m==='BTTS'?'':'style="display:none"'}><input placeholder="Odd BTTS Sí" value="${next.btts||''}"></td>
    <td ${m==='1X2'?'':'style="display:none"'}><div class="row2">
      <input placeholder="Odd 1" value="${next.o1||''}">
      <input placeholder="Odd X" value="${next.ox||''}">
      <input placeholder="Odd 2" value="${next.o2||''}">
    </div></td>`;
  tbNext.appendChild(tr);
}

function refreshNextTeamSelects(){
  const L=el('league').value, teams=getLeagueTeams(L);
  [...tbNext.querySelectorAll('tr')].forEach(tr=>{
    const tds=tr.querySelectorAll('td'); if(tds.length<3) return;
    const homeSel=tds[1].querySelector('select');
    const awaySel=tds[2].querySelector('select');
    const curH=homeSel?.value||'', curA=awaySel?.value||'';
    if(homeSel) homeSel.outerHTML = teamSelectHTML(teams, curH);
    if(awaySel) awaySel.outerHTML = teamSelectHTML(teams, curA);
  });
}

el('addRow').addEventListener('click', ()=>{
  if(!el('league').value){ alert('Elige una liga primero.'); return; }
  renderRow();
});
el('clearRows').addEventListener('click', ()=>{tbNext.innerHTML='';});

// Importar JSON de próximos (intenta mapear equipos al catálogo)
el('fileNext').addEventListener('change', async e=>{
  const f=e.target.files[0]; if(!f)return;
  try{ const arr=JSON.parse(await f.text()); loadNextFromJson(arr); }catch(err){alert('Error JSON próximos: '+err);}
});
el('btnPasteNext').addEventListener('click', async ()=>{
  try{ const arr=JSON.parse(await navigator.clipboard.readText()); loadNextFromJson(arr); }catch(err){alert('Portapapeles próximos: '+err);}
});
function nearestTeamName(name, teams){
  // emparejamiento simple por igualdad flexible
  const n=String(name||'').trim().toLowerCase();
  const found = teams.find(t=>t.toLowerCase()===n);
  if(found) return found;
  // contiene palabras clave
  const hit = teams.find(t=> n && (t.toLowerCase().includes(n) || n.includes(t.toLowerCase())) );
  return hit || '';
}
function loadNextFromJson(arr){
  if(!el('league').value){ alert('Elige una liga primero.'); return; }
  const teams=getLeagueTeams(el('league').value);
  tbNext.innerHTML='';
  for(const r of arr){
    const date =(r.Date||r.date||'').slice(0,10);
    const [mh,ma]=splitTeams(r.Match||'');
    const home = nearestTeamName(mh, teams) || mh || '';
    const away = nearestTeamName(ma, teams) || ma || '';
    renderRow({
      date, home, away,
      line: (r.Line||r.line||'2.5'),
      over: (r['Odd Over25']||r.Over25||r['Over 2.5']||r.Over||''),
      under:(r['Odd Under25']||r.Under25||r['Under 2.5']||r.Under||''),
      btts: (r['Odd BTTS']||r['Odd GG']||r.Odd||''),
      o1: (r['Odd 1 PreMatch']||r.Odd1||''), ox:(r['Odd X PreMatch']||r.OddX||''), o2:(r['Odd 2 PreMatch']||r.Odd2||'')
    });
  }
}

// ===== Próximos: calcular y decidir =====
el('predict').addEventListener('click', ()=>{
  const L=el('league').value; if(!L){alert('Elige una liga para usar su histórico.');return;}
  const hist=(BY_LEAGUE.get(L)||[]).slice(); if(hist.length< +el('minHist').value){alert('Poco histórico para calibrar.');return;}

  const alpha=+el('alpha').value||0.15, disc=el('disc').value, ns=+el('nsims').value||12000;
  const market=el('market').value; const evMin=+el('evThr').value||0;
  const ouDefault = +el('ou').value||2.5;

  // parámetros de liga usando TODO el histórico (EWMA si aplica)
  const H=hist.map(r=>r.h), A=hist.map(r=>r.a);
  let muH,muA,sdH,sdA,cov,rho;
  if(alpha>0){const w=ewmaWeights(H.length,alpha); muH=meanW(H,w); muA=meanW(A,w);
    const vH=varW(H,muH,w), vA=varW(A,muA,w), c=covW(H,A,muH,muA,w);
    sdH=Math.sqrt(Math.max(1e-9,vH)); sdA=Math.sqrt(Math.max(1e-9,vA)); rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
  }else{ muH=mean(H); muA=mean(A);
    sdH=Math.sqrt(Math.max(1e-9,variance(H,muH))); sdA=Math.sqrt(Math.max(1e-9,variance(A,muA)));
    const c=covariance(H,A,muH,muA); rho=Math.max(-0.999,Math.min(0.999,c/(sdH*sdA)));
  }

  const out=[]; const rows=[...tbNext.querySelectorAll('tr')];
  for(const tr of rows){
    const tds=tr.querySelectorAll('td'); if(!tds.length) continue;
    const date=tds[0].querySelector('input').value||'';
    const home=tds[1].querySelector('select').value||''; const away=tds[2].querySelector('select').value||'';
    let bet=null, odd=null, p=null, ev=null, desc=`${home} vs ${away}`;
    const ouLine = (market==='OU') ? +(tds[3].querySelectorAll('input')[0].value||ouDefault) : ouDefault;
    const sim=simulateQuick(muH,muA,sdH,sdA,rho,ns,disc, ouLine);

    if(market==='OU'){
      const over = +tds[3].querySelectorAll('input')[1].value||NaN;
      const under= +tds[3].querySelectorAll('input')[2].value||NaN;
      const cand=[];
      if(over>1.01)  cand.push({lab:'Over '+ouLine,  p:sim.pOver,  odd:over});
      if(under>1.01) cand.push({lab:'Under '+ouLine, p:sim.pUnder, odd:under});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick){bet=pick.lab; p=pick.p; odd=pick.odd; ev=pick.ev;}
    }else if(market==='BTTS'){
      const btts = +tds[3].querySelector('input').value||NaN;
      if(btts>1.01){ bet='BTTS Sí'; p=sim.pBTTS; odd=btts; ev=p*(odd-1)-(1-p); }
    }else{
      const ins=tds[3].querySelectorAll('input');
      const o1=+ins[0].value||NaN, ox=+ins[1].value||NaN, o2=+ins[2].value||NaN;
      const cand=[]; if(o1>1.01)cand.push({lab:'1',p:sim.p1,odd:o1}); if(ox>1.01)cand.push({lab:'X',p:sim.pX,odd:ox}); if(o2>1.01)cand.push({lab:'2',p:sim.p2,odd:o2});
      cand.forEach(c=>c.ev=c.p*(c.odd-1)-(1-c.p)); cand.sort((a,b)=>b.ev-a.ev);
      const pick=cand[0]; if(pick){bet=pick.lab; p=pick.p; odd=pick.odd; ev=pick.ev;}
    }

    const decision = (ev!=null && ev>=evMin) ? 'APOSTAR' : 'NO APOSTAR';
    out.push({date,match:desc,market:bet||'-',odd:isFinite(odd)?odd.toFixed(2):'-',p_hat:isFinite(p)?p.toFixed(3):'-',EV:isFinite(ev)?ev.toFixed(3):'-',decision});
  }

  const tb=document.querySelector('#tblOutNext tbody');
  tb.innerHTML = out.map(r=>`<tr>
    <td>${r.date||'-'}</td><td>${r.match}</td><td>${r.market}</td><td>${r.odd}</td><td>${r.p_hat}</td><td>${r.EV}</td><td>${r.decision}</td>
  </tr>`).join('') || `<tr><td colspan="7" class="muted">Agrega o importa próximos partidos.</td></tr>`;
});
</script>
</body>
</html>