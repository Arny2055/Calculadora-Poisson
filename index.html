<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Predicción Fútbol — Probabilidades (Over, BTTS, 1X2) + Elo + Priors</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel2:#1f2430; --text:#e6eaf2; --muted:#9aa3b2;
    --accent:#7aa2ff; --accent2:#5dd4a4; --warn:#ffb84d; --danger:#ff6b6b; --ok:#79e2a6;
    --border:#2a3140;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 "Inter",system-ui,-apple-system,Segoe UI,Roboto}
  main{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;font-weight:800;letter-spacing:.2px;margin:0 0 12px}
  h2{font-size:16px;font-weight:700;margin:18px 0 10px;color:var(--accent)}
  .sub{color:var(--muted);font-size:13px;margin-top:2px}
  .grid{display:grid;gap:16px}
  .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .card{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--border);border-radius:16px;padding:16px;box-shadow:0 4px 16px #0005}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--accent);border:none;color:#0b1020;font-weight:700;padding:10px 14px;border-radius:12px;cursor:pointer}
  .btn.alt{background:var(--accent2)}
  .btn.ghost{background:transparent;border:1px solid var(--border);color:#var(--text)}
  .btn.warn{background:var(--warn);color:#000}
  .btn:disabled{opacity:.55;cursor:not-allowed}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#111521;color:#fff}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--border);text-align:left}
  th{font-size:12px;color:var(--muted);font-weight:600}
  tr:hover td{background:#0f1422}
  .badge{display:inline-block;padding:3px 8px;border-radius:999px;font-size:11px;font-weight:700}
  .good{background:#0a3823;color:#94f3c1;border:1px solid #1a7b50}
  .bad{background:#3a1c1c;color:#ffb3b3;border:1px solid #7b1f1f}
  .mid{background:#2c2a11;color:#ffe9a1;border:1px solid #685c1c}
  .knum{font-variant-numeric:tabular-nums}
  .footer{color:var(--muted);font-size:12px;margin:24px 0 16px}
  .pill{background:#121a2a;border:1px solid var(--border);color:#9aa3b2;padding:6px 10px;border-radius:999px;font-size:12px}
  .split{display:flex;gap:16px;flex-wrap:wrap}
  .nowrap{white-space:nowrap}

  /* Gráficas: no desbordar */
  .charts{display:grid;gap:12px}
  .charts.g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
  .charts.g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  .chart-wrap{position:relative;width:100%;max-width:100%}
  canvas{display:block;width:100% !important;height:auto !important;max-height:260px}

  @media (max-width: 900px){
    .g-3{grid-template-columns:1fr}
    .g-2{grid-template-columns:1fr}
    .charts.g-3,.charts.g-2{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<main>
  <h1>BET MEXICO 🇲🇽</h1>
  <div class="sub">Carga <b>CSV o JSON</b> con histórico, entrena (80%/20% temporal), agrega partidos manuales y obtén <b>probabilidades calibradas</b> y <b>cuotas justas</b> (1/p). Sin cuotas de mercado.</div>

  <!-- CONTROLES PRINCIPALES -->
  <section class="grid g-3" style="margin-top:16px">
    <div class="card">
      <h2>1) Datos</h2>
      <div class="row">
        <input id="file" type="file" accept=".csv,.txt,.json,application/json" />
        <button class="btn ghost" id="btnDemoCSV">Demo CSV</button>
        <button class="btn ghost" id="btnDemoJSON">Demo JSON</button>
      </div>
      <p class="sub" style="margin-top:8px">Formato flexible con columnas tipo <span class="pill">Match</span>, <span class="pill">Date</span>, <span class="pill">Home OnGoal Shots at FT</span>… Se adapta automáticamente.</p>
    </div>

    <div class="card">
      <h2>2) Entrenamiento</h2>
      <div class="grid g-2">
        <div>
          <label>Rolling ventana corta</label>
          <input id="rollShort" type="number" value="6" min="3" max="12"/>
        </div>
        <div>
          <label>Rolling ventana larga</label>
          <input id="rollLong" type="number" value="18" min="5" max="30"/>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="btnEntrenar" class="btn">Entrenar modelos</button>
        <button id="btnPicks" class="btn alt" disabled>Calcular probabilidades</button>
        <button id="btnExport" class="btn ghost" disabled>Exportar predicciones (CSV)</button>
      </div>
      <p class="sub">Usamos: Elo con decaimiento, pesos por recencia y clase, priors por liga y calibración isotónica por liga.</p>
    </div>

    <div class="card">
      <h2>3) Filtro de vista</h2>
      <div>
        <label>Liga (para ver predicciones)</label>
        <select id="fLeague"><option value="">(Todas)</option></select>
      </div>
    </div>
  </section>

  <!-- 4) PARTIDOS MANUALES -->
  <section class="card" style="margin-top:8px">
    <h2>4) Partidos a analizar (manual)</h2>
    <div class="grid g-3">
      <div>
        <label>Fecha (YYYY-MM-DD)</label>
        <input id="fiDate" type="date" />
      </div>
      <div>
        <label>Liga</label>
        <select id="fiLeague"><option value="">(elige una liga)</option></select>
      </div>
      <div class="grid g-2" style="gap:8px">
        <div>
          <label>Local</label>
          <select id="fiHome" disabled><option value="">—</option></select>
        </div>
        <div>
          <label>Visitante</label>
          <select id="fiAway" disabled><option value="">—</option></select>
        </div>
      </div>
      <div style="display:flex;align-items:flex-end">
        <button id="btnAddFixture" class="btn" disabled>Agregar partido</button>
      </div>
    </div>
    <div class="sub" style="margin-top:8px">Solo equipos que existan en tu histórico para esa liga.</div>

    <table id="tblFixtures" class="tbl-small" style="margin-top:10px">
      <thead><tr>
        <th>Fecha</th><th>Liga</th><th>Partido</th><th></th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- MÉTRICAS Y GRÁFICOS (Over/BTTS) -->
  <section class="grid g-2" style="margin-top:16px">
    <div class="card">
      <h2>Métricas — Over 2.5</h2>
      <div class="split">
        <div>
          <div class="sub">Brier: <b id="brierO" class="knum">—</b> · LogLoss: <b id="loglossO" class="knum">—</b></div>
          <div class="sub">Calibración: <span id="calibO" class="badge mid">—</span></div>
        </div>
      </div>
      <div class="chart-wrap"><canvas id="chartReliabO"></canvas></div>
    </div>
    <div class="card">
      <h2>Métricas — BTTS</h2>
      <div class="split">
        <div>
          <div class="sub">Brier: <b id="brierB" class="knum">—</b> · LogLoss: <b id="loglossB" class="knum">—</b></div>
          <div class="sub">Calibración: <span id="calibB" class="badge mid">—</span></div>
        </div>
      </div>
      <div class="chart-wrap"><canvas id="chartReliabB"></canvas></div>
    </div>
  </section>

  <!-- MÉTRICAS Y GRÁFICOS (1X2) -->
  <section class="card" style="margin-top:16px">
    <h2>Métricas — 1X2</h2>
    <div class="sub">Calibración por clase (Home, Draw, Away) en validación temporal con isotónica por liga.</div>
    <div class="split">
      <div class="sub">Brier (prom): <b id="brier1x2" class="knum">—</b> · LogLoss (prom): <b id="logloss1x2" class="knum">—</b> · Calibración: <span id="calib1x2" class="badge mid">—</span></div>
    </div>
    <div class="charts g-3" style="margin-top:10px">
      <div class="chart-wrap"><canvas id="chartReliabH"></canvas></div>
      <div class="chart-wrap"><canvas id="chartReliabD"></canvas></div>
      <div class="chart-wrap"><canvas id="chartReliabA"></canvas></div>
    </div>
  </section>

  <!-- HISTORIAL POR EQUIPO -->
  <section class="card" style="margin-top:16px">
    <h2>5) Historial por equipo</h2>
    <div class="row">
      <div style="min-width:220px">
        <label>Liga</label>
        <select id="histLeague"><option value="">(Todas)</option></select>
      </div>
      <div>
        <label>Ventana (N partidos recientes)</label>
        <input id="histN" type="number" value="5" min="3" max="30" />
      </div>
      <button class="btn" id="btnRebuildHist">Recalcular</button>
    </div>
    <table id="tblTeams" class="tbl-small" style="margin-top:10px">
      <thead>
        <tr>
          <th>Equipo</th><th>Liga</th><th class="nowrap">PJ</th>
          <th class="nowrap">GFØ(N)</th><th class="nowrap">GCØ(N)</th>
          <th class="nowrap">SoT ForØ(N)</th><th class="nowrap">SoT AgØ(N)</th>
          <th class="nowrap">DifØ(N)</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- TABLAS DE PREDICCIONES -->
  <section class="grid g-2" style="margin-top:16px">
    <div class="card">
      <h2>Predicciones — Over 2.5</h2>
      <table id="tblOver">
        <thead><tr>
          <th>Fecha</th><th>Liga</th><th>Partido</th>
          <th>p_model (%)</th><th>Cuota justa</th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="card">
      <h2>Predicciones — BTTS</h2>
      <table id="tblBTTS">
        <thead><tr>
          <th>Fecha</th><th>Liga</th><th>Partido</th>
          <th>p_model (%)</th><th>Cuota justa</th>
        </tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section class="card" style="margin-top:16px">
    <h2>Predicciones — 1X2</h2>
    <table id="tbl1x2">
      <thead><tr>
        <th>Fecha</th><th>Liga</th><th>Partido</th>
        <th>Home %</th><th>Cuota H</th>
        <th>Draw %</th><th>Cuota X</th>
        <th>Away %</th><th>Cuota A</th>
      </tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <div class="footer">Modelado: logística binaria (Over, BTTS) + softmax (1X2) con SGD, L2, pesos por recencia y clase; features de forma (rolling), Elo con decaimiento, priors por liga; calibración isotónica <b>por liga</b> con respaldo global. Probabilidades calibradas en porcentaje y cuotas justas.</div>
</main>

<script>
// =================== UTILIDADES BÁSICAS ===================
const parseCSV = (text) => {
  const lines = text.replace(/\r/g,'').split('\n').filter(l=>l.trim().length>0)
  const head = lines[0].split(',').map(h=>h.trim())
  const rows = []
  for(let i=1;i<lines.length;i++){
    const raw = lines[i]
    const vals = []
    let cur='', inQ=false
    for(let j=0;j<raw.length;j++){
      const c = raw[j]
      if(c==='"') { inQ=!inQ; continue }
      if(c===',' && !inQ){ vals.push(cur); cur=''; }
      else cur+=c
    }
    vals.push(cur)
    const obj = {}
    head.forEach((h,idx)=> obj[h]= (vals[idx]??'').trim() )
    rows.push(obj)
  }
  return {columns: head, data: rows}
}
const toNum = (v)=> v===''||v==null? null : Number(v)
const clamp=(x,a,b)=> Math.max(a, Math.min(b, x))
const safeDate = (s)=>{ const d=new Date(s); return isNaN(d)? null : d }
const daysBetween = (a,b)=> Math.max(0, Math.round((b-a)/86400000))

// Normaliza keys: snake_case
function normalizeObjects(arr){
  const normKey = (k)=> k.toLowerCase().trim().replace(/[^a-z0-9]+/g,'_').replace(/^_|_$/g,'')
  return arr.map(r=>{ const o={}; for(const k of Object.keys(r)){ o[normKey(k)] = (''+r[k]).trim() } return o })
}

// Fecha “vie., 28 jul. 2023 18:30” -> YYYY-MM-DD
function parseSpanishDate(s){
  if(!s) return null;
  const months={ene:1,feb:2,mar:3,abr:4,may:5,jun:6,jul:7,ago:8,sep:9,oct:10,nov:11,dic:12};
  const m = String(s).toLowerCase().match(/(\d{1,2})\s+([a-záéíóú\.]{3,})\.?\s+(\d{4})/i);
  if(!m){ const d=new Date(s); return isNaN(d)? null : d.toISOString().slice(0,10) }
  const day = String(m[1]).padStart(2,'0');
  const monKey = m[2].slice(0,3).normalize('NFD').replace(/[\u0300-\u036f\.]/g,'');
  const mon = months[monKey]; const year=m[3];
  if(!mon) return null;
  return `${year}-${String(mon).padStart(2,'0')}-${day}`;
}
function splitMatch(s){ if(!s) return {home:null,away:null}; const p=String(s).split('-'); return {home:(p[0]||'').trim(), away:(p[1]||'').trim()} }
function numSafe(v){ const n=Number(String(v).replace(/[^0-9\.-]/g,'')); return isNaN(n)? null : n }

// =================== ADAPTADOR ESQUEMA (sin cuotas) ===================
function adaptFromCustomSchema(arr){
  return arr.map(r=>{
    if(r.date && r.home && r.away) return r;

    const out = {};
    out.date = parseSpanishDate(r.date) || parseSpanishDate(r._date) || parseSpanishDate(r.league) || parseSpanishDate(r.name) || r.date || null;
    out.league = r.league || r.name || r.argentina_liga_profesional_de_futbol || r.argentina_liga_profesional || '';

    const m = splitMatch(r.match);
    out.home = m.home || r.home;
    out.away = m.away || r.away;

    if(r.result_ft){
      const mm = String(r.result_ft).match(/(\d+)\s*-\s*(\d+)/);
      if(mm){ out.home_goals=numSafe(mm[1]); out.away_goals=numSafe(mm[2]); }
    }

    out.home_shotsOT = numSafe(r.home_ongoal_shots_at_ft);
    out.away_shotsOT = numSafe(r.away_ongoal_shots_at_ft);
    out.home_total_shots = numSafe(r.home_total_shots_at_ft);
    out.away_total_shots = numSafe(r.away_total_shots_at_ft);
    out.home_poss = numSafe(r.home_ball_possession_at_ft);
    out.away_poss = numSafe(r.away_ball_possession_at_ft);
    out.home_corners = numSafe(r.home_corners_at_ft);
    out.away_corners = numSafe(r.away_corners_at_ft);
    out.home_yellowcards_at_ft = numSafe(r.home_yellowcards_at_ft);
    out.away_yellowcards_at_ft = numSafe(r.away_yellowcards_at_ft);
    out.home_redcards_at_ft = numSafe(r.home_redcards_at_ft);
    out.away_redcards_at_ft = numSafe(r.away_redcards_at_ft);

    out.home_xg = numSafe(out.home_xg);
    out.away_xg = numSafe(out.away_xg);
    out.home_ppda = numSafe(out.home_ppda);
    out.away_ppda = numSafe(out.away_ppda);
    out.home_rest = numSafe(out.home_rest);
    out.away_rest = numSafe(out.away_rest);
    out.referee_fouls_pg = numSafe(out.referee_fouls_pg);
    out.humidity = numSafe(out.humidity);
    out.temp = numSafe(out.temp);

    return out;
  });
}

// =================== FEATURE ENGINEERING + ELO ===================
let TEAM_ELO = new Map(); // team -> rating

function getElo(team){ return TEAM_ELO.get(team) ?? 1500 }
function setElo(team, val){ TEAM_ELO.set(team, val) }
function expectedFromElo(eA, eB, hAdv=60){
  const qa = Math.pow(10, (eA + hAdv - eB)/400)
  const qb = 1
  const pHome = qa/(qa+qb)
  return [pHome, 1-pHome]
}
function updateEloRow(row, K=16, hAdv=60){
  if(row.home_goals==null || row.away_goals==null) return
  const h = row.home, a = row.away
  const Eh = getElo(h), Ea = getElo(a)
  const [pH] = expectedFromElo(Eh, Ea, hAdv)
  const y = (row.home_goals>row.away_goals)?1 : (row.home_goals===row.away_goals?0.5:0)
  const halfLife = 240
  const ageDays = row._ageDays ?? 0
  const decay = Math.pow(0.5, ageDays/halfLife)
  const Kd = K*decay
  const newH = Eh + Kd * (y - pH)
  const newA = Ea + Kd * ((1-y) - (1-pH))
  setElo(h, newH); setElo(a, newA)
}
function addEloFeature(rows){
  if(!rows.length) return
  const lastDate = safeDate(rows[rows.length-1].date) || new Date()
  for(const r of rows){ const d = safeDate(r.date)||lastDate; r._ageDays = daysBetween(d, lastDate) }
  TEAM_ELO = new Map()
  for(const r of rows){
    const Eh = getElo(r.home), Ea = getElo(r.away)
    r.f_eloDiff = (Eh - Ea)
    updateEloRow(r)
  }
}

function engineerFeatures(rows, opts){
  const rS = Number(opts.rollShort||5), rL = Number(opts.rollLong||10)
  rows.sort((a,b)=> (a.date||'').localeCompare(b.date||''))
  for(const r of rows){
    r.home_goals = toNum(r.home_goals); r.away_goals = toNum(r.away_goals)
    ;['home_xg','away_xg','home_shotsOT','away_shotsOT','home_ppda','away_ppda','home_rest','away_rest','referee_fouls_pg','humidity','temp']
      .forEach(k=> r[k] = toNum(r[k]))
  }
  const hist = new Map()
  function pushTeam(team, isHome, m){
    const key = team||'__NA__'
    if(!hist.has(key)) hist.set(key, [])
    const entry = {
      date: m.date||'',
      league: m.league||'',
      for_xg: isHome? (m.home_xg??null): (m.away_xg??null),
      ag_xg:  isHome? (m.away_xg??null): (m.home_xg??null),
      for_soT:isHome? (m.home_shotsOT??null): (m.away_shotsOT??null),
      ag_soT: isHome? (m.away_shotsOT??null): (m.home_shotsOT??null),
      ppda:   isHome? (m.home_ppda??null): (m.away_ppda??null),
      rest:   isHome? (m.home_rest??null): (m.away_rest??null),
      goals_for: isHome? (m.home_goals??null): (m.away_goals??null),
      goals_ag:  isHome? (m.away_goals??null): (m.home_goals??null),
      team: team
    }
    hist.get(key).push(entry)
  }
  for(const m of rows){ pushTeam(m.home,true,m); pushTeam(m.away,false,m) }

  function rollingStats(team, date){
    const h = (hist.get(team||'__NA__')||[]).filter(x=> (x.date||'') < (date||''))
    const take = (arr,n)=> arr.slice(-n)
    const s5 = take(h,rS), sL = take(h,rL)
    const avg=(arr,key)=>{ if(arr.length===0) return null; let s=0,c=0; for(const x of arr){ if(x[key]!=null){ s+=x[key]; c++ } } return c? s/c : null }
    return {
      s_for_xg: avg(s5,'for_xg'), s_ag_xg: avg(s5,'ag_xg'),
      l_for_xg: avg(sL,'for_xg'), l_ag_xg: avg(sL,'ag_xg'),
      s_for_soT: avg(s5,'for_soT'), s_ag_soT: avg(s5,'ag_soT'),
      s_ppda: avg(s5,'ppda'), l_ppda: avg(sL,'ppda'),
      s_rest: avg(s5,'rest'), l_rest: avg(sL,'rest'),
      s_goal_diff: (avg(s5,'goals_for')??0) - (avg(s5,'goals_ag')??0),
      l_goal_diff: (avg(sL,'goals_for')??0) - (avg(sL,'goals_ag')??0),
    }
  }

  for(const m of rows){
    const fH = rollingStats(m.home, m.date)
    const fA = rollingStats(m.away, m.date)
    m.f_for_xg = (fH.s_for_xg??0) - (fA.s_for_xg??0)
    m.f_ag_xg  = (fH.s_ag_xg??0)  - (fA.s_ag_xg??0)
    m.f_soT    = (fH.s_for_soT??0) - (fA.s_for_soT??0)
    m.f_ppda   = (fA.s_ppda??0) - (fH.s_ppda??0)
    m.f_rest   = (fH.s_rest??0) - (fA.s_rest??0)
    m.f_goalD  = (fH.s_goal_diff??0) - (fA.s_goal_diff??0)

    m.clima_hum = m.humidity ?? 50
    m.clima_temp = m.temp ?? 18
    m.ref_fouls = m.referee_fouls_pg ?? 22

    if(m.home_goals!=null && m.away_goals!=null){
      const tot = m.home_goals + m.away_goals
      m.y_over25 = (tot>2)?1:0
      m.y_btts = (m.home_goals>0 && m.away_goals>0)?1:0
      m.y_wdl = (m.home_goals>m.away_goals)?0 : ((m.home_goals===m.away_goals)?1:2) // 0:H,1:D,2:A
    } else {
      m.y_over25 = null; m.y_btts = null; m.y_wdl = null
    }
  }

  // Elo (añade f_eloDiff)
  addEloFeature(rows)

  return rows
}

// =================== PRIORS POR LIGA ===================
let PRIORS = null
function computeLeaguePriors(rows){
  const byL = new Map()
  for(const r of rows){
    if(r.y_over25==null || r.y_btts==null || r.y_wdl==null) continue
    const L = r.league||'__'
    if(!byL.has(L)) byL.set(L,{o:0,b:0,d:0,n:0})
    const s = byL.get(L)
    s.o += r.y_over25; s.b += r.y_btts; s.d += (r.y_wdl===1?1:0); s.n += 1
  }
  const pri = new Map()
  byL.forEach((v,k)=> pri.set(k,{
    pOver: v.n? v.o/v.n : 0.55,
    pBTTS: v.n? v.b/v.n : 0.52,
    pDraw: v.n? v.d/v.n : 0.26
  }))
  return pri
}
function addPriorsToRows(rows, priMap){
  for(const r of rows){
    const p = priMap?.get(r.league) || {pOver:0.55,pBTTS:0.52,pDraw:0.26}
    r.f_priorOver = p.pOver
    r.f_priorBTTS = p.pBTTS
    r.f_priorDraw = p.pDraw
  }
}

// =================== DISEÑOS + PESOS ===================
function makeDesignBinary(rows, target){
  // columnas comunes + prior específico y Elo
  const colsBase = ['f_for_xg','f_ag_xg','f_soT','f_ppda','f_rest','f_goalD','clima_hum','clima_temp','ref_fouls','f_eloDiff']
  const priorCol = (target==='over'?'f_priorOver':'f_priorBTTS')
  const cols = colsBase.concat([priorCol])

  // frecuencias para balanceo
  const freq = new Map()
  rows.forEach(r=>{
    const y = (target==='over'? r.y_over25 : r.y_btts)
    if(y!=null) freq.set(y,(freq.get(y)||0)+1)
  })
  const total = Array.from(freq.values()).reduce((a,b)=>a+b,0) || 1
  const invFreq = new Map(); freq.forEach((c,k)=> invFreq.set(k, total/(c||1)))

  // recencia
  const lastDate = safeDate(rows[rows.length-1]?.date)||new Date()

  const X=[], y=[], w=[], leagues=[]
  for(const r of rows){
    const yi = (target==='over'? r.y_over25 : r.y_btts)
    if(yi==null) continue
    const row = cols.map(c=> (r[c]==null? 0 : Number(r[c])))
    X.push(row); y.push(yi); leagues.push(r.league||'__')
    const ageDays = daysBetween(safeDate(r.date)||lastDate, lastDate)
    const wRec = Math.pow(0.5, ageDays/240)
    const wCls = invFreq.get(yi)||1
    w.push(wRec * wCls)
  }

  const mu = Array(X[0]?.length||0).fill(0), sd = Array(X[0]?.length||0).fill(0)
  if(X.length){
    for(let j=0;j<mu.length;j++){
      let s=0; for(let i=0;i<X.length;i++) s+=X[i][j]; mu[j]=s/X.length
      let v=0; for(let i=0;i<X.length;i++){ const d=X[i][j]-mu[j]; v+=d*d } sd[j]=Math.sqrt(v/Math.max(1,X.length-1))||1
      for(let i=0;i<X.length;i++) X[i][j]=(X[i][j]-mu[j])/sd[j]
    }
  }
  return {X,y,w,cols,mu,sd, leagues}
}

function makeDesignMulticlass(rows){
  const cols = ['f_for_xg','f_ag_xg','f_soT','f_ppda','f_rest','f_goalD','clima_hum','clima_temp','ref_fouls','f_eloDiff','f_priorDraw']

  // frecuencias por clase
  const freq = new Map()
  rows.forEach(r=>{
    const y=r.y_wdl
    if(y!=null) freq.set(y,(freq.get(y)||0)+1)
  })
  const total = Array.from(freq.values()).reduce((a,b)=>a+b,0) || 1
  const invFreq = new Map(); [0,1,2].forEach(k=> invFreq.set(k, total/((freq.get(k)||1))))

  const lastDate = safeDate(rows[rows.length-1]?.date)||new Date()

  const X=[], y=[], w=[], leagues=[]
  for(const r of rows){
    if(r.y_wdl==null) continue
    const row = cols.map(c=> (r[c]==null? 0 : Number(r[c])))
    X.push(row); y.push(r.y_wdl); leagues.push(r.league||'__')
    const ageDays = daysBetween(safeDate(r.date)||lastDate, lastDate)
    const wRec = Math.pow(0.5, ageDays/240)
    const wCls = invFreq.get(r.y_wdl)||1
    w.push(wRec * wCls)
  }

  const mu = Array(X[0]?.length||0).fill(0), sd = Array(X[0]?.length||0).fill(0)
  if(X.length){
    for(let j=0;j<mu.length;j++){
      let s=0; for(let i=0;i<X.length;i++) s+=X[i][j]; mu[j]=s/X.length
      let v=0; for(let i=0;i<X.length;i++){ const d=X[i][j]-mu[j]; v+=d*d } sd[j]=Math.sqrt(v/Math.max(1,X.length-1))||1
      for(let i=0;i<X.length;i++) X[i][j]=(X[i][j]-mu[j])/sd[j]
    }
  }
  return {X,y,w,cols,mu,sd,K:3, leagues}
}

// =================== MODELOS (SGD ponderado) ===================
function trainLogReg(design, epochs=400, lr=0.05, l2=0.001){
  const {X,y,w} = design
  const d = X[0]?.length||0
  let W = Array(d).fill(0), b=0
  for(let ep=0; ep<epochs; ep++){
    for(let i=0;i<X.length;i++){
      const xi = X[i], yi=y[i], wi=w[i]||1
      let z=b; for(let j=0;j<d;j++) z+= W[j]*xi[j]
      const p = 1/(1+Math.exp(-z))
      const err = (p-yi)*wi
      for(let j=0;j<d;j++){ W[j] -= lr*(err*xi[j] + l2*W[j]) }
      b -= lr*err
    }
  }
  return {w:W,b}
}
function predictLogReg(design, model, rowObj){
  const x = design.cols.map(c=> rowObj[c]==null?0:Number(rowObj[c]))
  for(let j=0;j<x.length;j++) x[j]=(x[j]-design.mu[j])/design.sd[j]
  let z=model.b; for(let j=0;j<x.length;j++) z+= model.w[j]*x[j]
  return 1/(1+Math.exp(-z))
}
function softmax(arr){
  const m = Math.max(...arr)
  const exps = arr.map(v=> Math.exp(v-m))
  const s = exps.reduce((a,b)=>a+b,0)
  return exps.map(v=> v/s)
}
function trainSoftmax(design, epochs=400, lr=0.05, l2=0.001){
  const {X,y,w,K} = design
  const d = X[0]?.length||0
  let W = Array.from({length:K}, ()=> Array(d).fill(0))
  let b = Array(K).fill(0)
  for(let ep=0; ep<epochs; ep++){
    for(let i=0;i<X.length;i++){
      const xi = X[i], yi = y[i], wi = w[i]||1
      const z = b.map((bk,k)=> bk + W[k].reduce((s,wj,j)=> s + wj*xi[j], 0))
      const m = Math.max(...z); const exps = z.map(v=> Math.exp(v-m))
      const s = exps.reduce((a,b)=>a+b,0); const p = exps.map(v=> v/s)
      for(let k=0;k<K;k++){
        const yk = (yi===k)?1:0
        const err = (p[k]-yk)*wi
        for(let j=0;j<d;j++){ W[k][j] -= lr*(err*xi[j] + l2*W[k][j]) }
        b[k] -= lr*err
      }
    }
  }
  return {W,b,K}
}
function predictSoftmax(design, model, rowObj){
  const x = design.cols.map(c=> rowObj[c]==null?0:Number(rowObj[c]))
  for(let j=0;j<x.length;j++) x[j]=(x[j]-design.mu[j])/design.sd[j]
  const z = model.b.map((bk,k)=> bk + model.W[k].reduce((s,wj,j)=> s + wj*x[j], 0))
  return softmax(z) // [pH,pD,pA]
}

// =================== ISOTÓNICA (global + por liga) ===================
function isotonicFit(probs, labels){
  const n = probs.length
  if(!n) return []
  let xy = []
  for(let i=0;i<n;i++) xy.push({x:probs[i], n:1, y:labels[i]})
  xy.sort((a,b)=> a.x-b.x)
  for(let i=0;i<xy.length;){
    let j=i
    while(j<xy.length-1 && xy[j].y/xy[j].n > xy[j+1].y/xy[j+1].n){
      xy[j+1] = {x: xy[j].x+xy[j+1].x, n: xy[j].n+xy[j+1].n, y: xy[j].y+xy[j+1].y}
      xy.splice(j,1); j=Math.max(0,j-1); if(j===0) break
    }
    i++
  }
  let out=[]
  let accx=0, accn=0, accy=0
  for(const b of xy){ accx+=b.x; accn+=b.n; accy+=b.y; out.push({x:clamp(accx/accn,0,1), y:clamp(accy/accn,0,1)}) }
  return out
}
function isotonicPredict(fit, p){
  if(!fit || fit.length===0) return p
  for(let i=0;i<fit.length-1;i++){
    if(p>=fit[i].x && p<=fit[i+1].x){
      const t=(p-fit[i].x)/(fit[i+1].x-fit[i].x+1e-9)
      return fit[i].y + t*(fit[i+1].y - fit[i].y)
    }
  }
  if(p<fit[0].x) return fit[0].y
  return fit[fit.length-1].y
}
function fitIsoByLeague(preds, labels, leagues){
  // preds, labels, leagues: arrays alineados (validación)
  const byL = new Map()
  for(let i=0;i<preds.length;i++){
    const L = leagues[i]||'__'
    if(!byL.has(L)) byL.set(L, {p:[],y:[]})
    byL.get(L).p.push(preds[i]); byL.get(L).y.push(labels[i])
  }
  const out = new Map()
  byL.forEach((v,k)=>{
    const fit = v.p.length>=20 ? isotonicFit(v.p, v.y) : [] // mínimo para estabilidad
    out.set(k, fit)
  })
  const globalFit = isotonicFit(preds, labels)
  return {byLeague: out, globalFit}
}
function isoPredictByLeague(isoObj, league, p){
  const fitL = isoObj.byLeague.get(league||'__')
  const fit = (fitL && fitL.length)? fitL : isoObj.globalFit
  return isotonicPredict(fit, p)
}

// =================== MÉTRICAS ===================
const brier = (p,y)=> { if(!p.length) return NaN; let s=0; for(let i=0;i<p.length;i++){ const d=(p[i]-y[i]); s+=d*d } return s/p.length }
const logloss = (p,y)=>{ if(!p.length) return NaN; let s=0; for(let i=0;i<p.length;i++){ const pi=clamp(p[i],1e-7,1-1e-7); s += -(y[i]*Math.log(pi)+(1-y[i])*Math.log(1-pi)) } return s/p.length }
function brierMulti(P, Y){
  if(!P.length) return NaN
  let s=0
  for(let i=0;i<P.length;i++){
    const yH = (Y[i]===0)?1:0, yD=(Y[i]===1)?1:0, yA=(Y[i]===2)?1:0
    const e = (P[i][0]-yH)**2 + (P[i][1]-yD)**2 + (P[i][2]-yA)**2
    s += e/3
  }
  return s/P.length
}
function loglossMulti(P,Y){
  if(!P.length) return NaN
  let s=0
  for(let i=0;i<P.length;i++){
    const pi = clamp(P[i][Y[i]],1e-7,1-1e-7)
    s += -Math.log(pi)
  }
  return s/P.length
}

// =================== ENTRENAMIENTO / INFERENCIA ===================
let RAW=[], FEAT=[]
let designO, modelO, isoO // bin Over
let designB, modelB, isoB // bin BTTS
let designWDL, modelWDL, isoH, isoD, isoA // 1x2
let PREDS=[] // export
let MANUAL_FIXTURES=[]
let LEAGUE_TEAMS = new Map()

// ----- Liga -> Set(Equipos)
function buildLeagueTeamsMap(data){
  LEAGUE_TEAMS = new Map()
  for(const r of data){
    if(r.__manualFixture) continue
    const league = r.league||''
    const home = r.home||''
    const away = r.away||''
    if(!league || !(home||away)) continue
    if(!LEAGUE_TEAMS.has(league)) LEAGUE_TEAMS.set(league, new Set())
    const s = LEAGUE_TEAMS.get(league)
    if(home) s.add(home)
    if(away) s.add(away)
  }
}
function setFiLeagueOptions(){
  const sel = document.getElementById('fiLeague')
  const leagues = Array.from(LEAGUE_TEAMS.keys()).sort()
  sel.innerHTML = '<option value="">(elige una liga)</option>' + leagues.map(l=> `<option>${l}</option>`).join('')
  sel.disabled = leagues.length===0
  setTeamOptions([], 'fiHome'); setTeamOptions([], 'fiAway')
  document.getElementById('fiHome').disabled = true
  document.getElementById('fiAway').disabled = true
  maybeToggleAddButton()
}
function setTeamOptions(teams, idSel){
  const sel = document.getElementById(idSel)
  const opts = teams.map(t=> `<option>${t}</option>`).join('')
  sel.innerHTML = '<option value="">(elige)</option>' + opts
}
function onLeagueChange(){
  const league = document.getElementById('fiLeague').value
  const homeSel = document.getElementById('fiHome')
  const awaySel = document.getElementById('fiAway')
  if(!league){
    setTeamOptions([], 'fiHome'); setTeamOptions([], 'fiAway')
    homeSel.disabled = true; awaySel.disabled = true
    maybeToggleAddButton()
    return
  }
  const teams = Array.from(LEAGUE_TEAMS.get(league)||[]).sort()
  setTeamOptions(teams, 'fiHome'); setTeamOptions(teams, 'fiAway')
  homeSel.disabled = false; awaySel.disabled = false
  homeSel.value=''; awaySel.value=''
  maybeToggleAddButton()
}
function maybeToggleAddButton(){
  const d = (document.getElementById('fiDate').value||'').trim()
  const league = document.getElementById('fiLeague').value
  const h = document.getElementById('fiHome').value
  const a = document.getElementById('fiAway').value
  const btn = document.getElementById('btnAddFixture')
  btn.disabled = !(d && league && h && a && h!==a)
}

// ----- Entrenar y métricas
function trainAll(){
  if(!FEAT.length){ alert('Primero carga datos históricos.'); return }
  let pool = FEAT.filter(r=> r.y_over25!=null && r.y_btts!=null && r.y_wdl!=null)
  if(pool.length < 60){
    alert('Pocas filas con resultado para entrenar (min. recomendado: 60). Carga más histórico.');
  }

  // Split 80/20 temporal
  const cut = Math.floor(pool.length*0.8)
  const trainSet = pool.slice(0,cut)
  const validSet = pool.slice(cut)

  // Priors por liga a todo el dataset (para que estén en train/valid y futuros)
  PRIORS = computeLeaguePriors(trainSet)
  addPriorsToRows(FEAT, PRIORS)

  // Diseños + entrenamiento ponderado
  designO = makeDesignBinary(trainSet, 'over'); modelO = trainLogReg(designO)
  designB = makeDesignBinary(trainSet, 'btts'); modelB = trainLogReg(designB)
  designWDL = makeDesignMulticlass(trainSet); modelWDL = trainSoftmax(designWDL)

  // Validación para calibrar (por liga y global)
  const pO=[], yO=[], lO=[]
  const pB=[], yB=[], lB=[]
  const P1x2=[], Y1x2=[], L1x2=[]
  for(const r of validSet){
    const p1 = predictLogReg(designO, modelO, r)
    const p2 = predictLogReg(designB, modelB, r)
    pO.push(p1); yO.push(r.y_over25); lO.push(r.league||'__')
    pB.push(p2); yB.push(r.y_btts);   lB.push(r.league||'__')

    const q = predictSoftmax(designWDL, modelWDL, r) // [H,D,A]
    P1x2.push(q); Y1x2.push(r.y_wdl); L1x2.push(r.league||'__')
  }

  // Calibración por liga
  const fitO = fitIsoByLeague(pO,yO,lO)
  const fitB = fitIsoByLeague(pB,yB,lB)
  // Para multiclase calibramos cada clase por separado
  const pH = P1x2.map(q=>q[0]), yH = Y1x2.map(v=> v===0?1:0)
  const pD = P1x2.map(q=>q[1]), yD = Y1x2.map(v=> v===1?1:0)
  const pA = P1x2.map(q=>q[2]), yA = Y1x2.map(v=> v===2?1:0)
  const fitH = fitIsoByLeague(pH,yH,L1x2)
  const fitD = fitIsoByLeague(pD,yD,L1x2)
  const fitA = fitIsoByLeague(pA,yA,L1x2)
  isoO = fitO; isoB = fitB; isoH = fitH; isoD = fitD; isoA = fitA

  // Métricas post-calibración
  const pOc = pO.map((p,i)=> isoPredictByLeague(isoO, lO[i], p))
  const pBc = pB.map((p,i)=> isoPredictByLeague(isoB, lB[i], p))
  document.getElementById('brierO').textContent = (pOc.length? brier(pOc,yO).toFixed(4): '—')
  document.getElementById('loglossO').textContent = (pOc.length? logloss(pOc,yO).toFixed(4): '—')
  document.getElementById('brierB').textContent = (pBc.length? brier(pBc,yB).toFixed(4): '—')
  document.getElementById('loglossB').textContent = (pBc.length? logloss(pBc,yB).toFixed(4): '—')
  setBadge('calibO', calibScore(pOc,yO))
  setBadge('calibB', calibScore(pBc,yB))
  renderReliability('chartReliabO', pOc, yO)
  renderReliability('chartReliabB', pBc, yB)

  // Métricas 1x2 calibradas por liga
  const Pc = P1x2.map((q,i)=>[
    isoPredictByLeague(isoH, L1x2[i], q[0]),
    isoPredictByLeague(isoD, L1x2[i], q[1]),
    isoPredictByLeague(isoA, L1x2[i], q[2]),
  ])
  for(const q of Pc){ const s=q[0]+q[1]+q[2]; if(s>0){ q[0]/=s; q[1]/=s; q[2]/=s } }
  const b1 = brierMulti(Pc,Y1x2)
  const l1 = loglossMulti(Pc,Y1x2)
  document.getElementById('brier1x2').textContent = isFinite(b1)? b1.toFixed(4) : '—'
  document.getElementById('logloss1x2').textContent = isFinite(l1)? l1.toFixed(4) : '—'
  setBadge('calib1x2', calibScoreMulti(Pc,Y1x2))

  renderReliability('chartReliabH', Pc.map(q=>q[0]), Y1x2.map(v=> v===0?1:0))
  renderReliability('chartReliabD', Pc.map(q=>q[1]), Y1x2.map(v=> v===1?1:0))
  renderReliability('chartReliabA', Pc.map(q=>q[2]), Y1x2.map(v=> v===2?1:0))

  document.getElementById('btnPicks').disabled = false
  populateHistLeagueOptions()
  rebuildTeamHistory()
}
function setBadge(id, score){
  const el = document.getElementById(id)
  el.textContent = score.txt
  el.className = 'badge ' + score.cls
}
function calibScore(p,y){
  if(!p.length) return {txt:'—', cls:'mid'}
  const bins = binReliability(p,y)
  let s=0; for(const b of bins){ s += Math.abs(b.acc - b.conf) }
  const d = s/bins.length
  if(d<0.02) return {txt:'Excelente', cls:'good'}
  if(d<0.05) return {txt:'Buena', cls:'mid'}
  return {txt:'Mejorable', cls:'bad'}
}
function calibScoreMulti(Pc, Y){
  const pH = Pc.map(q=>q[0]), yH = Y.map(v=> v===0?1:0)
  const pD = Pc.map(q=>q[1]), yD = Y.map(v=> v===1?1:0)
  const pA = Pc.map(q=>q[2]), yA = Y.map(v=> v===2?1:0)
  const d = (avgAbsBinDiff(pH,yH)+avgAbsBinDiff(pD,yD)+avgAbsBinDiff(pA,yA))/3
  if(d<0.02) return {txt:'Excelente', cls:'good'}
  if(d<0.05) return {txt:'Buena', cls:'mid'}
  return {txt:'Mejorable', cls:'bad'}
}

// ===== CALCULAR PROBABILIDADES =====
function generateProbabilities(){
  if(!designO || !designB || !designWDL){ alert('Primero entrena los modelos.'); return }
  const league = document.getElementById('fLeague').value

  // Asegurar que priors estén en fixtures agregados tras el entrenamiento
  addPriorsToRows(FEAT, PRIORS||new Map())

  const future = FEAT
    .filter(r=> r.__manualFixture === true)
    .filter(r=> !league || r.league===league)

  if(future.length===0){
    alert('No hay partidos manuales agregados. Usa la sección 4) para añadir Local vs Visitante.');
    return
  }

  const outO=[], outB=[], out1x2=[]
  PREDS = []

  for(const r of future){
    // Over / BTTS calibrados por liga
    const pOver = isoPredictByLeague(isoO, r.league, predictLogReg(designO, modelO, r))
    const pBTTS = isoPredictByLeague(isoB, r.league, predictLogReg(designB, modelB, r))

    const fairOver = pOver>0 ? (1/pOver) : null
    const fairBTTS = pBTTS>0 ? (1/pBTTS) : null

    outO.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, p_model:pOver, fair:fairOver})
    PREDS.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, market:'Over 2.5', p_model:pOver, p_model_percent:(pOver*100).toFixed(1), fair_odds: fairOver? fairOver.toFixed(2):''})

    outB.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, p_model:pBTTS, fair:fairBTTS})
    PREDS.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, market:'BTTS Yes', p_model:pBTTS, p_model_percent:(pBTTS*100).toFixed(1), fair_odds: fairBTTS? fairBTTS.toFixed(2):''})

    // 1X2 calibrado por liga (cada clase), re-normalizado
    let q = predictSoftmax(designWDL, modelWDL, r) // [H,D,A]
    q = [
      isoPredictByLeague(isoH, r.league, q[0]),
      isoPredictByLeague(isoD, r.league, q[1]),
      isoPredictByLeague(isoA, r.league, q[2]),
    ]
    const s=q[0]+q[1]+q[2]; if(s>0){ q[0]/=s; q[1]/=s; q[2]/=s }

    const fairH = q[0]>0? 1/q[0] : null
    const fairD = q[1]>0? 1/q[1] : null
    const fairA = q[2]>0? 1/q[2] : null

    out1x2.push({
      date:r.date, league:r.league, match:`${r.home} vs ${r.away}`,
      pH:q[0], pD:q[1], pA:q[2], fH:fairH, fD:fairD, fA:fairA
    })

    PREDS.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, market:'1 (Home)', p_model:q[0], p_model_percent:(q[0]*100).toFixed(1), fair_odds: fairH? fairH.toFixed(2):''})
    PREDS.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, market:'X (Draw)', p_model:q[1], p_model_percent:(q[1]*100).toFixed(1), fair_odds: fairD? fairD.toFixed(2):''})
    PREDS.push({date:r.date, league:r.league, match:`${r.home} vs ${r.away}`, market:'2 (Away)', p_model:q[2], p_model_percent:(q[2]*100).toFixed(1), fair_odds: fairA? fairA.toFixed(2):''})
  }

  outO.sort((a,b)=> b.p_model-a.p_model)
  outB.sort((a,b)=> b.p_model-a.p_model)
  out1x2.sort((a,b)=> (b.pH - a.pH))

  fillPredTable('tblOver', outO)
  fillPredTable('tblBTTS', outB)
  fill1x2Table('tbl1x2', out1x2)

  document.getElementById('btnExport').disabled = PREDS.length===0
}

function fmtPercent(x){ return (x*100).toFixed(1) + '%' }
function fmtFair(x){ return x? x.toFixed(2) : '—' }

function fillPredTable(id, rows){
  const tb = document.querySelector(`#${id} tbody`)
  tb.innerHTML = rows.map(r=> `<tr>
    <td>${r.date||''}</td>
    <td>${r.league||''}</td>
    <td>${r.match||''}</td>
    <td class="knum">${fmtPercent(r.p_model??0)}</td>
    <td class="knum">${fmtFair(r.fair)}</td>
  </tr>`).join('')
}
function fill1x2Table(id, rows){
  const tb = document.querySelector(`#${id} tbody`)
  tb.innerHTML = rows.map(r=> `<tr>
    <td>${r.date||''}</td>
    <td>${r.league||''}</td>
    <td>${r.match||''}</td>
    <td class="knum">${fmtPercent(r.pH??0)}</td>
    <td class="knum">${fmtFair(r.fH)}</td>
    <td class="knum">${fmtPercent(r.pD??0)}</td>
    <td class="knum">${fmtFair(r.fD)}</td>
    <td class="knum">${fmtPercent(r.pA??0)}</td>
    <td class="knum">${fmtFair(r.fA)}</td>
  </tr>`).join('')
}

function exportCSV(){
  const head=['date','league','match','market','p_model','p_model_percent','fair_odds']
  const rows = PREDS.map(r=> head.map(k=> r[k]??''))
  let csv = head.join(',')+'\n'
  for(const r of rows){ csv += r.join(',')+'\n' }
  const blob = new Blob([csv], {type:'text/csv'})
  const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='predicciones.csv'; a.click()
}

// =================== RELIABILITY PLOTS ===================
function binReliability(p,y, nb=10){
  if(!p.length) return []
  const idx = p.map((v,i)=>[v,i]).sort((a,b)=> a[0]-b[0]).map(x=>x[1])
  const n = p.length, size = Math.max(1, Math.floor(n/nb))
  const out=[]
  for(let b=0;b<nb;b++){
    const start = b*size, end = (b===nb-1? n: (b+1)*size)
    if(start>=n) break
    let sP=0,sY=0,c=0
    for(let i=start;i<end;i++){ const k=idx[i]; sP+=p[k]; sY+=y[k]; c++ }
    if(c>0) out.push({conf:sP/c, acc:sY/c, n:c})
  }
  return out
}
function renderReliability(canvasId, p, y){
  const bins = binReliability(p,y)
  const ctx = document.getElementById(canvasId).getContext('2d')
  if(ctx._chart){ ctx._chart.destroy() }
  if(!bins.length){ ctx.canvas.replaceWith(ctx.canvas.cloneNode(true)); return }
  const labels = bins.map((_,i)=> `${(i/bins.length*100).toFixed(0)}–${((i+1)/bins.length*100).toFixed(0)}%`)
  const data1 = bins.map(b=> b.acc)
  const data2 = bins.map(b=> b.conf)
  ctx._chart = new Chart(ctx, { type:'line', data:{ labels, datasets:[ {label:'Exactitud', data:data1}, {label:'Confianza', data:data2} ]}, options:{ responsive:true, interaction:{mode:'index',intersect:false}, maintainAspectRatio:true, scales:{ y:{min:0,max:1} } } })
}
function avgAbsBinDiff(p,y){
  const bins = binReliability(p,y)
  if(!bins.length) return 1
  let s=0; for(const b of bins){ s += Math.abs(b.acc - b.conf) }
  return s/bins.length
}

// =================== HISTORIAL POR EQUIPO ===================
function populateHistLeagueOptions(){
  const sel = document.getElementById('histLeague')
  const leagues = Array.from(LEAGUE_TEAMS.keys()).sort()
  sel.innerHTML = '<option value="">(Todas)</option>' + leagues.map(l=> `<option>${l}</option>`).join('')
}
function rebuildTeamHistory(){
  const N = Math.max(3, Math.min(30, Number(document.getElementById('histN').value||5)))
  const leagueFilter = document.getElementById('histLeague').value || null

  const rows = RAW.filter(r=> !r.__manualFixture && r.date && r.home && r.away).slice()
  rows.sort((a,b)=> (a.date||'').localeCompare(b.date||''))

  const perTeam = new Map()
  function push(team, league, date, gf, ga, sotf, sota){
    const key = `${league}|||${team}`
    if(!perTeam.has(key)) perTeam.set(key, [])
    perTeam.get(key).push({date, league, team, gf, ga, sotf, sota})
  }
  for(const m of rows){
    const gfH = toNum(m.home_goals), gaH = toNum(m.away_goals)
    const gfA = toNum(m.away_goals), gaA = toNum(m.home_goals)
    const soth = toNum(m.home_shotsOT), sota = toNum(m.away_shotsOT)
    const sotah = toNum(m.away_shotsOT), sotaa = toNum(m.home_shotsOT)
    push(m.home, m.league, m.date, gfH, gaH, soth, sota)
    push(m.away, m.league, m.date, gfA, gaA, sotah, sotaa)
  }

  const out=[]
  perTeam.forEach((arr)=>{
    if(!arr.length) return
    const lg = arr[0].league
    if(leagueFilter && lg!==leagueFilter) return
    const pj = arr.length
    const last = arr.slice(-N)
    const avg = (list, k)=> list.length? (list.reduce((s,x)=> s + (toNum(x[k])||0), 0) / list.length) : 0
    const gf = avg(last,'gf'), gc = avg(last,'ga')
    const sotf = avg(last,'sotf'), sota = avg(last,'sota')
    const dif = gf - gc
    out.push({ team:arr[0].team, league:lg, pj, gf, gc, sotf, sota, dif })
  })

  out.sort((a,b)=> b.dif - a.dif)

  const tb = document.querySelector('#tblTeams tbody')
  tb.innerHTML = out.map(r=> `<tr>
    <td>${r.team}</td>
    <td>${r.league}</td>
    <td class="knum">${r.pj}</td>
    <td class="knum">${r.gf.toFixed(2)}</td>
    <td class="knum">${r.gc.toFixed(2)}</td>
    <td class="knum">${r.sotf.toFixed(2)}</td>
    <td class="knum">${r.sota.toFixed(2)}</td>
    <td class="knum">${r.dif.toFixed(2)}</td>
  </tr>`).join('')
}

// =================== CARGA: CSV o JSON ===================
function refreshLeagueFilter(data){
  const sel = document.getElementById('fLeague')
  const leagues = Array.from(new Set(data.map(r=> r.league))).filter(Boolean).sort()
  sel.innerHTML = '<option value="">(Todas)</option>' + leagues.map(l=> `<option>${l}</option>`).join('')
}
function afterDataLoaded(){
  buildLeagueTeamsMap(RAW)
  setFiLeagueOptions()
  refreshLeagueFilter(FEAT)
  populateHistLeagueOptions()
  rebuildTeamHistory()
}
function handleCSV(text){
  const {data} = parseCSV(text)
  let norm = normalizeObjects(data)
  norm = adaptFromCustomSchema(norm)
  RAW = norm
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  afterDataLoaded()
  alert('Datos CSV cargados: '+FEAT.length+' filas.')
}
function handleJSON(text){
  let obj
  try{ obj = JSON.parse(text) }catch(e){ alert('JSON inválido.'); return }
  let arr = Array.isArray(obj)? obj : (obj && Array.isArray(obj.data)? obj.data : null)
  if(!arr){ alert('El JSON debe ser un array de partidos o {data:[...]}.'); return }
  let norm = normalizeObjects(arr)
  norm = adaptFromCustomSchema(norm)
  RAW = norm
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  afterDataLoaded()
  alert('Datos JSON cargados: '+FEAT.length+' filas.')
}
function loadAuto(text, name){
  const lower = (name||'').toLowerCase()
  if(lower.endsWith('.json')){ handleJSON(text); return }
  try{ const p=JSON.parse(text); if(Array.isArray(p) || (p && typeof p==='object')){ handleJSON(text); return } }catch(e){}
  handleCSV(text)
}

// ======= DEMOS =======
const DEMO_CSV = `Name,Date,League,Match,Home OnGoal Shots at FT,Away OnGoal Shots at FT,Result FT
Argentina Liga Profesional,vie., 28 jul. 2023 18:30,Argentina Liga Profesional de Fútbol,River Plate - Racing Club,6,4,2-1
B,dom., 06 ago. 2023 15:00,Argentina Liga Profesional de Fútbol,Boca Juniors - San Lorenzo,7,3,2-0
C,sáb., 12 ago. 2023 19:00,Argentina Liga Profesional de Fútbol,Racing Club - Independiente,5,6,1-1
D,sáb., 19 ago. 2023 19:00,Argentina Liga Profesional de Fútbol,San Lorenzo - River Plate,3,7,1-3
`
const DEMO_JSON = [
  {"Name":"Argentina Liga Profesional","Date":"vie., 28 jul. 2023 18:30","League":"Argentina Liga Profesional de Fútbol","Match":"River Plate - Racing Club","Home OnGoal Shots at FT":"6","Away OnGoal Shots at FT":"4","Result FT":"2-1"},
  {"Name":"B","Date":"dom., 06 ago. 2023 15:00","League":"Argentina Liga Profesional de Fútbol","Match":"Boca Juniors - San Lorenzo","Home OnGoal Shots at FT":"7","Away OnGoal Shots at FT":"3","Result FT":"2-0"},
  {"Name":"C","Date":"sáb., 12 ago. 2023 19:00","League":"Argentina Liga Profesional de Fútbol","Match":"Racing Club - Independiente","Home OnGoal Shots at FT":"5","Away OnGoal Shots at FT":"6","Result FT":"1-1"},
  {"Name":"D","Date":"sáb., 19 ago. 2023 19:00","League":"Argentina Liga Profesional de Fútbol","Match":"San Lorenzo - River Plate","Home OnGoal Shots at FT":"3","Away OnGoal Shots at FT":"7","Result FT":"1-3"}
]

// =================== PARTIDOS MANUALES ===================
function renderFixtures(){
  const tb = document.querySelector('#tblFixtures tbody')
  tb.innerHTML = MANUAL_FIXTURES.map((r,idx)=> `<tr>
    <td>${r.date||''}</td>
    <td>${r.league||''}</td>
    <td>${r.home||''} vs ${r.away||''}</td>
    <td><button class="btn warn" onclick="removeFixture(${idx})">Quitar</button></td>
  </tr>`).join('')
}
function removeFixture(idx){
  MANUAL_FIXTURES.splice(idx,1)
  RAW = RAW.filter(r=> !r.__manualFixture).concat(MANUAL_FIXTURES)
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})
  renderFixtures()
}
function addFixture(){
  const d = (document.getElementById('fiDate').value||'').trim()
  const l = document.getElementById('fiLeague').value
  const h = document.getElementById('fiHome').value
  const a = document.getElementById('fiAway').value

  if(!d || !l || !h || !a){ alert('Fecha, Liga, Local y Visitante son obligatorios.'); return }
  if(h===a){ alert('Local y Visitante deben ser distintos.'); return }

  const row = {
    date: d, league: l, home: h, away: a,
    y_over25: null, y_btts: null, y_wdl: null,
    __manualFixture: true
  }
  MANUAL_FIXTURES.push(row)

  RAW = RAW.filter(r=> !r.__manualFixture).concat(MANUAL_FIXTURES)
  FEAT = engineerFeatures(RAW, {rollShort:document.getElementById('rollShort').value, rollLong:document.getElementById('rollLong').value})

  renderFixtures()
  maybeToggleAddButton()
}

// =================== EVENTOS UI ===================
document.getElementById('btnDemoCSV').addEventListener('click', ()=> handleCSV(DEMO_CSV))
document.getElementById('btnDemoJSON').addEventListener('click', ()=> handleJSON(JSON.stringify(DEMO_JSON)))

const fileInput = document.getElementById('file')
fileInput.addEventListener('change', (e)=>{
  const f=e.target.files[0]; if(!f) return
  const fr = new FileReader(); fr.onload = ()=> loadAuto(fr.result, f.name); fr.readAsText(f)
})

document.getElementById('btnEntrenar').addEventListener('click', trainAll)
document.getElementById('btnPicks').addEventListener('click', generateProbabilities)
document.getElementById('btnExport').addEventListener('click', exportCSV)
document.getElementById('btnAddFixture').addEventListener('click', addFixture)

document.getElementById('fiLeague').addEventListener('change', onLeagueChange)
document.getElementById('fiDate').addEventListener('input', maybeToggleAddButton)
document.getElementById('fiHome').addEventListener('change', maybeToggleAddButton)
document.getElementById('fiAway').addEventListener('change', maybeToggleAddButton)

// Historial por equipo
document.getElementById('btnRebuildHist').addEventListener('click', rebuildTeamHistory)
document.getElementById('histLeague').addEventListener('change', rebuildTeamHistory)
document.getElementById('histN').addEventListener('input', rebuildTeamHistory)
</script>
</body>
</html>
