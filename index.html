<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Backtesting Fútbol — HTML (TRAIN/TEST, Kelly, Walk-Forward, Monte Carlo)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<style>
  :root{
    --bg:#0f1115; --panel:#171a21; --panel2:#1f2430; --text:#e6eaf2; --muted:#9aa3b2;
    --accent:#7aa2ff; --accent2:#5dd4a4; --warn:#ffb84d; --danger:#ff6b6b; --ok:#79e2a6;
    --border:#2a3140;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--text); font-family:Inter,system-ui,Segoe UI,Arial; 
  }
  header{
    padding:20px; border-bottom:1px solid var(--border); background:linear-gradient(180deg,var(--panel),transparent);
  }
  h1{font-size:20px;margin:0}
  .wrap{max-width:1200px;margin:0 auto;padding:20px;display:grid;gap:16px}
  .grid{display:grid;gap:16px}
  @media(min-width:900px){ .grid-2{grid-template-columns:1fr 1fr} .grid-3{grid-template-columns:repeat(3,1fr)}}
  .card{
    background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:16px;
  }
  .card h2{font-size:16px;margin:.2rem 0 1rem; color:var(--accent)}
  .row{display:flex;gap:12px;flex-wrap:wrap}
  label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
  input, select, button{
    background:var(--panel2); border:1px solid var(--border); color:var(--text); 
    padding:10px 12px; border-radius:10px; font-size:14px;
  }
  input[type="date"]{padding:8px 10px}
  button{cursor:pointer}
  button.primary{background:var(--accent);border-color:transparent;color:#0b1020;font-weight:700}
  button.ghost{background:transparent}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border-bottom:1px solid var(--border);padding:8px;text-align:right}
  th{color:var(--muted);text-align:right}
  td:first-child, th:first-child{text-align:left}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);color:var(--muted)}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .danger{color:var(--danger)}
  .muted{color:var(--muted)}
  .hint{font-size:12px;color:var(--muted)}
  .hr{height:1px;background:var(--border);margin:8px 0 0}
  .footer{color:var(--muted);font-size:12px;text-align:center;padding:10px}
  canvas{max-height:320px}
  .nowrap{white-space:nowrap}
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Backtesting de Fútbol — HTML (Yield, Drawdown, TRAIN/TEST, Walk-Forward 3M, Monte Carlo)</h1>
      <div class="hint">Carga tu CSV histórico (≤ 2 años). El cálculo es local en tu navegador.</div>
    </div>
  </header>

  <main class="wrap">
    <section class="card">
      <h2>1) Datos & Parámetros</h2>
      <div class="grid grid-3">
        <div>
          <label>Archivo CSV de apuestas</label>
          <input id="file" type="file" accept=".csv" />
          <div class="hint">Encabezados: Date,League,Season,MatchID,Home,Away,Market,Selection,Model_Prob,Odds_Taken,Closing_Odds,Result</div>
        </div>
        <div>
          <label>Split Date (TRAIN ≤ fecha, TEST > fecha)</label>
          <input id="splitDate" type="date" />
          <div class="hint">Ej. hoy o fin de la 1ª temporada del rango</div>
        </div>
        <div class="row">
          <div style="min-width:160px">
            <label>Bankroll inicial</label>
            <input id="bankroll" type="number" step="0.01" value="100" />
          </div>
          <div style="min-width:160px">
            <label>Método de Stake</label>
            <select id="stakeMethod">
              <option value="FLAT">FLAT</option>
              <option value="KELLY">KELLY</option>
            </select>
          </div>
          <div style="min-width:160px">
            <label>Fracción de Kelly</label>
            <input id="kellyFrac" type="number" step="0.01" value="0.25" />
          </div>
        </div>
      </div>
      <div class="row" style="margin-top:12px">
        <button id="run" class="primary">Calcular Backtest</button>
        <button id="exportProcessed" class="ghost">Exportar Apuestas Procesadas (CSV)</button>
        <button id="exportResults" class="ghost">Exportar Resultados (CSV)</button>
      </div>
    </section>

    <section class="grid grid-2">
      <div class="card">
        <h2>2) Métricas Globales</h2>
        <table id="metricsTotal">
          <thead><tr><th>Métrica</th><th>Valor</th></tr></thead>
          <tbody></tbody>
        </table>
        <div class="hr"></div>
        <h2>TRAIN / TEST</h2>
        <div class="grid grid-2">
          <div>
            <div class="badge">TRAIN</div>
            <table id="metricsTrain"><thead><tr><th>Métrica</th><th>Valor</th></tr></thead><tbody></tbody></table>
          </div>
          <div>
            <div class="badge">TEST</div>
            <table id="metricsTest"><thead><tr><th>Métrica</th><th>Valor</th></tr></thead><tbody></tbody></table>
          </div>
        </div>
      </div>

      <div class="card">
        <h2>3) Curva de Equity</h2>
        <canvas id="equityChart"></canvas>
        <div class="hint">Incluye stake según método seleccionado.</div>
      </div>
    </section>

    <section class="grid grid-2">
      <div class="card">
        <h2>4) Walk-Forward (bloques 3M)</h2>
        <table id="wf">
          <thead>
            <tr>
              <th class="nowrap">Train Start</th><th class="nowrap">Train End</th>
              <th class="nowrap">Test Start</th><th class="nowrap">Test End</th>
              <th>Bets (Train)</th><th>Yield (Train)</th>
              <th>Bets (Test)</th><th>Yield (Test)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="card">
        <h2>5) Monte Carlo (Yield por apuesta)</h2>
        <table id="mc">
          <thead>
            <tr><th>p05</th><th>p50</th><th>p95</th><th>N Sim</th></tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="hint">Bootstrap con reemplazo sobre el rendimiento por unidad.</div>
      </div>
    </section>

    <section class="card">
      <h2>6) Resumen por Liga / Mercado</h2>
      <div class="grid grid-2">
        <div>
          <div class="badge">Por Liga (TEST)</div>
          <table id="byLeague"><thead><tr><th>Liga</th><th>Bets</th><th>Yield</th><th>Profit</th></tr></thead><tbody></tbody></table>
        </div>
        <div>
          <div class="badge">Por Mercado (TEST)</div>
          <table id="byMarket"><thead><tr><th>Mercado</th><th>Bets</th><th>Yield</th><th>Profit</th></tr></thead><tbody></tbody></table>
        </div>
      </div>
    </section>

    <section class="footer muted">
      Recomendación: compara tu EV contra <span class="badge">Closing_Odds</span>. Si tu edge supera al cierre de forma consistente, es señal de ventaja real.
    </section>
  </main>

<script>
/* -------------------- Utilidades -------------------- */
const fmt = n => (Number.isFinite(n) ? (Math.abs(n)>=1 ? n.toFixed(2) : n.toFixed(4)) : "");
const pct = n => (Number.isFinite(n) ? (n*100).toFixed(2)+"%" : "");
const parseNum = v => v===null||v===undefined||v==="" ? NaN : Number(v);
const parseDate = s => (s ? new Date(s+"T00:00:00") : null);

function monthAdd(d, m){
  const nd = new Date(d);
  nd.setMonth(nd.getMonth()+m);
  return nd;
}

function csvToArray(csvFile){
  return new Promise((resolve, reject)=>{
    Papa.parse(csvFile, {
      header:true, skipEmptyLines:true, dynamicTyping:false,
      complete: res => resolve(res.data), error: err => reject(err)
    });
  });
}

function downloadCSV(filename, rows){
  const process = rows.map(r=>Array.isArray(r)?r:Object.values(r));
  const csv = process.map(r => r.map(x => (x==null?"":String(x)).replace(/"/g,'""')).map(x=>`"${x}"`).join(",")).join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8;"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename; a.click();
  URL.revokeObjectURL(url);
}

/* -------------------- Cálculos núcleo -------------------- */
function computeRows(rows, params){
  // Orden cronológico
  rows = rows.map(r => ({
    Date: r.Date, League: r.League, Season: r.Season, MatchID: r.MatchID,
    Home: r.Home, Away: r.Away, Market: r.Market, Selection: r.Selection,
    Model_Prob: parseNum(r.Model_Prob), Odds_Taken: parseNum(r.Odds_Taken),
    Closing_Odds: parseNum(r.Closing_Odds), Result: String(r.Result||"").toUpperCase()
  })).filter(r => r.Date && r.Odds_Taken);

  rows.sort((a,b)=> new Date(a.Date) - new Date(b.Date));

  const split = parseDate(params.splitDate);
  let bk = Number(params.bankroll);
  const stakeMethod = params.stakeMethod.toUpperCase();
  const kf = Number(params.kellyFrac);

  const out = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const date = parseDate(r.Date);
    const set = (split && date && date<=split) ? "TRAIN" : "TEST";
    const closingImp = Number.isFinite(r.Closing_Odds) && r.Closing_Odds>0 ? 1/r.Closing_Odds : null;
    const edgeClosing = Number.isFinite(closingImp) && Number.isFinite(r.Model_Prob) ? (r.Model_Prob - closingImp) : null;

    // Stake
    let stakeEff = "FLAT";
    let stake = 1;
    if (stakeMethod==="KELLY" && Number.isFinite(r.Model_Prob) && r.Model_Prob>=0 && r.Model_Prob<=1 && r.Odds_Taken>1){
      const p = r.Model_Prob, o = r.Odds_Taken;
      const fstar = ((p*o)-(1-p)) / (o-1);
      const fpos = Math.max(fstar, 0);
      stake = fpos * bk * kf;
      stakeEff = "KELLY";
      if (!Number.isFinite(stake) || stake<=0) { stake=1; stakeEff="FLAT"; }
    }

    // Profit por resultado
    let profit = 0;
    if (r.Result==="W") profit = stake*(r.Odds_Taken - 1);
    else if (r.Result==="L") profit = -stake;
    else profit = 0; // V o vacío

    const bkBefore = bk;
    const bkAfter = bkBefore + profit;
    bk = bkAfter;

    out.push({
      ...r,
      Closing_ImpProb: closingImp,
      Edge_vs_Closing: edgeClosing,
      Stake_Method_Effective: stakeEff,
      Stake: stake,
      Profit: profit,
      Bankroll_Before: bkBefore,
      Bankroll_After: bkAfter,
      Set: set,
      Equity_Curve: bkAfter
    });
  }
  return out;
}

function kpis(list){
  const n = list.length;
  const wins = list.filter(x=>x.Profit>0).length;
  const losses = list.filter(x=>x.Profit<0).length;
  const hit = (wins+losses)>0 ? wins/(wins+losses) : NaN;
  const stakeSum = list.reduce((s,x)=>s+(Number.isFinite(x.Stake)?x.Stake:0),0);
  const profitSum = list.reduce((s,x)=>s+(Number.isFinite(x.Profit)?x.Profit:0),0);
  const yieldR = stakeSum>0 ? profitSum/stakeSum : NaN;

  // Max drawdown sobre equity
  const eq = list.map(x=>x.Equity_Curve);
  let runmax = -Infinity, maxDD = 0;
  for (const v of eq){
    if (!Number.isFinite(v)) continue;
    runmax = Math.max(runmax, v);
    if (runmax>0){
      const dd = (runmax - v)/runmax;
      maxDD = Math.max(maxDD, dd);
    }
  }
  const avgOdds = prom(list.map(x=>x.Odds_Taken));
  const avgStake = prom(list.map(x=>x.Stake));
  return {Bets:n, HitRate:hit, Yield:yieldR, Profit:profitSum, MaxDrawdown:maxDD, AvgOdds:avgOdds, AvgStake:avgStake};
}

function prom(arr){
  const v = arr.filter(Number.isFinite);
  if (!v.length) return NaN;
  return v.reduce((a,b)=>a+b,0)/v.length;
}

/* Walk-Forward 3M */
function walkForward3M(list){
  if (!list.length) return [];
  const dates = list.map(x=>parseDate(x.Date)).filter(Boolean);
  if (!dates.length) return [];
  dates.sort((a,b)=>a-b);
  let cur = new Date(dates[0]); cur.setDate(1);
  const end = new Date(dates[dates.length-1]);
  const out = [];
  while (cur <= end){
    const trainEnd = new Date(monthAdd(cur,3).getTime()-24*3600*1000);
    const testEnd = monthAdd(cur,6);
    const train = list.filter(x=> {
      const d = parseDate(x.Date); return d && d>=cur && d<=trainEnd;
    });
    const test = list.filter(x=> {
      const d = parseDate(x.Date); return d && d>trainEnd && d<=testEnd;
    });
    if (test.length){
      const mTrain = train.length ? kpis(train) : {Yield:NaN,Bets:0};
      const mTest = kpis(test);
      out.push({
        Train_Start: cur.toISOString().slice(0,10),
        Train_End: trainEnd.toISOString().slice(0,10),
        Test_Start: new Date(trainEnd.getTime()+24*3600*1000).toISOString().slice(0,10),
        Test_End: testEnd.toISOString().slice(0,10),
        Train_Bets: mTrain.Bets|0,
        Train_Yield: mTrain.Yield,
        Test_Bets: mTest.Bets|0,
        Test_Yield: mTest.Yield
      });
    }
    cur = monthAdd(cur,3);
  }
  return out;
}

/* Monte Carlo del yield por unidad */
function monteCarlo(list, nSims=2000){
  const perUnit = list
    .map(x => Number.isFinite(x.Stake) && x.Stake>0 ? x.Profit/x.Stake : NaN)
    .filter(Number.isFinite);
  if (!perUnit.length) return {p05:NaN,p50:NaN,p95:NaN,n:0};
  const rng = (function(seed=42){
    let s = seed >>> 0;
    return ()=> (s = (s*1664525 + 1013904223) >>> 0) / 2**32;
  })();

  function choice(){
    const i = Math.floor(rng()*perUnit.length);
    return perUnit[i];
    }
  const sims = [];
  for (let i=0;i<nSims;i++){
    const draw = Array.from({length:perUnit.length}, choice);
    const m = draw.reduce((a,b)=>a+b,0)/draw.length;
    sims.push(m);
  }
  sims.sort((a,b)=>a-b);
  const q = p => sims[Math.min(sims.length-1, Math.max(0, Math.floor(p*(sims.length-1))))];
  return {p05:q(0.05), p50:q(0.50), p95:q(0.95), n:nSims};
}

/* Agrupados por liga/mercado (TEST) */
function groupByKey(list, key){
  const map = new Map();
  for (const x of list){
    const k = x[key] || "(sin dato)";
    if (!map.has(k)) map.set(k, []);
    map.get(k).push(x);
  }
  const rows = [];
  for (const [k, arr] of map){
    const m = kpis(arr);
    rows.push({Key:k, Bets:m.Bets, Yield:m.Yield, Profit:m.Profit});
  }
  rows.sort((a,b)=> b.Yield - a.Yield);
  return rows;
}

/* -------------------- UI Lógica -------------------- */
let equityChart;

function fillMetrics(tbodyEl, m){
  const rows = [
    ["Total Bets", m.Bets],
    ["Hit Rate", pct(m.HitRate)],
    ["Yield (ROI)", pct(m.Yield)],
    ["Profit", fmt(m.Profit)],
    ["Max Drawdown", pct(m.MaxDrawdown)],
    ["Avg Odds", fmt(m.AvgOdds)],
    ["Avg Stake", fmt(m.AvgStake)]
  ];
  tbodyEl.innerHTML = rows.map(r=>`<tr><td>${r[0]}</td><td>${r[1]}</td></tr>`).join("");
}

function fillTable(tableBody, rows, cols){
  tableBody.innerHTML = rows.map(r=>{
    return `<tr>${cols.map(c => `<td>${c.format ? c.format(r[c.key]) : (r[c.key]??"")}</td>`).join("")}</tr>`;
  }).join("");
}

function drawEquity(list){
  const labels = list.map(x=>x.Date);
  const data = list.map(x=>x.Equity_Curve);
  const ctx = document.getElementById("equityChart");
  if (equityChart) equityChart.destroy();
  equityChart = new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [{label:"Equity", data, tension:.2, borderWidth:2, pointRadius:0}]
    },
    options: {
      responsive:true,
      scales:{ x:{ticks:{maxTicksLimit:8}}, y:{beginAtZero:false} },
      plugins:{ legend:{display:false} }
    }
  });
}

/* -------------------- Eventos -------------------- */
const fileEl = document.getElementById("file");
const splitEl = document.getElementById("splitDate");
const bankrollEl = document.getElementById("bankroll");
const stakeMethodEl = document.getElementById("stakeMethod");
const kellyFracEl = document.getElementById("kellyFrac");

document.getElementById("run").addEventListener("click", async ()=>{
  const file = fileEl.files && fileEl.files[0];
  if (!file){ alert("Carga un archivo CSV primero."); return; }

  const raw = await csvToArray(file);
  const params = {
    splitDate: splitEl.value || new Date().toISOString().slice(0,10),
    bankroll: bankrollEl.value || 100,
    stakeMethod: stakeMethodEl.value || "FLAT",
    kellyFrac: kellyFracEl.value || 0.25
  };
  const processed = computeRows(raw, params);

  // KPIs
  const total = kpis(processed);
  const train = kpis(processed.filter(x=>x.Set==="TRAIN"));
  const test = kpis(processed.filter(x=>x.Set==="TEST"));

  fillMetrics(document.querySelector("#metricsTotal tbody"), total);
  fillMetrics(document.querySelector("#metricsTrain tbody"), train);
  fillMetrics(document.querySelector("#metricsTest tbody"), test);

  // Equity
  drawEquity(processed);

  // Walk-Forward
  const wfRows = walkForward3M(processed);
  fillTable(document.querySelector("#wf tbody"), wfRows, [
    {key:"Train_Start"}, {key:"Train_End"}, {key:"Test_Start"}, {key:"Test_End"},
    {key:"Train_Bets"}, {key:"Train_Yield", format:pct}, {key:"Test_Bets"}, {key:"Test_Yield", format:pct}
  ]);

  // Monte Carlo (TOTAL y TEST por simplicidad mostramos TOTAL)
  const mc = monteCarlo(processed);
  document.querySelector("#mc tbody").innerHTML =
    `<tr><td>${pct(mc.p05)}</td><td>${pct(mc.p50)}</td><td>${pct(mc.p95)}</td><td>${mc.n}</td></tr>`;

  // Resumen por Liga/Mercado en TEST
  const testSet = processed.filter(x=>x.Set==="TEST");
  const byLeague = groupByKey(testSet, "League");
  const byMarket = groupByKey(testSet, "Market");

  fillTable(document.querySelector("#byLeague tbody"), byLeague, [
    {key:"Key"}, {key:"Bets"}, {key:"Yield", format:pct}, {key:"Profit", format:fmt}
  ]);
  fillTable(document.querySelector("#byMarket tbody"), byMarket, [
    {key:"Key"}, {key:"Bets"}, {key:"Yield", format:pct}, {key:"Profit", format:fmt}
  ]);

  // Guardamos en ventana para exportar
  window.__bt_last = {processed, total, train, test, wfRows, mc, byLeague, byMarket};
});

document.getElementById("exportProcessed").addEventListener("click", ()=>{
  const st = window.__bt_last;
  if (!st?.processed) { alert("Primero ejecuta el backtest."); return; }
  const headers = Object.keys(st.processed[0]||{});
  const rows = [headers].concat(st.processed.map(o=>headers.map(h=>o[h])));
  downloadCSV("apuestas_procesadas.csv", rows);
});

document.getElementById("exportResults").addEventListener("click", ()=>{
  const st = window.__bt_last;
  if (!st){ alert("Primero ejecuta el backtest."); return; }
  const rows = [];
  const pushBlock = (name, m) => {
    rows.push([name,"Valor"]);
    rows.push(["Bets", m.Bets]);
    rows.push(["HitRate", m.HitRate]);
    rows.push(["Yield", m.Yield]);
    rows.push(["Profit", m.Profit]);
    rows.push(["MaxDrawdown", m.MaxDrawdown]);
    rows.push(["AvgOdds", m.AvgOdds]);
    rows.push(["AvgStake", m.AvgStake]);
    rows.push([]);
  };
  pushBlock("TOTAL", st.total);
  pushBlock("TRAIN", st.train);
  pushBlock("TEST", st.test);
  rows.push(["WF","Train_Start","Train_End","Test_Start","Test_End","Train_Bets","Train_Yield","Test_Bets","Test_Yield"]);
  (st.wfRows||[]).forEach(r=> rows.push(["WF", r.Train_Start, r.Train_End, r.Test_Start, r.Test_End, r.Train_Bets, r.Train_Yield, r.Test_Bets, r.Test_Yield]));
  rows.push([]);
  rows.push(["MonteCarlo","p05","p50","p95","N"]);
  rows.push(["TOTAL", st.mc.p05, st.mc.p50, st.mc.p95, st.mc.n]);
  rows.push([]);
  rows.push(["ByLeague TEST","Liga","Bets","Yield","Profit"]);
  (st.byLeague||[]).forEach(r=> rows.push(["ByLeague", r.Key, r.Bets, r.Yield, r.Profit]));
  rows.push([]);
  rows.push(["ByMarket TEST","Mercado","Bets","Yield","Profit"]);
  (st.byMarket||[]).forEach(r=> rows.push(["ByMarket", r.Key, r.Bets, r.Yield, r.Profit]));
  downloadCSV("resultados_backtesting.csv", rows);
});
</script>
</body>
</html>